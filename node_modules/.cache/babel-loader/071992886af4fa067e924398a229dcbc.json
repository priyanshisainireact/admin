{"ast":null,"code":"var expat = require('node-expat');\n\nvar sanitizer = require('./sanitize.js');\n\nvar joi = require('joi');\n\nvar hoek = require('hoek'); // This object will hold the final result.\n\n\nvar obj = {};\nvar currentObject = {};\nvar ancestors = [];\nvar currentElementName = null;\nvar options = {}; //configuration options\n\nfunction startElement(name, attrs) {\n  currentElementName = name;\n\n  if (options.coerce) {\n    // Looping here in stead of making coerce generic as object walk is unnecessary\n    for (var key in attrs) {\n      attrs[key] = coerce(attrs[key], key);\n    }\n  }\n\n  if (!(name in currentObject)) {\n    if (options.arrayNotation || options.forceArrays[name]) {\n      currentObject[name] = [attrs];\n    } else {\n      currentObject[name] = attrs;\n    }\n  } else if (!(currentObject[name] instanceof Array)) {\n    // Put the existing object in an array.\n    var newArray = [currentObject[name]]; // Add the new object to the array.\n\n    newArray.push(attrs); // Point to the new array.\n\n    currentObject[name] = newArray;\n  } else {\n    // An array already exists, push the attributes on to it.\n    currentObject[name].push(attrs);\n  } // Store the current (old) parent.\n\n\n  ancestors.push(currentObject); // We are now working with this object, so it becomes the current parent.\n\n  if (currentObject[name] instanceof Array) {\n    // If it is an array, get the last element of the array.\n    currentObject = currentObject[name][currentObject[name].length - 1];\n  } else {\n    // Otherwise, use the object itself.\n    currentObject = currentObject[name];\n  }\n}\n\nfunction text(data) {\n  currentObject[textNodeName()] = (currentObject[textNodeName()] || '') + data;\n}\n\nfunction endElement(name) {\n  if (currentObject[textNodeName()]) {\n    if (options.trim) {\n      currentObject[textNodeName()] = currentObject[textNodeName()].trim();\n    } // node-expat already reverse sanitizes it whether we like it or not\n    //if (options.sanitize) {\n    //    currentObject[textNodeName()] = sanitizer.sanitize(currentObject[textNodeName()], true);\n    //}\n\n\n    currentObject[textNodeName()] = coerce(currentObject[textNodeName()], name);\n  }\n\n  if (currentElementName !== name) {\n    delete currentObject[textNodeName()];\n  } // This should check to make sure that the name we're ending\n  // matches the name we started on.\n\n\n  var ancestor = ancestors.pop();\n\n  if (!options.reversible) {\n    if (textNodeName() in currentObject && Object.keys(currentObject).length == 1) {\n      if (ancestor[name] instanceof Array) {\n        ancestor[name].push(ancestor[name].pop()[textNodeName()]);\n      } else {\n        ancestor[name] = currentObject[textNodeName()];\n      }\n    }\n  }\n\n  currentObject = ancestor;\n}\n\nfunction coerce(value, key) {\n  if (!options.coerce || value.trim() === '') {\n    return value;\n  }\n\n  if (typeof options.coerce[key] === 'function') return options.coerce[key](value);\n  var num = Number(value);\n\n  if (!isNaN(num)) {\n    return num;\n  }\n\n  var _value = value.toLowerCase();\n\n  if (_value == 'true') {\n    return true;\n  }\n\n  if (_value == 'false') {\n    return false;\n  }\n\n  return value;\n}\n\nfunction textNodeName() {\n  return options.alternateTextNode ? typeof options.alternateTextNode === 'string' ? options.alternateTextNode : '_t' : '$t';\n}\n/**\n * Parses xml to json using node-expat.\n * @param {String|Buffer} xml The xml to be parsed to json.\n * @param {Object} _options An object with options provided by the user.\n * The available options are:\n *  - object: If true, the parser returns a Javascript object instead of\n *            a JSON string.\n *  - reversible: If true, the parser generates a reversible JSON, mainly\n *                characterized by the presence of the property $t.\n *  - sanitize_values: If true, the parser escapes any element value in the xml\n * that has any of the following characters: <, >, (, ), #, #, &, \", '.\n *  - alternateTextNode (boolean OR string): \n *      If false or not specified: default of $t is used \n *      If true, whenever $t is returned as an end point, is is substituted with _t  \n *      it String, whenever $t is returned as an end point, is is substituted with the String value (care advised)\n *\n * @return {String|Object} A String or an Object with the JSON representation\n * of the XML.\n */\n\n\nmodule.exports = function (xml, _options) {\n  _options = _options || {};\n  var parser = new expat.Parser('UTF-8');\n  parser.on('startElement', startElement);\n  parser.on('text', text);\n  parser.on('endElement', endElement);\n  obj = currentObject = {};\n  ancestors = [];\n  currentElementName = null;\n  var schema = {\n    object: joi.boolean().default(false),\n    reversible: joi.boolean().default(false),\n    coerce: joi.alternatives([joi.boolean(), joi.object()]).default(false),\n    sanitize: joi.boolean().default(true),\n    trim: joi.boolean().default(true),\n    arrayNotation: joi.alternatives([joi.boolean(), joi.array()]).default(false),\n    alternateTextNode: [joi.boolean().default(false), joi.string().default(false)]\n  };\n  var validation = joi.validate(_options, schema);\n  hoek.assert(validation.error === null, validation.error);\n  options = validation.value;\n  options.forceArrays = {};\n\n  if (Array.isArray(options.arrayNotation)) {\n    options.arrayNotation.forEach(function (i) {\n      options.forceArrays[i] = true;\n    });\n    options.arrayNotation = false;\n  }\n\n  if (!parser.parse(xml)) {\n    throw new Error('There are errors in your xml file: ' + parser.getError());\n  }\n\n  if (options.object) {\n    return obj;\n  }\n\n  var json = JSON.stringify(obj); //See: http://timelessrepo.com/json-isnt-a-javascript-subset\n\n  json = json.replace(/\\u2028/g, \"\\\\u2028\").replace(/\\u2029/g, \"\\\\u2029\");\n  return json;\n};","map":{"version":3,"sources":["/home/cloudmynds/Desktop/admin/node_modules/xml2json/lib/xml2json.js"],"names":["expat","require","sanitizer","joi","hoek","obj","currentObject","ancestors","currentElementName","options","startElement","name","attrs","coerce","key","arrayNotation","forceArrays","Array","newArray","push","length","text","data","textNodeName","endElement","trim","ancestor","pop","reversible","Object","keys","value","num","Number","isNaN","_value","toLowerCase","alternateTextNode","module","exports","xml","_options","parser","Parser","on","schema","object","boolean","default","alternatives","sanitize","array","string","validation","validate","assert","error","isArray","forEach","i","parse","Error","getError","json","JSON","stringify","replace"],"mappings":"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","sourcesContent":["var expat = require('node-expat');\nvar sanitizer = require('./sanitize.js')\nvar joi = require('joi');\nvar hoek = require('hoek');\n\n// This object will hold the final result.\nvar obj = {};\nvar currentObject = {};\nvar ancestors = [];\nvar currentElementName = null;\n\nvar options = {}; //configuration options\nfunction startElement(name, attrs) {\n    currentElementName = name;\n    if(options.coerce) {\n        // Looping here in stead of making coerce generic as object walk is unnecessary\n        for(var key in attrs) {\n            attrs[key] = coerce(attrs[key],key);\n        }\n    }\n\n    if (! (name in currentObject)) {\n        if(options.arrayNotation || options.forceArrays[name]) {\n            currentObject[name] = [attrs];\n        } else {\n            currentObject[name] = attrs;\n        }\n    } else if (! (currentObject[name] instanceof Array)) {\n        // Put the existing object in an array.\n        var newArray = [currentObject[name]];\n        // Add the new object to the array.\n        newArray.push(attrs);\n        // Point to the new array.\n        currentObject[name] = newArray;\n    } else {\n        // An array already exists, push the attributes on to it.\n        currentObject[name].push(attrs);\n    }\n\n    // Store the current (old) parent.\n    ancestors.push(currentObject);\n\n    // We are now working with this object, so it becomes the current parent.\n    if (currentObject[name] instanceof Array) {\n        // If it is an array, get the last element of the array.\n        currentObject = currentObject[name][currentObject[name].length - 1];\n    } else {\n        // Otherwise, use the object itself.\n        currentObject = currentObject[name];\n    }\n}\n\nfunction text(data) {\n    currentObject[textNodeName()] = (currentObject[textNodeName()] || '') + data;\n}\n\nfunction endElement(name) {\n    if (currentObject[textNodeName()]) {\n        if (options.trim) {\n            currentObject[textNodeName()] = currentObject[textNodeName()].trim()\n        }\n\n        // node-expat already reverse sanitizes it whether we like it or not\n        //if (options.sanitize) {\n        //    currentObject[textNodeName()] = sanitizer.sanitize(currentObject[textNodeName()], true);\n        //}\n\n        currentObject[textNodeName()] = coerce(currentObject[textNodeName()],name);\n    }\n\n    if (currentElementName !== name) {\n        delete currentObject[textNodeName()];\n    }\n    // This should check to make sure that the name we're ending\n    // matches the name we started on.\n    var ancestor = ancestors.pop();\n    if (!options.reversible) {\n        if ((textNodeName() in currentObject) && (Object.keys(currentObject).length == 1)) {\n            if (ancestor[name] instanceof Array) {\n                ancestor[name].push(ancestor[name].pop()[textNodeName()]);\n            } else {\n                ancestor[name] = currentObject[textNodeName()];\n            }\n        }\n    }\n\n    currentObject = ancestor;\n}\n\nfunction coerce(value,key) {\n    if (!options.coerce || value.trim() === '') {\n        return value;\n    }\n\n    if (typeof options.coerce[key] === 'function')\n        return options.coerce[key](value);\n\n    var num = Number(value);\n    if (!isNaN(num)) {\n        return num;\n    }\n\n    var _value = value.toLowerCase();\n\n    if (_value == 'true') {\n        return true;\n    }\n\n    if (_value == 'false') {\n        return false;\n    }\n\n    return value;\n}\n\nfunction textNodeName() {\n    return options.alternateTextNode ? typeof options.alternateTextNode === 'string' ? options.alternateTextNode : '_t' : '$t'\n}\n\n\n/**\n * Parses xml to json using node-expat.\n * @param {String|Buffer} xml The xml to be parsed to json.\n * @param {Object} _options An object with options provided by the user.\n * The available options are:\n *  - object: If true, the parser returns a Javascript object instead of\n *            a JSON string.\n *  - reversible: If true, the parser generates a reversible JSON, mainly\n *                characterized by the presence of the property $t.\n *  - sanitize_values: If true, the parser escapes any element value in the xml\n * that has any of the following characters: <, >, (, ), #, #, &, \", '.\n *  - alternateTextNode (boolean OR string): \n *      If false or not specified: default of $t is used \n *      If true, whenever $t is returned as an end point, is is substituted with _t  \n *      it String, whenever $t is returned as an end point, is is substituted with the String value (care advised)\n *\n * @return {String|Object} A String or an Object with the JSON representation\n * of the XML.\n */\nmodule.exports = function(xml, _options) {\n\n    _options = _options || {};\n    var parser = new expat.Parser('UTF-8');\n\n    parser.on('startElement', startElement);\n    parser.on('text', text);\n    parser.on('endElement', endElement);\n\n    obj = currentObject = {};\n    ancestors = [];\n    currentElementName = null;\n\n    var schema = {\n        object: joi.boolean().default(false),\n        reversible: joi.boolean().default(false),\n        coerce: joi.alternatives([joi.boolean(), joi.object()]).default(false),\n        sanitize: joi.boolean().default(true),\n        trim: joi.boolean().default(true),\n        arrayNotation: joi.alternatives([joi.boolean(), joi.array()]).default(false),\n        alternateTextNode: [joi.boolean().default(false), joi.string().default(false)]\n    };\n    var validation = joi.validate(_options, schema);\n    hoek.assert(validation.error === null, validation.error);\n    options = validation.value;\n    options.forceArrays = {};\n    if (Array.isArray(options.arrayNotation)) {\n        options.arrayNotation.forEach(function(i) {\n            options.forceArrays[i] = true;\n        });\n        options.arrayNotation = false;\n    }\n    if (!parser.parse(xml)) {\n        throw new Error('There are errors in your xml file: ' + parser.getError());\n    }\n\n    if (options.object) {\n        return obj;\n    }\n\n    var json = JSON.stringify(obj);\n\n    //See: http://timelessrepo.com/json-isnt-a-javascript-subset\n    json = json.replace(/\\u2028/g, '\\\\u2028').replace(/\\u2029/g, '\\\\u2029');\n    \n    return json;\n};\n"]},"metadata":{},"sourceType":"script"}