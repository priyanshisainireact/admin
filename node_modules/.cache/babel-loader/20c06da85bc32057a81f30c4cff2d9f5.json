{"ast":null,"code":"'use strict'; // Load modules\n\nvar _createForOfIteratorHelper = require(\"/home/cloudmynds/Desktop/admin/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"/home/cloudmynds/Desktop/admin/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/cloudmynds/Desktop/admin/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _get = require(\"/home/cloudmynds/Desktop/admin/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"/home/cloudmynds/Desktop/admin/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/home/cloudmynds/Desktop/admin/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/home/cloudmynds/Desktop/admin/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar Hoek = require('hoek');\n\nvar Topo = require('topo');\n\nvar Any = require('../any');\n\nvar Errors = require('../../errors');\n\nvar Cast = require('../../cast'); // Declare internals\n\n\nvar internals = {};\n\ninternals.Object = /*#__PURE__*/function (_Any) {\n  _inherits(_class, _Any);\n\n  var _super = _createSuper(_class);\n\n  function _class() {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    _this = _super.call(this);\n    _this._type = 'object';\n    _this._inner.children = null;\n    _this._inner.renames = [];\n    _this._inner.dependencies = [];\n    _this._inner.patterns = [];\n    return _this;\n  }\n\n  _createClass(_class, [{\n    key: \"_init\",\n    value: function _init() {\n      return arguments.length ? this.keys.apply(this, arguments) : this;\n    }\n  }, {\n    key: \"_base\",\n    value: function _base(value, state, options) {\n      var target = value;\n      var errors = [];\n\n      var finish = function finish() {\n        return {\n          value: target,\n          errors: errors.length ? errors : null\n        };\n      };\n\n      if (typeof value === 'string' && options.convert) {\n        value = internals.safeParse(value);\n      }\n\n      var type = this._flags.func ? 'function' : 'object';\n\n      if (!value || typeof value !== type || Array.isArray(value)) {\n        errors.push(this.createError(type + '.base', null, state, options));\n        return finish();\n      } // Skip if there are no other rules to test\n\n\n      if (!this._inner.renames.length && !this._inner.dependencies.length && !this._inner.children && // null allows any keys\n      !this._inner.patterns.length) {\n        target = value;\n        return finish();\n      } // Ensure target is a local copy (parsed) or shallow copy\n\n\n      if (target === value) {\n        if (type === 'object') {\n          target = Object.create(Object.getPrototypeOf(value));\n        } else {\n          target = function target() {\n            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n              args[_key] = arguments[_key];\n            }\n\n            return value.apply(this, args);\n          };\n\n          target.prototype = Hoek.clone(value.prototype);\n        }\n\n        var valueKeys = Object.keys(value);\n\n        for (var i = 0; i < valueKeys.length; ++i) {\n          target[valueKeys[i]] = value[valueKeys[i]];\n        }\n      } else {\n        target = value;\n      } // Rename keys\n\n\n      var renamed = {};\n\n      for (var _i = 0; _i < this._inner.renames.length; ++_i) {\n        var rename = this._inner.renames[_i];\n\n        if (rename.isRegExp) {\n          var targetKeys = Object.keys(target);\n          var matchedTargetKeys = [];\n\n          for (var j = 0; j < targetKeys.length; ++j) {\n            if (rename.from.test(targetKeys[j])) {\n              matchedTargetKeys.push(targetKeys[j]);\n            }\n          }\n\n          var allUndefined = matchedTargetKeys.every(function (key) {\n            return target[key] === undefined;\n          });\n\n          if (rename.options.ignoreUndefined && allUndefined) {\n            continue;\n          }\n\n          if (!rename.options.multiple && renamed[rename.to]) {\n            errors.push(this.createError('object.rename.regex.multiple', {\n              from: matchedTargetKeys,\n              to: rename.to\n            }, state, options));\n\n            if (options.abortEarly) {\n              return finish();\n            }\n          }\n\n          if (Object.prototype.hasOwnProperty.call(target, rename.to) && !rename.options.override && !renamed[rename.to]) {\n            errors.push(this.createError('object.rename.regex.override', {\n              from: matchedTargetKeys,\n              to: rename.to\n            }, state, options));\n\n            if (options.abortEarly) {\n              return finish();\n            }\n          }\n\n          if (allUndefined) {\n            delete target[rename.to];\n          } else {\n            target[rename.to] = target[matchedTargetKeys[matchedTargetKeys.length - 1]];\n          }\n\n          renamed[rename.to] = true;\n\n          if (!rename.options.alias) {\n            for (var _j = 0; _j < matchedTargetKeys.length; ++_j) {\n              delete target[matchedTargetKeys[_j]];\n            }\n          }\n        } else {\n          if (rename.options.ignoreUndefined && target[rename.from] === undefined) {\n            continue;\n          }\n\n          if (!rename.options.multiple && renamed[rename.to]) {\n            errors.push(this.createError('object.rename.multiple', {\n              from: rename.from,\n              to: rename.to\n            }, state, options));\n\n            if (options.abortEarly) {\n              return finish();\n            }\n          }\n\n          if (Object.prototype.hasOwnProperty.call(target, rename.to) && !rename.options.override && !renamed[rename.to]) {\n            errors.push(this.createError('object.rename.override', {\n              from: rename.from,\n              to: rename.to\n            }, state, options));\n\n            if (options.abortEarly) {\n              return finish();\n            }\n          }\n\n          if (target[rename.from] === undefined) {\n            delete target[rename.to];\n          } else {\n            target[rename.to] = target[rename.from];\n          }\n\n          renamed[rename.to] = true;\n\n          if (!rename.options.alias) {\n            delete target[rename.from];\n          }\n        }\n      } // Validate schema\n\n\n      if (!this._inner.children && // null allows any keys\n      !this._inner.patterns.length && !this._inner.dependencies.length) {\n        return finish();\n      }\n\n      var unprocessed = new Set(Object.keys(target));\n\n      if (this._inner.children) {\n        var stripProps = [];\n\n        for (var _i2 = 0; _i2 < this._inner.children.length; ++_i2) {\n          var child = this._inner.children[_i2];\n          var key = child.key;\n          var item = target[key];\n          unprocessed.delete(key);\n          var localState = {\n            key: key,\n            path: state.path.concat(key),\n            parent: target,\n            reference: state.reference\n          };\n\n          var result = child.schema._validate(item, localState, options);\n\n          if (result.errors) {\n            errors.push(this.createError('object.child', {\n              key: key,\n              child: child.schema._getLabel(key),\n              reason: result.errors\n            }, localState, options));\n\n            if (options.abortEarly) {\n              return finish();\n            }\n          } else {\n            if (child.schema._flags.strip || result.value === undefined && result.value !== item) {\n              stripProps.push(key);\n              target[key] = result.finalValue;\n            } else if (result.value !== undefined) {\n              target[key] = result.value;\n            }\n          }\n        }\n\n        for (var _i3 = 0; _i3 < stripProps.length; ++_i3) {\n          delete target[stripProps[_i3]];\n        }\n      } // Unknown keys\n\n\n      if (unprocessed.size && this._inner.patterns.length) {\n        var _iterator = _createForOfIteratorHelper(unprocessed),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var _key2 = _step.value;\n            var _localState = {\n              key: _key2,\n              path: state.path.concat(_key2),\n              parent: target,\n              reference: state.reference\n            };\n            var _item = target[_key2];\n\n            for (var _i4 = 0; _i4 < this._inner.patterns.length; ++_i4) {\n              var pattern = this._inner.patterns[_i4];\n\n              if (pattern.regex ? pattern.regex.test(_key2) : !pattern.schema.validate(_key2).error) {\n                unprocessed.delete(_key2);\n\n                var _result = pattern.rule._validate(_item, _localState, options);\n\n                if (_result.errors) {\n                  errors.push(this.createError('object.child', {\n                    key: _key2,\n                    child: pattern.rule._getLabel(_key2),\n                    reason: _result.errors\n                  }, _localState, options));\n\n                  if (options.abortEarly) {\n                    return finish();\n                  }\n                }\n\n                target[_key2] = _result.value;\n              }\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n\n      if (unprocessed.size && (this._inner.children || this._inner.patterns.length)) {\n        if (options.stripUnknown && this._flags.allowUnknown !== true || options.skipFunctions) {\n          var stripUnknown = options.stripUnknown ? options.stripUnknown === true ? true : !!options.stripUnknown.objects : false;\n\n          var _iterator2 = _createForOfIteratorHelper(unprocessed),\n              _step2;\n\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var _key3 = _step2.value;\n\n              if (stripUnknown) {\n                delete target[_key3];\n                unprocessed.delete(_key3);\n              } else if (typeof target[_key3] === 'function') {\n                unprocessed.delete(_key3);\n              }\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n        }\n\n        if (this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown) {\n          var _iterator3 = _createForOfIteratorHelper(unprocessed),\n              _step3;\n\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var unprocessedKey = _step3.value;\n              errors.push(this.createError('object.allowUnknown', {\n                child: unprocessedKey\n              }, {\n                key: unprocessedKey,\n                path: state.path.concat(unprocessedKey)\n              }, options, {}));\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n        }\n      } // Validate dependencies\n\n\n      for (var _i5 = 0; _i5 < this._inner.dependencies.length; ++_i5) {\n        var dep = this._inner.dependencies[_i5];\n\n        var _err = internals[dep.type].call(this, dep.key !== null && target[dep.key], dep.peers, target, {\n          key: dep.key,\n          path: dep.key === null ? state.path : state.path.concat(dep.key)\n        }, options);\n\n        if (_err instanceof Errors.Err) {\n          errors.push(_err);\n\n          if (options.abortEarly) {\n            return finish();\n          }\n        }\n      }\n\n      return finish();\n    }\n  }, {\n    key: \"keys\",\n    value: function keys(schema) {\n      Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');\n      Hoek.assert(!schema || !(schema instanceof Any), 'Object schema cannot be a joi schema');\n      var obj = this.clone();\n\n      if (!schema) {\n        obj._inner.children = null;\n        return obj;\n      }\n\n      var children = Object.keys(schema);\n\n      if (!children.length) {\n        obj._inner.children = [];\n        return obj;\n      }\n\n      var topo = new Topo();\n\n      if (obj._inner.children) {\n        for (var i = 0; i < obj._inner.children.length; ++i) {\n          var child = obj._inner.children[i]; // Only add the key if we are not going to replace it later\n\n          if (!children.includes(child.key)) {\n            topo.add(child, {\n              after: child._refs,\n              group: child.key\n            });\n          }\n        }\n      }\n\n      for (var _i6 = 0; _i6 < children.length; ++_i6) {\n        var key = children[_i6];\n        var _child = schema[key];\n\n        try {\n          var cast = Cast.schema(this._currentJoi, _child);\n          topo.add({\n            key: key,\n            schema: cast\n          }, {\n            after: cast._refs,\n            group: key\n          });\n        } catch (castErr) {\n          if (castErr.hasOwnProperty('path')) {\n            castErr.path = key + '.' + castErr.path;\n          } else {\n            castErr.path = key;\n          }\n\n          throw castErr;\n        }\n      }\n\n      obj._inner.children = topo.nodes;\n      return obj;\n    }\n  }, {\n    key: \"append\",\n    value: function append(schema) {\n      // Skip any changes\n      if (schema === null || schema === undefined || Object.keys(schema).length === 0) {\n        return this;\n      }\n\n      return this.keys(schema);\n    }\n  }, {\n    key: \"unknown\",\n    value: function unknown(allow) {\n      var value = allow !== false;\n\n      if (this._flags.allowUnknown === value) {\n        return this;\n      }\n\n      var obj = this.clone();\n      obj._flags.allowUnknown = value;\n      return obj;\n    }\n  }, {\n    key: \"length\",\n    value: function length(limit) {\n      Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\n      return this._test('length', limit, function (value, state, options) {\n        if (Object.keys(value).length === limit) {\n          return value;\n        }\n\n        return this.createError('object.length', {\n          limit: limit\n        }, state, options);\n      });\n    }\n  }, {\n    key: \"min\",\n    value: function min(limit) {\n      Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\n      return this._test('min', limit, function (value, state, options) {\n        if (Object.keys(value).length >= limit) {\n          return value;\n        }\n\n        return this.createError('object.min', {\n          limit: limit\n        }, state, options);\n      });\n    }\n  }, {\n    key: \"max\",\n    value: function max(limit) {\n      Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\n      return this._test('max', limit, function (value, state, options) {\n        if (Object.keys(value).length <= limit) {\n          return value;\n        }\n\n        return this.createError('object.max', {\n          limit: limit\n        }, state, options);\n      });\n    }\n  }, {\n    key: \"pattern\",\n    value: function pattern(_pattern, schema) {\n      var isRegExp = _pattern instanceof RegExp;\n      Hoek.assert(isRegExp || _pattern instanceof Any, 'pattern must be a regex or schema');\n      Hoek.assert(schema !== undefined, 'Invalid rule');\n\n      if (isRegExp) {\n        _pattern = new RegExp(_pattern.source, _pattern.ignoreCase ? 'i' : undefined); // Future version should break this and forbid unsupported regex flags\n      }\n\n      try {\n        schema = Cast.schema(this._currentJoi, schema);\n      } catch (castErr) {\n        if (castErr.hasOwnProperty('path')) {\n          castErr.message = castErr.message + '(' + castErr.path + ')';\n        }\n\n        throw castErr;\n      }\n\n      var obj = this.clone();\n\n      if (isRegExp) {\n        obj._inner.patterns.push({\n          regex: _pattern,\n          rule: schema\n        });\n      } else {\n        obj._inner.patterns.push({\n          schema: _pattern,\n          rule: schema\n        });\n      }\n\n      return obj;\n    }\n  }, {\n    key: \"schema\",\n    value: function schema() {\n      return this._test('schema', null, function (value, state, options) {\n        if (value instanceof Any) {\n          return value;\n        }\n\n        return this.createError('object.schema', null, state, options);\n      });\n    }\n  }, {\n    key: \"with\",\n    value: function _with(key, peers) {\n      Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\n      return this._dependency('with', key, peers);\n    }\n  }, {\n    key: \"without\",\n    value: function without(key, peers) {\n      Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\n      return this._dependency('without', key, peers);\n    }\n  }, {\n    key: \"xor\",\n    value: function xor() {\n      for (var _len2 = arguments.length, peers = new Array(_len2), _key4 = 0; _key4 < _len2; _key4++) {\n        peers[_key4] = arguments[_key4];\n      }\n\n      peers = Hoek.flatten(peers);\n      return this._dependency('xor', null, peers);\n    }\n  }, {\n    key: \"or\",\n    value: function or() {\n      for (var _len3 = arguments.length, peers = new Array(_len3), _key5 = 0; _key5 < _len3; _key5++) {\n        peers[_key5] = arguments[_key5];\n      }\n\n      peers = Hoek.flatten(peers);\n      return this._dependency('or', null, peers);\n    }\n  }, {\n    key: \"and\",\n    value: function and() {\n      for (var _len4 = arguments.length, peers = new Array(_len4), _key6 = 0; _key6 < _len4; _key6++) {\n        peers[_key6] = arguments[_key6];\n      }\n\n      peers = Hoek.flatten(peers);\n      return this._dependency('and', null, peers);\n    }\n  }, {\n    key: \"nand\",\n    value: function nand() {\n      for (var _len5 = arguments.length, peers = new Array(_len5), _key7 = 0; _key7 < _len5; _key7++) {\n        peers[_key7] = arguments[_key7];\n      }\n\n      peers = Hoek.flatten(peers);\n      return this._dependency('nand', null, peers);\n    }\n  }, {\n    key: \"requiredKeys\",\n    value: function requiredKeys() {\n      for (var _len6 = arguments.length, children = new Array(_len6), _key8 = 0; _key8 < _len6; _key8++) {\n        children[_key8] = arguments[_key8];\n      }\n\n      children = Hoek.flatten(children);\n      return this.applyFunctionToChildren(children, 'required');\n    }\n  }, {\n    key: \"optionalKeys\",\n    value: function optionalKeys() {\n      for (var _len7 = arguments.length, children = new Array(_len7), _key9 = 0; _key9 < _len7; _key9++) {\n        children[_key9] = arguments[_key9];\n      }\n\n      children = Hoek.flatten(children);\n      return this.applyFunctionToChildren(children, 'optional');\n    }\n  }, {\n    key: \"forbiddenKeys\",\n    value: function forbiddenKeys() {\n      for (var _len8 = arguments.length, children = new Array(_len8), _key10 = 0; _key10 < _len8; _key10++) {\n        children[_key10] = arguments[_key10];\n      }\n\n      children = Hoek.flatten(children);\n      return this.applyFunctionToChildren(children, 'forbidden');\n    }\n  }, {\n    key: \"rename\",\n    value: function rename(from, to, options) {\n      Hoek.assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');\n      Hoek.assert(typeof to === 'string', 'Rename missing the to argument');\n      Hoek.assert(to !== from, 'Cannot rename key to same name:', from);\n\n      for (var i = 0; i < this._inner.renames.length; ++i) {\n        Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');\n      }\n\n      var obj = this.clone();\n\n      obj._inner.renames.push({\n        from: from,\n        to: to,\n        options: Hoek.applyToDefaults(internals.renameDefaults, options || {}),\n        isRegExp: from instanceof RegExp\n      });\n\n      return obj;\n    }\n  }, {\n    key: \"applyFunctionToChildren\",\n    value: function applyFunctionToChildren(children, fn, args, root) {\n      children = [].concat(children);\n      Hoek.assert(children.length > 0, 'expected at least one children');\n      var groupedChildren = internals.groupChildren(children);\n      var obj;\n\n      if ('' in groupedChildren) {\n        obj = this[fn].apply(this, args);\n        delete groupedChildren[''];\n      } else {\n        obj = this.clone();\n      }\n\n      if (obj._inner.children) {\n        root = root ? root + '.' : '';\n\n        for (var i = 0; i < obj._inner.children.length; ++i) {\n          var child = obj._inner.children[i];\n          var group = groupedChildren[child.key];\n\n          if (group) {\n            obj._inner.children[i] = {\n              key: child.key,\n              _refs: child._refs,\n              schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\n            };\n            delete groupedChildren[child.key];\n          }\n        }\n      }\n\n      var remaining = Object.keys(groupedChildren);\n      Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\n      return obj;\n    }\n  }, {\n    key: \"_dependency\",\n    value: function _dependency(type, key, peers) {\n      peers = [].concat(peers);\n\n      for (var i = 0; i < peers.length; ++i) {\n        Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\n      }\n\n      var obj = this.clone();\n\n      obj._inner.dependencies.push({\n        type: type,\n        key: key,\n        peers: peers\n      });\n\n      return obj;\n    }\n  }, {\n    key: \"describe\",\n    value: function describe(shallow) {\n      var description = _get(_getPrototypeOf(_class.prototype), \"describe\", this).call(this);\n\n      if (description.rules) {\n        for (var i = 0; i < description.rules.length; ++i) {\n          var rule = description.rules[i]; // Coverage off for future-proof descriptions, only object().assert() is use right now\n\n          if (\n          /* $lab:coverage:off$ */\n          rule.arg && typeof rule.arg === 'object' && rule.arg.schema && rule.arg.ref\n          /* $lab:coverage:on$ */\n          ) {\n              rule.arg = {\n                schema: rule.arg.schema.describe(),\n                ref: rule.arg.ref.toString()\n              };\n            }\n        }\n      }\n\n      if (this._inner.children && !shallow) {\n        description.children = {};\n\n        for (var _i7 = 0; _i7 < this._inner.children.length; ++_i7) {\n          var child = this._inner.children[_i7];\n          description.children[child.key] = child.schema.describe();\n        }\n      }\n\n      if (this._inner.dependencies.length) {\n        description.dependencies = Hoek.clone(this._inner.dependencies);\n      }\n\n      if (this._inner.patterns.length) {\n        description.patterns = [];\n\n        for (var _i8 = 0; _i8 < this._inner.patterns.length; ++_i8) {\n          var pattern = this._inner.patterns[_i8];\n\n          if (pattern.regex) {\n            description.patterns.push({\n              regex: pattern.regex.toString(),\n              rule: pattern.rule.describe()\n            });\n          } else {\n            description.patterns.push({\n              schema: pattern.schema.describe(),\n              rule: pattern.rule.describe()\n            });\n          }\n        }\n      }\n\n      if (this._inner.renames.length > 0) {\n        description.renames = Hoek.clone(this._inner.renames);\n      }\n\n      return description;\n    }\n  }, {\n    key: \"assert\",\n    value: function assert(ref, schema, message) {\n      ref = Cast.ref(ref);\n      Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\n      message = message || 'pass the assertion test';\n\n      try {\n        schema = Cast.schema(this._currentJoi, schema);\n      } catch (castErr) {\n        if (castErr.hasOwnProperty('path')) {\n          castErr.message = castErr.message + '(' + castErr.path + ')';\n        }\n\n        throw castErr;\n      }\n\n      var key = ref.path[ref.path.length - 1];\n      var path = ref.path.join('.');\n      return this._test('assert', {\n        schema: schema,\n        ref: ref\n      }, function (value, state, options) {\n        var result = schema._validate(ref(value), null, options, value);\n\n        if (!result.errors) {\n          return value;\n        }\n\n        var localState = Hoek.merge({}, state);\n        localState.key = key;\n        localState.path = ref.path;\n        return this.createError('object.assert', {\n          ref: path,\n          message: message\n        }, localState, options);\n      });\n    }\n  }, {\n    key: \"type\",\n    value: function type(constructor) {\n      var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : constructor.name;\n      Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\n      var typeData = {\n        name: name,\n        ctor: constructor\n      };\n      return this._test('type', typeData, function (value, state, options) {\n        if (value instanceof constructor) {\n          return value;\n        }\n\n        return this.createError('object.type', {\n          type: typeData.name\n        }, state, options);\n      });\n    }\n  }]);\n\n  return _class;\n}(Any);\n\ninternals.safeParse = function (value) {\n  try {\n    return JSON.parse(value);\n  } catch (parseErr) {}\n\n  return value;\n};\n\ninternals.renameDefaults = {\n  alias: false,\n  // Keep old value in place\n  multiple: false,\n  // Allow renaming multiple keys into the same target\n  override: false // Overrides an existing key\n\n};\n\ninternals.groupChildren = function (children) {\n  children.sort();\n  var grouped = {};\n\n  for (var i = 0; i < children.length; ++i) {\n    var child = children[i];\n    Hoek.assert(typeof child === 'string', 'children must be strings');\n    var group = child.split('.')[0];\n    var childGroup = grouped[group] = grouped[group] || [];\n    childGroup.push(child.substring(group.length + 1));\n  }\n\n  return grouped;\n};\n\ninternals.keysToLabels = function (schema, keys) {\n  var children = schema._inner.children;\n\n  if (!children) {\n    return keys;\n  }\n\n  var findLabel = function findLabel(key) {\n    var matchingChild = children.find(function (child) {\n      return child.key === key;\n    });\n    return matchingChild ? matchingChild.schema._getLabel(key) : key;\n  };\n\n  if (Array.isArray(keys)) {\n    return keys.map(findLabel);\n  }\n\n  return findLabel(keys);\n};\n\ninternals.with = function (value, peers, parent, state, options) {\n  if (value === undefined) {\n    return value;\n  }\n\n  for (var i = 0; i < peers.length; ++i) {\n    var peer = peers[i];\n\n    if (!Object.prototype.hasOwnProperty.call(parent, peer) || parent[peer] === undefined) {\n      return this.createError('object.with', {\n        main: state.key,\n        mainWithLabel: internals.keysToLabels(this, state.key),\n        peer: peer,\n        peerWithLabel: internals.keysToLabels(this, peer)\n      }, state, options);\n    }\n  }\n\n  return value;\n};\n\ninternals.without = function (value, peers, parent, state, options) {\n  if (value === undefined) {\n    return value;\n  }\n\n  for (var i = 0; i < peers.length; ++i) {\n    var peer = peers[i];\n\n    if (Object.prototype.hasOwnProperty.call(parent, peer) && parent[peer] !== undefined) {\n      return this.createError('object.without', {\n        main: state.key,\n        mainWithLabel: internals.keysToLabels(this, state.key),\n        peer: peer,\n        peerWithLabel: internals.keysToLabels(this, peer)\n      }, state, options);\n    }\n  }\n\n  return value;\n};\n\ninternals.xor = function (value, peers, parent, state, options) {\n  var present = [];\n\n  for (var i = 0; i < peers.length; ++i) {\n    var peer = peers[i];\n\n    if (Object.prototype.hasOwnProperty.call(parent, peer) && parent[peer] !== undefined) {\n      present.push(peer);\n    }\n  }\n\n  if (present.length === 1) {\n    return value;\n  }\n\n  var context = {\n    peers: peers,\n    peersWithLabels: internals.keysToLabels(this, peers)\n  };\n\n  if (present.length === 0) {\n    return this.createError('object.missing', context, state, options);\n  }\n\n  return this.createError('object.xor', context, state, options);\n};\n\ninternals.or = function (value, peers, parent, state, options) {\n  for (var i = 0; i < peers.length; ++i) {\n    var peer = peers[i];\n\n    if (Object.prototype.hasOwnProperty.call(parent, peer) && parent[peer] !== undefined) {\n      return value;\n    }\n  }\n\n  return this.createError('object.missing', {\n    peers: peers,\n    peersWithLabels: internals.keysToLabels(this, peers)\n  }, state, options);\n};\n\ninternals.and = function (value, peers, parent, state, options) {\n  var missing = [];\n  var present = [];\n  var count = peers.length;\n\n  for (var i = 0; i < count; ++i) {\n    var peer = peers[i];\n\n    if (!Object.prototype.hasOwnProperty.call(parent, peer) || parent[peer] === undefined) {\n      missing.push(peer);\n    } else {\n      present.push(peer);\n    }\n  }\n\n  var aon = missing.length === count || present.length === count;\n\n  if (!aon) {\n    return this.createError('object.and', {\n      present: present,\n      presentWithLabels: internals.keysToLabels(this, present),\n      missing: missing,\n      missingWithLabels: internals.keysToLabels(this, missing)\n    }, state, options);\n  }\n};\n\ninternals.nand = function (value, peers, parent, state, options) {\n  var present = [];\n\n  for (var i = 0; i < peers.length; ++i) {\n    var peer = peers[i];\n\n    if (Object.prototype.hasOwnProperty.call(parent, peer) && parent[peer] !== undefined) {\n      present.push(peer);\n    }\n  }\n\n  var values = Hoek.clone(peers);\n  var main = values.splice(0, 1)[0];\n  var allPresent = present.length === peers.length;\n  return allPresent ? this.createError('object.nand', {\n    main: main,\n    mainWithLabel: internals.keysToLabels(this, main),\n    peers: values,\n    peersWithLabels: internals.keysToLabels(this, values)\n  }, state, options) : null;\n};\n\nmodule.exports = new internals.Object();","map":{"version":3,"sources":["/home/cloudmynds/Desktop/admin/node_modules/joi/lib/types/object/index.js"],"names":["Hoek","require","Topo","Any","Errors","Cast","internals","Object","_type","_inner","children","renames","dependencies","patterns","length","keys","value","state","options","target","errors","finish","convert","safeParse","type","_flags","func","Array","isArray","push","createError","create","getPrototypeOf","args","apply","prototype","clone","valueKeys","i","renamed","rename","isRegExp","targetKeys","matchedTargetKeys","j","from","test","allUndefined","every","key","undefined","ignoreUndefined","multiple","to","abortEarly","hasOwnProperty","call","override","alias","unprocessed","Set","stripProps","child","item","delete","localState","path","concat","parent","reference","result","schema","_validate","_getLabel","reason","strip","finalValue","size","pattern","regex","validate","error","rule","stripUnknown","allowUnknown","skipFunctions","objects","unprocessedKey","dep","err","peers","Err","assert","obj","topo","includes","add","after","_refs","group","cast","_currentJoi","castErr","nodes","allow","limit","Number","isSafeInteger","_test","RegExp","source","ignoreCase","message","arguments","_dependency","flatten","applyFunctionToChildren","applyToDefaults","renameDefaults","fn","root","groupedChildren","groupChildren","remaining","join","shallow","description","rules","arg","ref","describe","toString","isContext","depth","merge","constructor","name","typeData","ctor","JSON","parse","parseErr","sort","grouped","split","childGroup","substring","keysToLabels","findLabel","matchingChild","find","map","with","peer","main","mainWithLabel","peerWithLabel","without","xor","present","context","peersWithLabels","or","and","missing","count","aon","presentWithLabels","missingWithLabels","nand","values","splice","allPresent","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\n// Load modules\n\nconst Hoek = require('hoek');\nconst Topo = require('topo');\nconst Any = require('../any');\nconst Errors = require('../../errors');\nconst Cast = require('../../cast');\n\n\n// Declare internals\n\nconst internals = {};\n\n\ninternals.Object = class extends Any {\n\n    constructor() {\n\n        super();\n        this._type = 'object';\n        this._inner.children = null;\n        this._inner.renames = [];\n        this._inner.dependencies = [];\n        this._inner.patterns = [];\n    }\n\n    _init(...args) {\n\n        return args.length ? this.keys(...args) : this;\n    }\n\n    _base(value, state, options) {\n\n        let target = value;\n        const errors = [];\n        const finish = () => {\n\n            return {\n                value: target,\n                errors: errors.length ? errors : null\n            };\n        };\n\n        if (typeof value === 'string' &&\n            options.convert) {\n\n            value = internals.safeParse(value);\n        }\n\n        const type = this._flags.func ? 'function' : 'object';\n        if (!value ||\n            typeof value !== type ||\n            Array.isArray(value)) {\n\n            errors.push(this.createError(type + '.base', null, state, options));\n            return finish();\n        }\n\n        // Skip if there are no other rules to test\n\n        if (!this._inner.renames.length &&\n            !this._inner.dependencies.length &&\n            !this._inner.children &&                    // null allows any keys\n            !this._inner.patterns.length) {\n\n            target = value;\n            return finish();\n        }\n\n        // Ensure target is a local copy (parsed) or shallow copy\n\n        if (target === value) {\n            if (type === 'object') {\n                target = Object.create(Object.getPrototypeOf(value));\n            }\n            else {\n                target = function (...args) {\n\n                    return value.apply(this, args);\n                };\n\n                target.prototype = Hoek.clone(value.prototype);\n            }\n\n            const valueKeys = Object.keys(value);\n            for (let i = 0; i < valueKeys.length; ++i) {\n                target[valueKeys[i]] = value[valueKeys[i]];\n            }\n        }\n        else {\n            target = value;\n        }\n\n        // Rename keys\n\n        const renamed = {};\n        for (let i = 0; i < this._inner.renames.length; ++i) {\n            const rename = this._inner.renames[i];\n\n            if (rename.isRegExp) {\n                const targetKeys = Object.keys(target);\n                const matchedTargetKeys = [];\n\n                for (let j = 0; j < targetKeys.length; ++j) {\n                    if (rename.from.test(targetKeys[j])) {\n                        matchedTargetKeys.push(targetKeys[j]);\n                    }\n                }\n\n                const allUndefined = matchedTargetKeys.every((key) => target[key] === undefined);\n                if (rename.options.ignoreUndefined && allUndefined) {\n                    continue;\n                }\n\n                if (!rename.options.multiple &&\n                    renamed[rename.to]) {\n\n                    errors.push(this.createError('object.rename.regex.multiple', { from: matchedTargetKeys, to: rename.to }, state, options));\n                    if (options.abortEarly) {\n                        return finish();\n                    }\n                }\n\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\n                    !rename.options.override &&\n                    !renamed[rename.to]) {\n\n                    errors.push(this.createError('object.rename.regex.override', { from: matchedTargetKeys, to: rename.to }, state, options));\n                    if (options.abortEarly) {\n                        return finish();\n                    }\n                }\n\n                if (allUndefined) {\n                    delete target[rename.to];\n                }\n                else {\n                    target[rename.to] = target[matchedTargetKeys[matchedTargetKeys.length - 1]];\n                }\n\n                renamed[rename.to] = true;\n\n                if (!rename.options.alias) {\n                    for (let j = 0; j < matchedTargetKeys.length; ++j) {\n                        delete target[matchedTargetKeys[j]];\n                    }\n                }\n            }\n            else {\n                if (rename.options.ignoreUndefined && target[rename.from] === undefined) {\n                    continue;\n                }\n\n                if (!rename.options.multiple &&\n                    renamed[rename.to]) {\n\n                    errors.push(this.createError('object.rename.multiple', { from: rename.from, to: rename.to }, state, options));\n                    if (options.abortEarly) {\n                        return finish();\n                    }\n                }\n\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\n                    !rename.options.override &&\n                    !renamed[rename.to]) {\n\n                    errors.push(this.createError('object.rename.override', { from: rename.from, to: rename.to }, state, options));\n                    if (options.abortEarly) {\n                        return finish();\n                    }\n                }\n\n                if (target[rename.from] === undefined) {\n                    delete target[rename.to];\n                }\n                else {\n                    target[rename.to] = target[rename.from];\n                }\n\n                renamed[rename.to] = true;\n\n                if (!rename.options.alias) {\n                    delete target[rename.from];\n                }\n            }\n        }\n\n        // Validate schema\n\n        if (!this._inner.children &&            // null allows any keys\n            !this._inner.patterns.length &&\n            !this._inner.dependencies.length) {\n\n            return finish();\n        }\n\n        const unprocessed = new Set(Object.keys(target));\n\n        if (this._inner.children) {\n            const stripProps = [];\n\n            for (let i = 0; i < this._inner.children.length; ++i) {\n                const child = this._inner.children[i];\n                const key = child.key;\n                const item = target[key];\n\n                unprocessed.delete(key);\n\n                const localState = { key, path: state.path.concat(key), parent: target, reference: state.reference };\n                const result = child.schema._validate(item, localState, options);\n                if (result.errors) {\n                    errors.push(this.createError('object.child', { key, child: child.schema._getLabel(key), reason: result.errors }, localState, options));\n\n                    if (options.abortEarly) {\n                        return finish();\n                    }\n                }\n                else {\n                    if (child.schema._flags.strip || (result.value === undefined && result.value !== item)) {\n                        stripProps.push(key);\n                        target[key] = result.finalValue;\n                    }\n                    else if (result.value !== undefined) {\n                        target[key] = result.value;\n                    }\n                }\n            }\n\n            for (let i = 0; i < stripProps.length; ++i) {\n                delete target[stripProps[i]];\n            }\n        }\n\n        // Unknown keys\n\n        if (unprocessed.size && this._inner.patterns.length) {\n\n            for (const key of unprocessed) {\n                const localState = {\n                    key,\n                    path: state.path.concat(key),\n                    parent: target,\n                    reference: state.reference\n                };\n                const item = target[key];\n\n                for (let i = 0; i < this._inner.patterns.length; ++i) {\n                    const pattern = this._inner.patterns[i];\n\n                    if (pattern.regex ?\n                        pattern.regex.test(key) :\n                        !pattern.schema.validate(key).error) {\n\n                        unprocessed.delete(key);\n\n                        const result = pattern.rule._validate(item, localState, options);\n                        if (result.errors) {\n                            errors.push(this.createError('object.child', {\n                                key,\n                                child: pattern.rule._getLabel(key),\n                                reason: result.errors\n                            }, localState, options));\n\n                            if (options.abortEarly) {\n                                return finish();\n                            }\n                        }\n\n                        target[key] = result.value;\n                    }\n                }\n            }\n        }\n\n        if (unprocessed.size && (this._inner.children || this._inner.patterns.length)) {\n            if ((options.stripUnknown && this._flags.allowUnknown !== true) ||\n                options.skipFunctions) {\n\n                const stripUnknown = options.stripUnknown\n                    ? (options.stripUnknown === true ? true : !!options.stripUnknown.objects)\n                    : false;\n\n\n                for (const key of unprocessed) {\n                    if (stripUnknown) {\n                        delete target[key];\n                        unprocessed.delete(key);\n                    }\n                    else if (typeof target[key] === 'function') {\n                        unprocessed.delete(key);\n                    }\n                }\n            }\n\n            if ((this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown)) {\n\n                for (const unprocessedKey of unprocessed) {\n                    errors.push(this.createError('object.allowUnknown', { child: unprocessedKey }, {\n                        key: unprocessedKey,\n                        path: state.path.concat(unprocessedKey)\n                    }, options, {}));\n                }\n            }\n        }\n\n        // Validate dependencies\n\n        for (let i = 0; i < this._inner.dependencies.length; ++i) {\n            const dep = this._inner.dependencies[i];\n            const err = internals[dep.type].call(this, dep.key !== null && target[dep.key], dep.peers, target, { key: dep.key, path: dep.key === null ? state.path : state.path.concat(dep.key) }, options);\n            if (err instanceof Errors.Err) {\n                errors.push(err);\n                if (options.abortEarly) {\n                    return finish();\n                }\n            }\n        }\n\n        return finish();\n    }\n\n    keys(schema) {\n\n        Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');\n        Hoek.assert(!schema || !(schema instanceof Any), 'Object schema cannot be a joi schema');\n\n        const obj = this.clone();\n\n        if (!schema) {\n            obj._inner.children = null;\n            return obj;\n        }\n\n        const children = Object.keys(schema);\n\n        if (!children.length) {\n            obj._inner.children = [];\n            return obj;\n        }\n\n        const topo = new Topo();\n        if (obj._inner.children) {\n            for (let i = 0; i < obj._inner.children.length; ++i) {\n                const child = obj._inner.children[i];\n\n                // Only add the key if we are not going to replace it later\n                if (!children.includes(child.key)) {\n                    topo.add(child, { after: child._refs, group: child.key });\n                }\n            }\n        }\n\n        for (let i = 0; i < children.length; ++i) {\n            const key = children[i];\n            const child = schema[key];\n            try {\n                const cast = Cast.schema(this._currentJoi, child);\n                topo.add({ key, schema: cast }, { after: cast._refs, group: key });\n            }\n            catch (castErr) {\n                if (castErr.hasOwnProperty('path')) {\n                    castErr.path = key + '.' + castErr.path;\n                }\n                else {\n                    castErr.path = key;\n                }\n                throw castErr;\n            }\n        }\n\n        obj._inner.children = topo.nodes;\n\n        return obj;\n    }\n\n    append(schema) {\n        // Skip any changes\n        if (schema === null || schema === undefined || Object.keys(schema).length === 0) {\n            return this;\n        }\n\n        return this.keys(schema);\n    }\n\n    unknown(allow) {\n\n        const value = allow !== false;\n\n        if (this._flags.allowUnknown === value) {\n            return this;\n        }\n\n        const obj = this.clone();\n        obj._flags.allowUnknown = value;\n        return obj;\n    }\n\n    length(limit) {\n\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\n\n        return this._test('length', limit, function (value, state, options) {\n\n            if (Object.keys(value).length === limit) {\n                return value;\n            }\n\n            return this.createError('object.length', { limit }, state, options);\n        });\n    }\n\n    min(limit) {\n\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\n\n        return this._test('min', limit, function (value, state, options) {\n\n            if (Object.keys(value).length >= limit) {\n                return value;\n            }\n\n            return this.createError('object.min', { limit }, state, options);\n        });\n    }\n\n    max(limit) {\n\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\n\n        return this._test('max', limit, function (value, state, options) {\n\n            if (Object.keys(value).length <= limit) {\n                return value;\n            }\n\n            return this.createError('object.max', { limit }, state, options);\n        });\n    }\n\n    pattern(pattern, schema) {\n\n        const isRegExp = pattern instanceof RegExp;\n        Hoek.assert(isRegExp || pattern instanceof Any, 'pattern must be a regex or schema');\n        Hoek.assert(schema !== undefined, 'Invalid rule');\n\n        if (isRegExp) {\n            pattern = new RegExp(pattern.source, pattern.ignoreCase ? 'i' : undefined);         // Future version should break this and forbid unsupported regex flags\n        }\n\n        try {\n            schema = Cast.schema(this._currentJoi, schema);\n        }\n        catch (castErr) {\n            if (castErr.hasOwnProperty('path')) {\n                castErr.message = castErr.message + '(' + castErr.path + ')';\n            }\n\n            throw castErr;\n        }\n\n        const obj = this.clone();\n        if (isRegExp) {\n            obj._inner.patterns.push({ regex: pattern, rule: schema });\n        }\n        else {\n            obj._inner.patterns.push({ schema: pattern, rule: schema });\n        }\n        return obj;\n    }\n\n    schema() {\n\n        return this._test('schema', null, function (value, state, options) {\n\n            if (value instanceof Any) {\n                return value;\n            }\n\n            return this.createError('object.schema', null, state, options);\n        });\n    }\n\n    with(key, peers) {\n\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\n\n        return this._dependency('with', key, peers);\n    }\n\n    without(key, peers) {\n\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\n\n        return this._dependency('without', key, peers);\n    }\n\n    xor(...peers) {\n\n        peers = Hoek.flatten(peers);\n        return this._dependency('xor', null, peers);\n    }\n\n    or(...peers) {\n\n        peers = Hoek.flatten(peers);\n        return this._dependency('or', null, peers);\n    }\n\n    and(...peers) {\n\n        peers = Hoek.flatten(peers);\n        return this._dependency('and', null, peers);\n    }\n\n    nand(...peers) {\n\n        peers = Hoek.flatten(peers);\n        return this._dependency('nand', null, peers);\n    }\n\n    requiredKeys(...children) {\n\n        children = Hoek.flatten(children);\n        return this.applyFunctionToChildren(children, 'required');\n    }\n\n    optionalKeys(...children) {\n\n        children = Hoek.flatten(children);\n        return this.applyFunctionToChildren(children, 'optional');\n    }\n\n    forbiddenKeys(...children) {\n\n        children = Hoek.flatten(children);\n        return this.applyFunctionToChildren(children, 'forbidden');\n    }\n\n    rename(from, to, options) {\n\n        Hoek.assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');\n        Hoek.assert(typeof to === 'string', 'Rename missing the to argument');\n        Hoek.assert(to !== from, 'Cannot rename key to same name:', from);\n\n        for (let i = 0; i < this._inner.renames.length; ++i) {\n            Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');\n        }\n\n        const obj = this.clone();\n\n        obj._inner.renames.push({\n            from,\n            to,\n            options: Hoek.applyToDefaults(internals.renameDefaults, options || {}),\n            isRegExp: from instanceof RegExp\n        });\n\n        return obj;\n    }\n\n    applyFunctionToChildren(children, fn, args, root) {\n\n        children = [].concat(children);\n        Hoek.assert(children.length > 0, 'expected at least one children');\n\n        const groupedChildren = internals.groupChildren(children);\n        let obj;\n\n        if ('' in groupedChildren) {\n            obj = this[fn].apply(this, args);\n            delete groupedChildren[''];\n        }\n        else {\n            obj = this.clone();\n        }\n\n        if (obj._inner.children) {\n            root = root ? (root + '.') : '';\n\n            for (let i = 0; i < obj._inner.children.length; ++i) {\n                const child = obj._inner.children[i];\n                const group = groupedChildren[child.key];\n\n                if (group) {\n                    obj._inner.children[i] = {\n                        key: child.key,\n                        _refs: child._refs,\n                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\n                    };\n\n                    delete groupedChildren[child.key];\n                }\n            }\n        }\n\n        const remaining = Object.keys(groupedChildren);\n        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\n\n        return obj;\n    }\n\n    _dependency(type, key, peers) {\n\n        peers = [].concat(peers);\n        for (let i = 0; i < peers.length; ++i) {\n            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\n        }\n\n        const obj = this.clone();\n        obj._inner.dependencies.push({ type, key, peers });\n        return obj;\n    }\n\n    describe(shallow) {\n\n        const description = super.describe();\n\n        if (description.rules) {\n            for (let i = 0; i < description.rules.length; ++i) {\n                const rule = description.rules[i];\n                // Coverage off for future-proof descriptions, only object().assert() is use right now\n                if (/* $lab:coverage:off$ */rule.arg &&\n                    typeof rule.arg === 'object' &&\n                    rule.arg.schema &&\n                    rule.arg.ref /* $lab:coverage:on$ */) {\n                    rule.arg = {\n                        schema: rule.arg.schema.describe(),\n                        ref: rule.arg.ref.toString()\n                    };\n                }\n            }\n        }\n\n        if (this._inner.children &&\n            !shallow) {\n\n            description.children = {};\n            for (let i = 0; i < this._inner.children.length; ++i) {\n                const child = this._inner.children[i];\n                description.children[child.key] = child.schema.describe();\n            }\n        }\n\n        if (this._inner.dependencies.length) {\n            description.dependencies = Hoek.clone(this._inner.dependencies);\n        }\n\n        if (this._inner.patterns.length) {\n            description.patterns = [];\n\n            for (let i = 0; i < this._inner.patterns.length; ++i) {\n                const pattern = this._inner.patterns[i];\n                if (pattern.regex) {\n                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\n                }\n                else {\n                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });\n                }\n            }\n        }\n\n        if (this._inner.renames.length > 0) {\n            description.renames = Hoek.clone(this._inner.renames);\n        }\n\n        return description;\n    }\n\n    assert(ref, schema, message) {\n\n        ref = Cast.ref(ref);\n        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\n        message = message || 'pass the assertion test';\n\n        try {\n            schema = Cast.schema(this._currentJoi, schema);\n        }\n        catch (castErr) {\n            if (castErr.hasOwnProperty('path')) {\n                castErr.message = castErr.message + '(' + castErr.path + ')';\n            }\n\n            throw castErr;\n        }\n\n        const key = ref.path[ref.path.length - 1];\n        const path = ref.path.join('.');\n\n        return this._test('assert', { schema, ref }, function (value, state, options) {\n\n            const result = schema._validate(ref(value), null, options, value);\n            if (!result.errors) {\n                return value;\n            }\n\n            const localState = Hoek.merge({}, state);\n            localState.key = key;\n            localState.path = ref.path;\n            return this.createError('object.assert', { ref: path, message }, localState, options);\n        });\n    }\n\n    type(constructor, name = constructor.name) {\n\n        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\n        const typeData = {\n            name,\n            ctor: constructor\n        };\n\n        return this._test('type', typeData, function (value, state, options) {\n\n            if (value instanceof constructor) {\n                return value;\n            }\n\n            return this.createError('object.type', { type: typeData.name }, state, options);\n        });\n    }\n};\n\ninternals.safeParse = function (value) {\n\n    try {\n        return JSON.parse(value);\n    }\n    catch (parseErr) {}\n\n    return value;\n};\n\n\ninternals.renameDefaults = {\n    alias: false,                   // Keep old value in place\n    multiple: false,                // Allow renaming multiple keys into the same target\n    override: false                 // Overrides an existing key\n};\n\n\ninternals.groupChildren = function (children) {\n\n    children.sort();\n\n    const grouped = {};\n\n    for (let i = 0; i < children.length; ++i) {\n        const child = children[i];\n        Hoek.assert(typeof child === 'string', 'children must be strings');\n        const group = child.split('.')[0];\n        const childGroup = grouped[group] = (grouped[group] || []);\n        childGroup.push(child.substring(group.length + 1));\n    }\n\n    return grouped;\n};\n\n\ninternals.keysToLabels = function (schema, keys) {\n\n    const children = schema._inner.children;\n\n    if (!children) {\n        return keys;\n    }\n\n    const findLabel = function (key) {\n\n        const matchingChild = children.find((child) => child.key === key);\n        return matchingChild ? matchingChild.schema._getLabel(key) : key;\n    };\n\n    if (Array.isArray(keys)) {\n        return keys.map(findLabel);\n    }\n\n    return findLabel(keys);\n};\n\n\ninternals.with = function (value, peers, parent, state, options) {\n\n    if (value === undefined) {\n        return value;\n    }\n\n    for (let i = 0; i < peers.length; ++i) {\n        const peer = peers[i];\n        if (!Object.prototype.hasOwnProperty.call(parent, peer) ||\n            parent[peer] === undefined) {\n\n            return this.createError('object.with', {\n                main: state.key,\n                mainWithLabel: internals.keysToLabels(this, state.key),\n                peer,\n                peerWithLabel: internals.keysToLabels(this, peer)\n            }, state, options);\n        }\n    }\n\n    return value;\n};\n\n\ninternals.without = function (value, peers, parent, state, options) {\n\n    if (value === undefined) {\n        return value;\n    }\n\n    for (let i = 0; i < peers.length; ++i) {\n        const peer = peers[i];\n        if (Object.prototype.hasOwnProperty.call(parent, peer) &&\n            parent[peer] !== undefined) {\n\n            return this.createError('object.without', {\n                main: state.key,\n                mainWithLabel: internals.keysToLabels(this, state.key),\n                peer,\n                peerWithLabel: internals.keysToLabels(this, peer)\n            }, state, options);\n        }\n    }\n\n    return value;\n};\n\n\ninternals.xor = function (value, peers, parent, state, options) {\n\n    const present = [];\n    for (let i = 0; i < peers.length; ++i) {\n        const peer = peers[i];\n        if (Object.prototype.hasOwnProperty.call(parent, peer) &&\n            parent[peer] !== undefined) {\n\n            present.push(peer);\n        }\n    }\n\n    if (present.length === 1) {\n        return value;\n    }\n\n    const context = { peers, peersWithLabels: internals.keysToLabels(this, peers) };\n\n    if (present.length === 0) {\n        return this.createError('object.missing', context, state, options);\n    }\n\n    return this.createError('object.xor', context, state, options);\n};\n\n\ninternals.or = function (value, peers, parent, state, options) {\n\n    for (let i = 0; i < peers.length; ++i) {\n        const peer = peers[i];\n        if (Object.prototype.hasOwnProperty.call(parent, peer) &&\n            parent[peer] !== undefined) {\n            return value;\n        }\n    }\n\n    return this.createError('object.missing', {\n        peers,\n        peersWithLabels: internals.keysToLabels(this, peers)\n    }, state, options);\n};\n\n\ninternals.and = function (value, peers, parent, state, options) {\n\n    const missing = [];\n    const present = [];\n    const count = peers.length;\n    for (let i = 0; i < count; ++i) {\n        const peer = peers[i];\n        if (!Object.prototype.hasOwnProperty.call(parent, peer) ||\n            parent[peer] === undefined) {\n\n            missing.push(peer);\n        }\n        else {\n            present.push(peer);\n        }\n    }\n\n    const aon = (missing.length === count || present.length === count);\n\n    if (!aon) {\n\n        return this.createError('object.and', {\n            present,\n            presentWithLabels: internals.keysToLabels(this, present),\n            missing,\n            missingWithLabels: internals.keysToLabels(this, missing)\n        }, state, options);\n    }\n};\n\n\ninternals.nand = function (value, peers, parent, state, options) {\n\n    const present = [];\n    for (let i = 0; i < peers.length; ++i) {\n        const peer = peers[i];\n        if (Object.prototype.hasOwnProperty.call(parent, peer) &&\n            parent[peer] !== undefined) {\n\n            present.push(peer);\n        }\n    }\n\n    const values = Hoek.clone(peers);\n    const main = values.splice(0, 1)[0];\n    const allPresent = (present.length === peers.length);\n    return allPresent ? this.createError('object.nand', {\n        main,\n        mainWithLabel: internals.keysToLabels(this, main),\n        peers: values,\n        peersWithLabels: internals.keysToLabels(this, values)\n    }, state, options) : null;\n};\n\n\nmodule.exports = new internals.Object();\n"]},"metadata":{},"sourceType":"script"}