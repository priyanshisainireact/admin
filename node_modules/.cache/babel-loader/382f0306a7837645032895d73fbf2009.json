{"ast":null,"code":"'use strict'; // Load modules\n\nvar _classCallCheck = require(\"/home/cloudmynds/Desktop/admin/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/cloudmynds/Desktop/admin/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/home/cloudmynds/Desktop/admin/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/home/cloudmynds/Desktop/admin/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar Net = require('net');\n\nvar Hoek = require('hoek');\n\nvar Isemail; // Loaded on demand\n\nvar Any = require('../any');\n\nvar Ref = require('../../ref');\n\nvar JoiDate = require('../date');\n\nvar Uri = require('./uri');\n\nvar Ip = require('./ip'); // Declare internals\n\n\nvar internals = {\n  uriRegex: Uri.createUriRegex(),\n  ipRegex: Ip.createIpRegex(['ipv4', 'ipv6', 'ipvfuture'], 'optional'),\n  guidBrackets: {\n    '{': '}',\n    '[': ']',\n    '(': ')',\n    '': ''\n  },\n  guidVersions: {\n    uuidv1: '1',\n    uuidv2: '2',\n    uuidv3: '3',\n    uuidv4: '4',\n    uuidv5: '5'\n  },\n  cidrPresences: ['required', 'optional', 'forbidden'],\n  normalizationForms: ['NFC', 'NFD', 'NFKC', 'NFKD']\n};\n\ninternals.String = /*#__PURE__*/function (_Any) {\n  _inherits(_class, _Any);\n\n  var _super = _createSuper(_class);\n\n  function _class() {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    _this = _super.call(this);\n    _this._type = 'string';\n\n    _this._invalids.add('');\n\n    return _this;\n  }\n\n  _createClass(_class, [{\n    key: \"_base\",\n    value: function _base(value, state, options) {\n      if (typeof value === 'string' && options.convert) {\n        if (this._flags.normalize) {\n          value = value.normalize(this._flags.normalize);\n        }\n\n        if (this._flags.case) {\n          value = this._flags.case === 'upper' ? value.toLocaleUpperCase() : value.toLocaleLowerCase();\n        }\n\n        if (this._flags.trim) {\n          value = value.trim();\n        }\n\n        if (this._inner.replacements) {\n          for (var i = 0; i < this._inner.replacements.length; ++i) {\n            var replacement = this._inner.replacements[i];\n            value = value.replace(replacement.pattern, replacement.replacement);\n          }\n        }\n\n        if (this._flags.truncate) {\n          for (var _i = 0; _i < this._tests.length; ++_i) {\n            var test = this._tests[_i];\n\n            if (test.name === 'max') {\n              value = value.slice(0, test.arg);\n              break;\n            }\n          }\n        }\n\n        if (this._flags.byteAligned && value.length % 2 !== 0) {\n          value = \"0\".concat(value);\n        }\n      }\n\n      return {\n        value: value,\n        errors: typeof value === 'string' ? null : this.createError('string.base', {\n          value: value\n        }, state, options)\n      };\n    }\n  }, {\n    key: \"insensitive\",\n    value: function insensitive() {\n      if (this._flags.insensitive) {\n        return this;\n      }\n\n      var obj = this.clone();\n      obj._flags.insensitive = true;\n      return obj;\n    }\n  }, {\n    key: \"creditCard\",\n    value: function creditCard() {\n      return this._test('creditCard', undefined, function (value, state, options) {\n        var i = value.length;\n        var sum = 0;\n        var mul = 1;\n\n        while (i--) {\n          var char = value.charAt(i) * mul;\n          sum = sum + (char - (char > 9) * 9);\n          mul = mul ^ 3;\n        }\n\n        var check = sum % 10 === 0 && sum > 0;\n        return check ? value : this.createError('string.creditCard', {\n          value: value\n        }, state, options);\n      });\n    }\n  }, {\n    key: \"regex\",\n    value: function regex(pattern, patternOptions) {\n      Hoek.assert(pattern instanceof RegExp, 'pattern must be a RegExp');\n      var patternObject = {\n        pattern: new RegExp(pattern.source, pattern.ignoreCase ? 'i' : undefined) // Future version should break this and forbid unsupported regex flags\n\n      };\n\n      if (typeof patternOptions === 'string') {\n        patternObject.name = patternOptions;\n      } else if (typeof patternOptions === 'object') {\n        patternObject.invert = !!patternOptions.invert;\n\n        if (patternOptions.name) {\n          patternObject.name = patternOptions.name;\n        }\n      }\n\n      var errorCode = ['string.regex', patternObject.invert ? '.invert' : '', patternObject.name ? '.name' : '.base'].join('');\n      return this._test('regex', patternObject, function (value, state, options) {\n        var patternMatch = patternObject.pattern.test(value);\n\n        if (patternMatch ^ patternObject.invert) {\n          return value;\n        }\n\n        return this.createError(errorCode, {\n          name: patternObject.name,\n          pattern: patternObject.pattern,\n          value: value\n        }, state, options);\n      });\n    }\n  }, {\n    key: \"alphanum\",\n    value: function alphanum() {\n      return this._test('alphanum', undefined, function (value, state, options) {\n        if (/^[a-zA-Z0-9]+$/.test(value)) {\n          return value;\n        }\n\n        return this.createError('string.alphanum', {\n          value: value\n        }, state, options);\n      });\n    }\n  }, {\n    key: \"token\",\n    value: function token() {\n      return this._test('token', undefined, function (value, state, options) {\n        if (/^\\w+$/.test(value)) {\n          return value;\n        }\n\n        return this.createError('string.token', {\n          value: value\n        }, state, options);\n      });\n    }\n  }, {\n    key: \"email\",\n    value: function email(isEmailOptions) {\n      if (isEmailOptions) {\n        Hoek.assert(typeof isEmailOptions === 'object', 'email options must be an object');\n        Hoek.assert(typeof isEmailOptions.checkDNS === 'undefined', 'checkDNS option is not supported');\n        Hoek.assert(typeof isEmailOptions.tldWhitelist === 'undefined' || typeof isEmailOptions.tldWhitelist === 'object', 'tldWhitelist must be an array or object');\n        Hoek.assert(typeof isEmailOptions.minDomainAtoms === 'undefined' || Number.isSafeInteger(isEmailOptions.minDomainAtoms) && isEmailOptions.minDomainAtoms > 0, 'minDomainAtoms must be a positive integer');\n        Hoek.assert(typeof isEmailOptions.errorLevel === 'undefined' || typeof isEmailOptions.errorLevel === 'boolean' || Number.isSafeInteger(isEmailOptions.errorLevel) && isEmailOptions.errorLevel >= 0, 'errorLevel must be a non-negative integer or boolean');\n      }\n\n      return this._test('email', isEmailOptions, function (value, state, options) {\n        Isemail = Isemail || require('isemail');\n\n        try {\n          var result = Isemail.validate(value, isEmailOptions);\n\n          if (result === true || result === 0) {\n            return value;\n          }\n        } catch (e) {}\n\n        return this.createError('string.email', {\n          value: value\n        }, state, options);\n      });\n    }\n  }, {\n    key: \"ip\",\n    value: function ip() {\n      var ipOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var regex = internals.ipRegex;\n      Hoek.assert(typeof ipOptions === 'object', 'options must be an object');\n\n      if (ipOptions.cidr) {\n        Hoek.assert(typeof ipOptions.cidr === 'string', 'cidr must be a string');\n        ipOptions.cidr = ipOptions.cidr.toLowerCase();\n        Hoek.assert(Hoek.contain(internals.cidrPresences, ipOptions.cidr), 'cidr must be one of ' + internals.cidrPresences.join(', ')); // If we only received a `cidr` setting, create a regex for it. But we don't need to create one if `cidr` is \"optional\" since that is the default\n\n        if (!ipOptions.version && ipOptions.cidr !== 'optional') {\n          regex = Ip.createIpRegex(['ipv4', 'ipv6', 'ipvfuture'], ipOptions.cidr);\n        }\n      } else {\n        // Set our default cidr strategy\n        ipOptions.cidr = 'optional';\n      }\n\n      var versions;\n\n      if (ipOptions.version) {\n        if (!Array.isArray(ipOptions.version)) {\n          ipOptions.version = [ipOptions.version];\n        }\n\n        Hoek.assert(ipOptions.version.length >= 1, 'version must have at least 1 version specified');\n        versions = [];\n\n        for (var i = 0; i < ipOptions.version.length; ++i) {\n          var version = ipOptions.version[i];\n          Hoek.assert(typeof version === 'string', 'version at position ' + i + ' must be a string');\n          version = version.toLowerCase();\n          Hoek.assert(Ip.versions[version], 'version at position ' + i + ' must be one of ' + Object.keys(Ip.versions).join(', '));\n          versions.push(version);\n        } // Make sure we have a set of versions\n\n\n        versions = Hoek.unique(versions);\n        regex = Ip.createIpRegex(versions, ipOptions.cidr);\n      }\n\n      return this._test('ip', ipOptions, function (value, state, options) {\n        if (regex.test(value)) {\n          return value;\n        }\n\n        if (versions) {\n          return this.createError('string.ipVersion', {\n            value: value,\n            cidr: ipOptions.cidr,\n            version: versions\n          }, state, options);\n        }\n\n        return this.createError('string.ip', {\n          value: value,\n          cidr: ipOptions.cidr\n        }, state, options);\n      });\n    }\n  }, {\n    key: \"uri\",\n    value: function uri(uriOptions) {\n      var customScheme = '';\n      var allowRelative = false;\n      var relativeOnly = false;\n      var allowQuerySquareBrackets = false;\n      var regex = internals.uriRegex;\n\n      if (uriOptions) {\n        Hoek.assert(typeof uriOptions === 'object', 'options must be an object');\n        var unknownOptions = Object.keys(uriOptions).filter(function (key) {\n          return !['scheme', 'allowRelative', 'relativeOnly', 'allowQuerySquareBrackets'].includes(key);\n        });\n        Hoek.assert(unknownOptions.length === 0, \"options contain unknown keys: \".concat(unknownOptions));\n\n        if (uriOptions.scheme) {\n          Hoek.assert(uriOptions.scheme instanceof RegExp || typeof uriOptions.scheme === 'string' || Array.isArray(uriOptions.scheme), 'scheme must be a RegExp, String, or Array');\n\n          if (!Array.isArray(uriOptions.scheme)) {\n            uriOptions.scheme = [uriOptions.scheme];\n          }\n\n          Hoek.assert(uriOptions.scheme.length >= 1, 'scheme must have at least 1 scheme specified'); // Flatten the array into a string to be used to match the schemes.\n\n          for (var i = 0; i < uriOptions.scheme.length; ++i) {\n            var scheme = uriOptions.scheme[i];\n            Hoek.assert(scheme instanceof RegExp || typeof scheme === 'string', 'scheme at position ' + i + ' must be a RegExp or String'); // Add OR separators if a value already exists\n\n            customScheme = customScheme + (customScheme ? '|' : ''); // If someone wants to match HTTP or HTTPS for example then we need to support both RegExp and String so we don't escape their pattern unknowingly.\n\n            if (scheme instanceof RegExp) {\n              customScheme = customScheme + scheme.source;\n            } else {\n              Hoek.assert(/[a-zA-Z][a-zA-Z0-9+-\\.]*/.test(scheme), 'scheme at position ' + i + ' must be a valid scheme');\n              customScheme = customScheme + Hoek.escapeRegex(scheme);\n            }\n          }\n        }\n\n        if (uriOptions.allowRelative) {\n          allowRelative = true;\n        }\n\n        if (uriOptions.relativeOnly) {\n          relativeOnly = true;\n        }\n\n        if (uriOptions.allowQuerySquareBrackets) {\n          allowQuerySquareBrackets = true;\n        }\n      }\n\n      if (customScheme || allowRelative || relativeOnly || allowQuerySquareBrackets) {\n        regex = Uri.createUriRegex(customScheme, allowRelative, relativeOnly, allowQuerySquareBrackets);\n      }\n\n      return this._test('uri', uriOptions, function (value, state, options) {\n        if (regex.test(value)) {\n          return value;\n        }\n\n        if (relativeOnly) {\n          return this.createError('string.uriRelativeOnly', {\n            value: value\n          }, state, options);\n        }\n\n        if (customScheme) {\n          return this.createError('string.uriCustomScheme', {\n            scheme: customScheme,\n            value: value\n          }, state, options);\n        }\n\n        return this.createError('string.uri', {\n          value: value\n        }, state, options);\n      });\n    }\n  }, {\n    key: \"isoDate\",\n    value: function isoDate() {\n      return this._test('isoDate', undefined, function (value, state, options) {\n        if (JoiDate._isIsoDate(value)) {\n          if (!options.convert) {\n            return value;\n          }\n\n          var d = new Date(value);\n\n          if (!isNaN(d.getTime())) {\n            return d.toISOString();\n          }\n        }\n\n        return this.createError('string.isoDate', {\n          value: value\n        }, state, options);\n      });\n    }\n  }, {\n    key: \"guid\",\n    value: function guid(guidOptions) {\n      var versionNumbers = '';\n\n      if (guidOptions && guidOptions.version) {\n        if (!Array.isArray(guidOptions.version)) {\n          guidOptions.version = [guidOptions.version];\n        }\n\n        Hoek.assert(guidOptions.version.length >= 1, 'version must have at least 1 valid version specified');\n        var versions = new Set();\n\n        for (var i = 0; i < guidOptions.version.length; ++i) {\n          var version = guidOptions.version[i];\n          Hoek.assert(typeof version === 'string', 'version at position ' + i + ' must be a string');\n          version = version.toLowerCase();\n          var versionNumber = internals.guidVersions[version];\n          Hoek.assert(versionNumber, 'version at position ' + i + ' must be one of ' + Object.keys(internals.guidVersions).join(', '));\n          Hoek.assert(!versions.has(versionNumber), 'version at position ' + i + ' must not be a duplicate.');\n          versionNumbers += versionNumber;\n          versions.add(versionNumber);\n        }\n      }\n\n      var guidRegex = new RegExp(\"^([\\\\[{\\\\(]?)[0-9A-F]{8}([:-]?)[0-9A-F]{4}\\\\2?[\".concat(versionNumbers || '0-9A-F', \"][0-9A-F]{3}\\\\2?[\").concat(versionNumbers ? '89AB' : '0-9A-F', \"][0-9A-F]{3}\\\\2?[0-9A-F]{12}([\\\\]}\\\\)]?)$\"), 'i');\n      return this._test('guid', guidOptions, function (value, state, options) {\n        var results = guidRegex.exec(value);\n\n        if (!results) {\n          return this.createError('string.guid', {\n            value: value\n          }, state, options);\n        } // Matching braces\n\n\n        if (internals.guidBrackets[results[1]] !== results[results.length - 1]) {\n          return this.createError('string.guid', {\n            value: value\n          }, state, options);\n        }\n\n        return value;\n      });\n    }\n  }, {\n    key: \"hex\",\n    value: function hex() {\n      var hexOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      Hoek.assert(typeof hexOptions === 'object', 'hex options must be an object');\n      Hoek.assert(typeof hexOptions.byteAligned === 'undefined' || typeof hexOptions.byteAligned === 'boolean', 'byteAligned must be boolean');\n      var byteAligned = hexOptions.byteAligned === true;\n      var regex = /^[a-f0-9]+$/i;\n\n      var obj = this._test('hex', regex, function (value, state, options) {\n        if (regex.test(value)) {\n          if (byteAligned && value.length % 2 !== 0) {\n            return this.createError('string.hexAlign', {\n              value: value\n            }, state, options);\n          }\n\n          return value;\n        }\n\n        return this.createError('string.hex', {\n          value: value\n        }, state, options);\n      });\n\n      if (byteAligned) {\n        obj._flags.byteAligned = true;\n      }\n\n      return obj;\n    }\n  }, {\n    key: \"base64\",\n    value: function base64() {\n      var base64Options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      // Validation.\n      Hoek.assert(typeof base64Options === 'object', 'base64 options must be an object');\n      Hoek.assert(typeof base64Options.paddingRequired === 'undefined' || typeof base64Options.paddingRequired === 'boolean', 'paddingRequired must be boolean'); // Determine if padding is required.\n\n      var paddingRequired = base64Options.paddingRequired === false ? base64Options.paddingRequired : base64Options.paddingRequired || true; // Set validation based on preference.\n\n      var regex = paddingRequired ? // Padding is required.\n      /^(?:[A-Za-z0-9+\\/]{4})*(?:[A-Za-z0-9+\\/]{2}==|[A-Za-z0-9+\\/]{3}=)?$/ // Padding is optional.\n      : /^(?:[A-Za-z0-9+\\/]{4})*(?:[A-Za-z0-9+\\/]{2}(==)?|[A-Za-z0-9+\\/]{3}=?)?$/;\n      return this._test('base64', regex, function (value, state, options) {\n        if (regex.test(value)) {\n          return value;\n        }\n\n        return this.createError('string.base64', {\n          value: value\n        }, state, options);\n      });\n    }\n  }, {\n    key: \"dataUri\",\n    value: function dataUri() {\n      var dataUriOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var regex = /^data:[\\w\\/\\+]+;((charset=[\\w-]+|base64),)?(.*)$/; // Determine if padding is required.\n\n      var paddingRequired = dataUriOptions.paddingRequired === false ? dataUriOptions.paddingRequired : dataUriOptions.paddingRequired || true;\n      var base64regex = paddingRequired ? /^(?:[A-Za-z0-9+\\/]{4})*(?:[A-Za-z0-9+\\/]{2}==|[A-Za-z0-9+\\/]{3}=)?$/ : /^(?:[A-Za-z0-9+\\/]{4})*(?:[A-Za-z0-9+\\/]{2}(==)?|[A-Za-z0-9+\\/]{3}=?)?$/;\n      return this._test('dataUri', regex, function (value, state, options) {\n        var matches = value.match(regex);\n\n        if (matches) {\n          if (!matches[2]) {\n            return value;\n          }\n\n          if (matches[2] !== 'base64') {\n            return value;\n          }\n\n          if (base64regex.test(matches[3])) {\n            return value;\n          }\n        }\n\n        return this.createError('string.dataUri', {\n          value: value\n        }, state, options);\n      });\n    }\n  }, {\n    key: \"hostname\",\n    value: function hostname() {\n      var regex = /^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\\-]*[A-Za-z0-9])$/;\n      return this._test('hostname', undefined, function (value, state, options) {\n        if (value.length <= 255 && regex.test(value) || Net.isIPv6(value)) {\n          return value;\n        }\n\n        return this.createError('string.hostname', {\n          value: value\n        }, state, options);\n      });\n    }\n  }, {\n    key: \"normalize\",\n    value: function normalize() {\n      var form = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'NFC';\n      Hoek.assert(Hoek.contain(internals.normalizationForms, form), 'normalization form must be one of ' + internals.normalizationForms.join(', '));\n\n      var obj = this._test('normalize', form, function (value, state, options) {\n        if (options.convert || value === value.normalize(form)) {\n          return value;\n        }\n\n        return this.createError('string.normalize', {\n          value: value,\n          form: form\n        }, state, options);\n      });\n\n      obj._flags.normalize = form;\n      return obj;\n    }\n  }, {\n    key: \"lowercase\",\n    value: function lowercase() {\n      var obj = this._test('lowercase', undefined, function (value, state, options) {\n        if (options.convert || value === value.toLocaleLowerCase()) {\n          return value;\n        }\n\n        return this.createError('string.lowercase', {\n          value: value\n        }, state, options);\n      });\n\n      obj._flags.case = 'lower';\n      return obj;\n    }\n  }, {\n    key: \"uppercase\",\n    value: function uppercase() {\n      var obj = this._test('uppercase', undefined, function (value, state, options) {\n        if (options.convert || value === value.toLocaleUpperCase()) {\n          return value;\n        }\n\n        return this.createError('string.uppercase', {\n          value: value\n        }, state, options);\n      });\n\n      obj._flags.case = 'upper';\n      return obj;\n    }\n  }, {\n    key: \"trim\",\n    value: function trim() {\n      var enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      Hoek.assert(typeof enabled === 'boolean', 'option must be a boolean');\n\n      if (this._flags.trim && enabled || !this._flags.trim && !enabled) {\n        return this;\n      }\n\n      var obj;\n\n      if (enabled) {\n        obj = this._test('trim', undefined, function (value, state, options) {\n          if (options.convert || value === value.trim()) {\n            return value;\n          }\n\n          return this.createError('string.trim', {\n            value: value\n          }, state, options);\n        });\n      } else {\n        obj = this.clone();\n        obj._tests = obj._tests.filter(function (test) {\n          return test.name !== 'trim';\n        });\n      }\n\n      obj._flags.trim = enabled;\n      return obj;\n    }\n  }, {\n    key: \"replace\",\n    value: function replace(pattern, replacement) {\n      if (typeof pattern === 'string') {\n        pattern = new RegExp(Hoek.escapeRegex(pattern), 'g');\n      }\n\n      Hoek.assert(pattern instanceof RegExp, 'pattern must be a RegExp');\n      Hoek.assert(typeof replacement === 'string', 'replacement must be a String'); // This can not be considere a test like trim, we can't \"reject\"\n      // anything from this rule, so just clone the current object\n\n      var obj = this.clone();\n\n      if (!obj._inner.replacements) {\n        obj._inner.replacements = [];\n      }\n\n      obj._inner.replacements.push({\n        pattern: pattern,\n        replacement: replacement\n      });\n\n      return obj;\n    }\n  }, {\n    key: \"truncate\",\n    value: function truncate(enabled) {\n      var value = enabled === undefined ? true : !!enabled;\n\n      if (this._flags.truncate === value) {\n        return this;\n      }\n\n      var obj = this.clone();\n      obj._flags.truncate = value;\n      return obj;\n    }\n  }]);\n\n  return _class;\n}(Any);\n\ninternals.compare = function (type, compare) {\n  return function (limit, encoding) {\n    var isRef = Ref.isRef(limit);\n    Hoek.assert(Number.isSafeInteger(limit) && limit >= 0 || isRef, 'limit must be a positive integer or reference');\n    Hoek.assert(!encoding || Buffer.isEncoding(encoding), 'Invalid encoding:', encoding);\n    return this._test(type, limit, function (value, state, options) {\n      var compareTo;\n\n      if (isRef) {\n        compareTo = limit(state.reference || state.parent, options);\n\n        if (!Number.isSafeInteger(compareTo)) {\n          return this.createError('string.ref', {\n            ref: limit.key\n          }, state, options);\n        }\n      } else {\n        compareTo = limit;\n      }\n\n      if (compare(value, compareTo, encoding)) {\n        return value;\n      }\n\n      return this.createError('string.' + type, {\n        limit: compareTo,\n        value: value,\n        encoding: encoding\n      }, state, options);\n    });\n  };\n};\n\ninternals.String.prototype.min = internals.compare('min', function (value, limit, encoding) {\n  var length = encoding ? Buffer.byteLength(value, encoding) : value.length;\n  return length >= limit;\n});\ninternals.String.prototype.max = internals.compare('max', function (value, limit, encoding) {\n  var length = encoding ? Buffer.byteLength(value, encoding) : value.length;\n  return length <= limit;\n});\ninternals.String.prototype.length = internals.compare('length', function (value, limit, encoding) {\n  var length = encoding ? Buffer.byteLength(value, encoding) : value.length;\n  return length === limit;\n}); // Aliases\n\ninternals.String.prototype.uuid = internals.String.prototype.guid;\nmodule.exports = new internals.String();","map":{"version":3,"sources":["/home/cloudmynds/Desktop/admin/node_modules/joi/lib/types/string/index.js"],"names":["Net","require","Hoek","Isemail","Any","Ref","JoiDate","Uri","Ip","internals","uriRegex","createUriRegex","ipRegex","createIpRegex","guidBrackets","guidVersions","uuidv1","uuidv2","uuidv3","uuidv4","uuidv5","cidrPresences","normalizationForms","String","_type","_invalids","add","value","state","options","convert","_flags","normalize","case","toLocaleUpperCase","toLocaleLowerCase","trim","_inner","replacements","i","length","replacement","replace","pattern","truncate","_tests","test","name","slice","arg","byteAligned","errors","createError","insensitive","obj","clone","_test","undefined","sum","mul","char","charAt","check","patternOptions","assert","RegExp","patternObject","source","ignoreCase","invert","errorCode","join","patternMatch","isEmailOptions","checkDNS","tldWhitelist","minDomainAtoms","Number","isSafeInteger","errorLevel","result","validate","e","ipOptions","regex","cidr","toLowerCase","contain","version","versions","Array","isArray","Object","keys","push","unique","uriOptions","customScheme","allowRelative","relativeOnly","allowQuerySquareBrackets","unknownOptions","filter","key","includes","scheme","escapeRegex","_isIsoDate","d","Date","isNaN","getTime","toISOString","guidOptions","versionNumbers","Set","versionNumber","has","guidRegex","results","exec","hexOptions","base64Options","paddingRequired","dataUriOptions","base64regex","matches","match","isIPv6","form","enabled","compare","type","limit","encoding","isRef","Buffer","isEncoding","compareTo","reference","parent","ref","prototype","min","byteLength","max","uuid","guid","module","exports"],"mappings":"AAAA,a,CAEA;;;;;;;;;;AAEA,IAAMA,GAAG,GAAGC,OAAO,CAAC,KAAD,CAAnB;;AACA,IAAMC,IAAI,GAAGD,OAAO,CAAC,MAAD,CAApB;;AACA,IAAIE,OAAJ,C,CAAwC;;AACxC,IAAMC,GAAG,GAAGH,OAAO,CAAC,QAAD,CAAnB;;AACA,IAAMI,GAAG,GAAGJ,OAAO,CAAC,WAAD,CAAnB;;AACA,IAAMK,OAAO,GAAGL,OAAO,CAAC,SAAD,CAAvB;;AACA,IAAMM,GAAG,GAAGN,OAAO,CAAC,OAAD,CAAnB;;AACA,IAAMO,EAAE,GAAGP,OAAO,CAAC,MAAD,CAAlB,C,CAEA;;;AAEA,IAAMQ,SAAS,GAAG;AACdC,EAAAA,QAAQ,EAAEH,GAAG,CAACI,cAAJ,EADI;AAEdC,EAAAA,OAAO,EAAEJ,EAAE,CAACK,aAAH,CAAiB,CAAC,MAAD,EAAS,MAAT,EAAiB,WAAjB,CAAjB,EAAgD,UAAhD,CAFK;AAGdC,EAAAA,YAAY,EAAE;AACV,SAAK,GADK;AACA,SAAK,GADL;AACU,SAAK,GADf;AACoB,QAAI;AADxB,GAHA;AAMdC,EAAAA,YAAY,EAAE;AACVC,IAAAA,MAAM,EAAE,GADE;AAEVC,IAAAA,MAAM,EAAE,GAFE;AAGVC,IAAAA,MAAM,EAAE,GAHE;AAIVC,IAAAA,MAAM,EAAE,GAJE;AAKVC,IAAAA,MAAM,EAAE;AALE,GANA;AAadC,EAAAA,aAAa,EAAE,CAAC,UAAD,EAAa,UAAb,EAAyB,WAAzB,CAbD;AAcdC,EAAAA,kBAAkB,EAAE,CAAC,KAAD,EAAQ,KAAR,EAAe,MAAf,EAAuB,MAAvB;AAdN,CAAlB;;AAiBAb,SAAS,CAACc,MAAV;AAAA;;AAAA;;AAEI,oBAAc;AAAA;;AAAA;;AAEV;AACA,UAAKC,KAAL,GAAa,QAAb;;AACA,UAAKC,SAAL,CAAeC,GAAf,CAAmB,EAAnB;;AAJU;AAKb;;AAPL;AAAA;AAAA,0BASUC,KATV,EASiBC,KATjB,EASwBC,OATxB,EASiC;AAEzB,UAAI,OAAOF,KAAP,KAAiB,QAAjB,IACAE,OAAO,CAACC,OADZ,EACqB;AAEjB,YAAI,KAAKC,MAAL,CAAYC,SAAhB,EAA2B;AACvBL,UAAAA,KAAK,GAAGA,KAAK,CAACK,SAAN,CAAgB,KAAKD,MAAL,CAAYC,SAA5B,CAAR;AACH;;AAED,YAAI,KAAKD,MAAL,CAAYE,IAAhB,EAAsB;AAClBN,UAAAA,KAAK,GAAI,KAAKI,MAAL,CAAYE,IAAZ,KAAqB,OAArB,GAA+BN,KAAK,CAACO,iBAAN,EAA/B,GAA2DP,KAAK,CAACQ,iBAAN,EAApE;AACH;;AAED,YAAI,KAAKJ,MAAL,CAAYK,IAAhB,EAAsB;AAClBT,UAAAA,KAAK,GAAGA,KAAK,CAACS,IAAN,EAAR;AACH;;AAED,YAAI,KAAKC,MAAL,CAAYC,YAAhB,EAA8B;AAE1B,eAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKF,MAAL,CAAYC,YAAZ,CAAyBE,MAA7C,EAAqD,EAAED,CAAvD,EAA0D;AACtD,gBAAME,WAAW,GAAG,KAAKJ,MAAL,CAAYC,YAAZ,CAAyBC,CAAzB,CAApB;AACAZ,YAAAA,KAAK,GAAGA,KAAK,CAACe,OAAN,CAAcD,WAAW,CAACE,OAA1B,EAAmCF,WAAW,CAACA,WAA/C,CAAR;AACH;AACJ;;AAED,YAAI,KAAKV,MAAL,CAAYa,QAAhB,EAA0B;AACtB,eAAK,IAAIL,EAAC,GAAG,CAAb,EAAgBA,EAAC,GAAG,KAAKM,MAAL,CAAYL,MAAhC,EAAwC,EAAED,EAA1C,EAA6C;AACzC,gBAAMO,IAAI,GAAG,KAAKD,MAAL,CAAYN,EAAZ,CAAb;;AACA,gBAAIO,IAAI,CAACC,IAAL,KAAc,KAAlB,EAAyB;AACrBpB,cAAAA,KAAK,GAAGA,KAAK,CAACqB,KAAN,CAAY,CAAZ,EAAeF,IAAI,CAACG,GAApB,CAAR;AACA;AACH;AACJ;AACJ;;AAED,YAAI,KAAKlB,MAAL,CAAYmB,WAAZ,IAA2BvB,KAAK,CAACa,MAAN,GAAe,CAAf,KAAqB,CAApD,EAAuD;AACnDb,UAAAA,KAAK,cAAOA,KAAP,CAAL;AACH;AACJ;;AAED,aAAO;AACHA,QAAAA,KAAK,EAALA,KADG;AAEHwB,QAAAA,MAAM,EAAG,OAAOxB,KAAP,KAAiB,QAAlB,GAA8B,IAA9B,GAAqC,KAAKyB,WAAL,CAAiB,aAAjB,EAAgC;AAAEzB,UAAAA,KAAK,EAALA;AAAF,SAAhC,EAA2CC,KAA3C,EAAkDC,OAAlD;AAF1C,OAAP;AAIH;AArDL;AAAA;AAAA,kCAuDkB;AAEV,UAAI,KAAKE,MAAL,CAAYsB,WAAhB,EAA6B;AACzB,eAAO,IAAP;AACH;;AAED,UAAMC,GAAG,GAAG,KAAKC,KAAL,EAAZ;AACAD,MAAAA,GAAG,CAACvB,MAAJ,CAAWsB,WAAX,GAAyB,IAAzB;AACA,aAAOC,GAAP;AACH;AAhEL;AAAA;AAAA,iCAkEiB;AAET,aAAO,KAAKE,KAAL,CAAW,YAAX,EAAyBC,SAAzB,EAAoC,UAAU9B,KAAV,EAAiBC,KAAjB,EAAwBC,OAAxB,EAAiC;AAExE,YAAIU,CAAC,GAAGZ,KAAK,CAACa,MAAd;AACA,YAAIkB,GAAG,GAAG,CAAV;AACA,YAAIC,GAAG,GAAG,CAAV;;AAEA,eAAOpB,CAAC,EAAR,EAAY;AACR,cAAMqB,IAAI,GAAGjC,KAAK,CAACkC,MAAN,CAAatB,CAAb,IAAkBoB,GAA/B;AACAD,UAAAA,GAAG,GAAGA,GAAG,IAAIE,IAAI,GAAG,CAACA,IAAI,GAAG,CAAR,IAAa,CAAxB,CAAT;AACAD,UAAAA,GAAG,GAAGA,GAAG,GAAG,CAAZ;AACH;;AAED,YAAMG,KAAK,GAAIJ,GAAG,GAAG,EAAN,KAAa,CAAd,IAAqBA,GAAG,GAAG,CAAzC;AACA,eAAOI,KAAK,GAAGnC,KAAH,GAAW,KAAKyB,WAAL,CAAiB,mBAAjB,EAAsC;AAAEzB,UAAAA,KAAK,EAALA;AAAF,SAAtC,EAAiDC,KAAjD,EAAwDC,OAAxD,CAAvB;AACH,OAdM,CAAP;AAeH;AAnFL;AAAA;AAAA,0BAqFUc,OArFV,EAqFmBoB,cArFnB,EAqFmC;AAE3B7D,MAAAA,IAAI,CAAC8D,MAAL,CAAYrB,OAAO,YAAYsB,MAA/B,EAAuC,0BAAvC;AAEA,UAAMC,aAAa,GAAG;AAClBvB,QAAAA,OAAO,EAAE,IAAIsB,MAAJ,CAAWtB,OAAO,CAACwB,MAAnB,EAA2BxB,OAAO,CAACyB,UAAR,GAAqB,GAArB,GAA2BX,SAAtD,CADS,CACgE;;AADhE,OAAtB;;AAIA,UAAI,OAAOM,cAAP,KAA0B,QAA9B,EAAwC;AACpCG,QAAAA,aAAa,CAACnB,IAAd,GAAqBgB,cAArB;AACH,OAFD,MAGK,IAAI,OAAOA,cAAP,KAA0B,QAA9B,EAAwC;AACzCG,QAAAA,aAAa,CAACG,MAAd,GAAuB,CAAC,CAACN,cAAc,CAACM,MAAxC;;AAEA,YAAIN,cAAc,CAAChB,IAAnB,EAAyB;AACrBmB,UAAAA,aAAa,CAACnB,IAAd,GAAqBgB,cAAc,CAAChB,IAApC;AACH;AACJ;;AAED,UAAMuB,SAAS,GAAG,CAAC,cAAD,EAAiBJ,aAAa,CAACG,MAAd,GAAuB,SAAvB,GAAmC,EAApD,EAAwDH,aAAa,CAACnB,IAAd,GAAqB,OAArB,GAA+B,OAAvF,EAAgGwB,IAAhG,CAAqG,EAArG,CAAlB;AAEA,aAAO,KAAKf,KAAL,CAAW,OAAX,EAAoBU,aAApB,EAAmC,UAAUvC,KAAV,EAAiBC,KAAjB,EAAwBC,OAAxB,EAAiC;AAEvE,YAAM2C,YAAY,GAAGN,aAAa,CAACvB,OAAd,CAAsBG,IAAtB,CAA2BnB,KAA3B,CAArB;;AAEA,YAAI6C,YAAY,GAAGN,aAAa,CAACG,MAAjC,EAAyC;AACrC,iBAAO1C,KAAP;AACH;;AAED,eAAO,KAAKyB,WAAL,CAAiBkB,SAAjB,EAA4B;AAAEvB,UAAAA,IAAI,EAAEmB,aAAa,CAACnB,IAAtB;AAA4BJ,UAAAA,OAAO,EAAEuB,aAAa,CAACvB,OAAnD;AAA4DhB,UAAAA,KAAK,EAALA;AAA5D,SAA5B,EAAiGC,KAAjG,EAAwGC,OAAxG,CAAP;AACH,OATM,CAAP;AAUH;AApHL;AAAA;AAAA,+BAsHe;AAEP,aAAO,KAAK2B,KAAL,CAAW,UAAX,EAAuBC,SAAvB,EAAkC,UAAU9B,KAAV,EAAiBC,KAAjB,EAAwBC,OAAxB,EAAiC;AAEtE,YAAI,iBAAiBiB,IAAjB,CAAsBnB,KAAtB,CAAJ,EAAkC;AAC9B,iBAAOA,KAAP;AACH;;AAED,eAAO,KAAKyB,WAAL,CAAiB,iBAAjB,EAAoC;AAAEzB,UAAAA,KAAK,EAALA;AAAF,SAApC,EAA+CC,KAA/C,EAAsDC,OAAtD,CAAP;AACH,OAPM,CAAP;AAQH;AAhIL;AAAA;AAAA,4BAkIY;AAEJ,aAAO,KAAK2B,KAAL,CAAW,OAAX,EAAoBC,SAApB,EAA+B,UAAU9B,KAAV,EAAiBC,KAAjB,EAAwBC,OAAxB,EAAiC;AAEnE,YAAI,QAAQiB,IAAR,CAAanB,KAAb,CAAJ,EAAyB;AACrB,iBAAOA,KAAP;AACH;;AAED,eAAO,KAAKyB,WAAL,CAAiB,cAAjB,EAAiC;AAAEzB,UAAAA,KAAK,EAALA;AAAF,SAAjC,EAA4CC,KAA5C,EAAmDC,OAAnD,CAAP;AACH,OAPM,CAAP;AAQH;AA5IL;AAAA;AAAA,0BA8IU4C,cA9IV,EA8I0B;AAElB,UAAIA,cAAJ,EAAoB;AAChBvE,QAAAA,IAAI,CAAC8D,MAAL,CAAY,OAAOS,cAAP,KAA0B,QAAtC,EAAgD,iCAAhD;AACAvE,QAAAA,IAAI,CAAC8D,MAAL,CAAY,OAAOS,cAAc,CAACC,QAAtB,KAAmC,WAA/C,EAA4D,kCAA5D;AACAxE,QAAAA,IAAI,CAAC8D,MAAL,CAAY,OAAOS,cAAc,CAACE,YAAtB,KAAuC,WAAvC,IACR,OAAOF,cAAc,CAACE,YAAtB,KAAuC,QAD3C,EACqD,yCADrD;AAEAzE,QAAAA,IAAI,CAAC8D,MAAL,CACI,OAAOS,cAAc,CAACG,cAAtB,KAAyC,WAAzC,IACAC,MAAM,CAACC,aAAP,CAAqBL,cAAc,CAACG,cAApC,KACAH,cAAc,CAACG,cAAf,GAAgC,CAHpC,EAII,2CAJJ;AAMA1E,QAAAA,IAAI,CAAC8D,MAAL,CACI,OAAOS,cAAc,CAACM,UAAtB,KAAqC,WAArC,IACA,OAAON,cAAc,CAACM,UAAtB,KAAqC,SADrC,IAGIF,MAAM,CAACC,aAAP,CAAqBL,cAAc,CAACM,UAApC,KACAN,cAAc,CAACM,UAAf,IAA6B,CALrC,EAOI,sDAPJ;AASH;;AAED,aAAO,KAAKvB,KAAL,CAAW,OAAX,EAAoBiB,cAApB,EAAoC,UAAU9C,KAAV,EAAiBC,KAAjB,EAAwBC,OAAxB,EAAiC;AAExE1B,QAAAA,OAAO,GAAGA,OAAO,IAAIF,OAAO,CAAC,SAAD,CAA5B;;AAEA,YAAI;AACA,cAAM+E,MAAM,GAAG7E,OAAO,CAAC8E,QAAR,CAAiBtD,KAAjB,EAAwB8C,cAAxB,CAAf;;AACA,cAAIO,MAAM,KAAK,IAAX,IAAmBA,MAAM,KAAK,CAAlC,EAAqC;AACjC,mBAAOrD,KAAP;AACH;AACJ,SALD,CAMA,OAAOuD,CAAP,EAAU,CAAG;;AAEb,eAAO,KAAK9B,WAAL,CAAiB,cAAjB,EAAiC;AAAEzB,UAAAA,KAAK,EAALA;AAAF,SAAjC,EAA4CC,KAA5C,EAAmDC,OAAnD,CAAP;AACH,OAbM,CAAP;AAcH;AApLL;AAAA;AAAA,yBAsLuB;AAAA,UAAhBsD,SAAgB,uEAAJ,EAAI;AAEf,UAAIC,KAAK,GAAG3E,SAAS,CAACG,OAAtB;AACAV,MAAAA,IAAI,CAAC8D,MAAL,CAAY,OAAOmB,SAAP,KAAqB,QAAjC,EAA2C,2BAA3C;;AAEA,UAAIA,SAAS,CAACE,IAAd,EAAoB;AAChBnF,QAAAA,IAAI,CAAC8D,MAAL,CAAY,OAAOmB,SAAS,CAACE,IAAjB,KAA0B,QAAtC,EAAgD,uBAAhD;AACAF,QAAAA,SAAS,CAACE,IAAV,GAAiBF,SAAS,CAACE,IAAV,CAAeC,WAAf,EAAjB;AAEApF,QAAAA,IAAI,CAAC8D,MAAL,CAAY9D,IAAI,CAACqF,OAAL,CAAa9E,SAAS,CAACY,aAAvB,EAAsC8D,SAAS,CAACE,IAAhD,CAAZ,EAAmE,yBAAyB5E,SAAS,CAACY,aAAV,CAAwBkD,IAAxB,CAA6B,IAA7B,CAA5F,EAJgB,CAMhB;;AACA,YAAI,CAACY,SAAS,CAACK,OAAX,IAAsBL,SAAS,CAACE,IAAV,KAAmB,UAA7C,EAAyD;AACrDD,UAAAA,KAAK,GAAG5E,EAAE,CAACK,aAAH,CAAiB,CAAC,MAAD,EAAS,MAAT,EAAiB,WAAjB,CAAjB,EAAgDsE,SAAS,CAACE,IAA1D,CAAR;AACH;AACJ,OAVD,MAWK;AAED;AACAF,QAAAA,SAAS,CAACE,IAAV,GAAiB,UAAjB;AACH;;AAED,UAAII,QAAJ;;AACA,UAAIN,SAAS,CAACK,OAAd,EAAuB;AACnB,YAAI,CAACE,KAAK,CAACC,OAAN,CAAcR,SAAS,CAACK,OAAxB,CAAL,EAAuC;AACnCL,UAAAA,SAAS,CAACK,OAAV,GAAoB,CAACL,SAAS,CAACK,OAAX,CAApB;AACH;;AAEDtF,QAAAA,IAAI,CAAC8D,MAAL,CAAYmB,SAAS,CAACK,OAAV,CAAkBhD,MAAlB,IAA4B,CAAxC,EAA2C,gDAA3C;AAEAiD,QAAAA,QAAQ,GAAG,EAAX;;AACA,aAAK,IAAIlD,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG4C,SAAS,CAACK,OAAV,CAAkBhD,MAAtC,EAA8C,EAAED,CAAhD,EAAmD;AAC/C,cAAIiD,OAAO,GAAGL,SAAS,CAACK,OAAV,CAAkBjD,CAAlB,CAAd;AACArC,UAAAA,IAAI,CAAC8D,MAAL,CAAY,OAAOwB,OAAP,KAAmB,QAA/B,EAAyC,yBAAyBjD,CAAzB,GAA6B,mBAAtE;AACAiD,UAAAA,OAAO,GAAGA,OAAO,CAACF,WAAR,EAAV;AACApF,UAAAA,IAAI,CAAC8D,MAAL,CAAYxD,EAAE,CAACiF,QAAH,CAAYD,OAAZ,CAAZ,EAAkC,yBAAyBjD,CAAzB,GAA6B,kBAA7B,GAAkDqD,MAAM,CAACC,IAAP,CAAYrF,EAAE,CAACiF,QAAf,EAAyBlB,IAAzB,CAA8B,IAA9B,CAApF;AACAkB,UAAAA,QAAQ,CAACK,IAAT,CAAcN,OAAd;AACH,SAdkB,CAgBnB;;;AACAC,QAAAA,QAAQ,GAAGvF,IAAI,CAAC6F,MAAL,CAAYN,QAAZ,CAAX;AAEAL,QAAAA,KAAK,GAAG5E,EAAE,CAACK,aAAH,CAAiB4E,QAAjB,EAA2BN,SAAS,CAACE,IAArC,CAAR;AACH;;AAED,aAAO,KAAK7B,KAAL,CAAW,IAAX,EAAiB2B,SAAjB,EAA4B,UAAUxD,KAAV,EAAiBC,KAAjB,EAAwBC,OAAxB,EAAiC;AAEhE,YAAIuD,KAAK,CAACtC,IAAN,CAAWnB,KAAX,CAAJ,EAAuB;AACnB,iBAAOA,KAAP;AACH;;AAED,YAAI8D,QAAJ,EAAc;AACV,iBAAO,KAAKrC,WAAL,CAAiB,kBAAjB,EAAqC;AAAEzB,YAAAA,KAAK,EAALA,KAAF;AAAS0D,YAAAA,IAAI,EAAEF,SAAS,CAACE,IAAzB;AAA+BG,YAAAA,OAAO,EAAEC;AAAxC,WAArC,EAAyF7D,KAAzF,EAAgGC,OAAhG,CAAP;AACH;;AAED,eAAO,KAAKuB,WAAL,CAAiB,WAAjB,EAA8B;AAAEzB,UAAAA,KAAK,EAALA,KAAF;AAAS0D,UAAAA,IAAI,EAAEF,SAAS,CAACE;AAAzB,SAA9B,EAA+DzD,KAA/D,EAAsEC,OAAtE,CAAP;AACH,OAXM,CAAP;AAYH;AA/OL;AAAA;AAAA,wBAiPQmE,UAjPR,EAiPoB;AAEZ,UAAIC,YAAY,GAAG,EAAnB;AACA,UAAIC,aAAa,GAAG,KAApB;AACA,UAAIC,YAAY,GAAG,KAAnB;AACA,UAAIC,wBAAwB,GAAG,KAA/B;AACA,UAAIhB,KAAK,GAAG3E,SAAS,CAACC,QAAtB;;AAEA,UAAIsF,UAAJ,EAAgB;AACZ9F,QAAAA,IAAI,CAAC8D,MAAL,CAAY,OAAOgC,UAAP,KAAsB,QAAlC,EAA4C,2BAA5C;AAEA,YAAMK,cAAc,GAAGT,MAAM,CAACC,IAAP,CAAYG,UAAZ,EAAwBM,MAAxB,CAA+B,UAACC,GAAD;AAAA,iBAAS,CAAC,CAAC,QAAD,EAAW,eAAX,EAA4B,cAA5B,EAA4C,0BAA5C,EAAwEC,QAAxE,CAAiFD,GAAjF,CAAV;AAAA,SAA/B,CAAvB;AACArG,QAAAA,IAAI,CAAC8D,MAAL,CAAYqC,cAAc,CAAC7D,MAAf,KAA0B,CAAtC,0CAA0E6D,cAA1E;;AAEA,YAAIL,UAAU,CAACS,MAAf,EAAuB;AACnBvG,UAAAA,IAAI,CAAC8D,MAAL,CAAYgC,UAAU,CAACS,MAAX,YAA6BxC,MAA7B,IAAuC,OAAO+B,UAAU,CAACS,MAAlB,KAA6B,QAApE,IAAgFf,KAAK,CAACC,OAAN,CAAcK,UAAU,CAACS,MAAzB,CAA5F,EAA8H,2CAA9H;;AAEA,cAAI,CAACf,KAAK,CAACC,OAAN,CAAcK,UAAU,CAACS,MAAzB,CAAL,EAAuC;AACnCT,YAAAA,UAAU,CAACS,MAAX,GAAoB,CAACT,UAAU,CAACS,MAAZ,CAApB;AACH;;AAEDvG,UAAAA,IAAI,CAAC8D,MAAL,CAAYgC,UAAU,CAACS,MAAX,CAAkBjE,MAAlB,IAA4B,CAAxC,EAA2C,8CAA3C,EAPmB,CASnB;;AACA,eAAK,IAAID,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGyD,UAAU,CAACS,MAAX,CAAkBjE,MAAtC,EAA8C,EAAED,CAAhD,EAAmD;AAC/C,gBAAMkE,MAAM,GAAGT,UAAU,CAACS,MAAX,CAAkBlE,CAAlB,CAAf;AACArC,YAAAA,IAAI,CAAC8D,MAAL,CAAYyC,MAAM,YAAYxC,MAAlB,IAA4B,OAAOwC,MAAP,KAAkB,QAA1D,EAAoE,wBAAwBlE,CAAxB,GAA4B,6BAAhG,EAF+C,CAI/C;;AACA0D,YAAAA,YAAY,GAAGA,YAAY,IAAIA,YAAY,GAAG,GAAH,GAAS,EAAzB,CAA3B,CAL+C,CAO/C;;AACA,gBAAIQ,MAAM,YAAYxC,MAAtB,EAA8B;AAC1BgC,cAAAA,YAAY,GAAGA,YAAY,GAAGQ,MAAM,CAACtC,MAArC;AACH,aAFD,MAGK;AACDjE,cAAAA,IAAI,CAAC8D,MAAL,CAAY,2BAA2BlB,IAA3B,CAAgC2D,MAAhC,CAAZ,EAAqD,wBAAwBlE,CAAxB,GAA4B,yBAAjF;AACA0D,cAAAA,YAAY,GAAGA,YAAY,GAAG/F,IAAI,CAACwG,WAAL,CAAiBD,MAAjB,CAA9B;AACH;AACJ;AACJ;;AAED,YAAIT,UAAU,CAACE,aAAf,EAA8B;AAC1BA,UAAAA,aAAa,GAAG,IAAhB;AACH;;AAED,YAAIF,UAAU,CAACG,YAAf,EAA6B;AACzBA,UAAAA,YAAY,GAAG,IAAf;AACH;;AAED,YAAIH,UAAU,CAACI,wBAAf,EAAyC;AACrCA,UAAAA,wBAAwB,GAAG,IAA3B;AACH;AACJ;;AAED,UAAIH,YAAY,IAAIC,aAAhB,IAAiCC,YAAjC,IAAiDC,wBAArD,EAA+E;AAC3EhB,QAAAA,KAAK,GAAG7E,GAAG,CAACI,cAAJ,CAAmBsF,YAAnB,EAAiCC,aAAjC,EAAgDC,YAAhD,EAA8DC,wBAA9D,CAAR;AACH;;AAED,aAAO,KAAK5C,KAAL,CAAW,KAAX,EAAkBwC,UAAlB,EAA8B,UAAUrE,KAAV,EAAiBC,KAAjB,EAAwBC,OAAxB,EAAiC;AAElE,YAAIuD,KAAK,CAACtC,IAAN,CAAWnB,KAAX,CAAJ,EAAuB;AACnB,iBAAOA,KAAP;AACH;;AAED,YAAIwE,YAAJ,EAAkB;AACd,iBAAO,KAAK/C,WAAL,CAAiB,wBAAjB,EAA2C;AAAEzB,YAAAA,KAAK,EAALA;AAAF,WAA3C,EAAsDC,KAAtD,EAA6DC,OAA7D,CAAP;AACH;;AAED,YAAIoE,YAAJ,EAAkB;AACd,iBAAO,KAAK7C,WAAL,CAAiB,wBAAjB,EAA2C;AAAEqD,YAAAA,MAAM,EAAER,YAAV;AAAwBtE,YAAAA,KAAK,EAALA;AAAxB,WAA3C,EAA4EC,KAA5E,EAAmFC,OAAnF,CAAP;AACH;;AAED,eAAO,KAAKuB,WAAL,CAAiB,YAAjB,EAA+B;AAAEzB,UAAAA,KAAK,EAALA;AAAF,SAA/B,EAA0CC,KAA1C,EAAiDC,OAAjD,CAAP;AACH,OAfM,CAAP;AAgBH;AA5TL;AAAA;AAAA,8BA8Tc;AAEN,aAAO,KAAK2B,KAAL,CAAW,SAAX,EAAsBC,SAAtB,EAAiC,UAAU9B,KAAV,EAAiBC,KAAjB,EAAwBC,OAAxB,EAAiC;AAErE,YAAIvB,OAAO,CAACqG,UAAR,CAAmBhF,KAAnB,CAAJ,EAA+B;AAC3B,cAAI,CAACE,OAAO,CAACC,OAAb,EAAsB;AAClB,mBAAOH,KAAP;AACH;;AAED,cAAMiF,CAAC,GAAG,IAAIC,IAAJ,CAASlF,KAAT,CAAV;;AACA,cAAI,CAACmF,KAAK,CAACF,CAAC,CAACG,OAAF,EAAD,CAAV,EAAyB;AACrB,mBAAOH,CAAC,CAACI,WAAF,EAAP;AACH;AACJ;;AAED,eAAO,KAAK5D,WAAL,CAAiB,gBAAjB,EAAmC;AAAEzB,UAAAA,KAAK,EAALA;AAAF,SAAnC,EAA8CC,KAA9C,EAAqDC,OAArD,CAAP;AACH,OAdM,CAAP;AAeH;AA/UL;AAAA;AAAA,yBAiVSoF,WAjVT,EAiVsB;AAEd,UAAIC,cAAc,GAAG,EAArB;;AAEA,UAAID,WAAW,IAAIA,WAAW,CAACzB,OAA/B,EAAwC;AACpC,YAAI,CAACE,KAAK,CAACC,OAAN,CAAcsB,WAAW,CAACzB,OAA1B,CAAL,EAAyC;AACrCyB,UAAAA,WAAW,CAACzB,OAAZ,GAAsB,CAACyB,WAAW,CAACzB,OAAb,CAAtB;AACH;;AAEDtF,QAAAA,IAAI,CAAC8D,MAAL,CAAYiD,WAAW,CAACzB,OAAZ,CAAoBhD,MAApB,IAA8B,CAA1C,EAA6C,sDAA7C;AACA,YAAMiD,QAAQ,GAAG,IAAI0B,GAAJ,EAAjB;;AAEA,aAAK,IAAI5E,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG0E,WAAW,CAACzB,OAAZ,CAAoBhD,MAAxC,EAAgD,EAAED,CAAlD,EAAqD;AACjD,cAAIiD,OAAO,GAAGyB,WAAW,CAACzB,OAAZ,CAAoBjD,CAApB,CAAd;AACArC,UAAAA,IAAI,CAAC8D,MAAL,CAAY,OAAOwB,OAAP,KAAmB,QAA/B,EAAyC,yBAAyBjD,CAAzB,GAA6B,mBAAtE;AACAiD,UAAAA,OAAO,GAAGA,OAAO,CAACF,WAAR,EAAV;AACA,cAAM8B,aAAa,GAAG3G,SAAS,CAACM,YAAV,CAAuByE,OAAvB,CAAtB;AACAtF,UAAAA,IAAI,CAAC8D,MAAL,CAAYoD,aAAZ,EAA2B,yBAAyB7E,CAAzB,GAA6B,kBAA7B,GAAkDqD,MAAM,CAACC,IAAP,CAAYpF,SAAS,CAACM,YAAtB,EAAoCwD,IAApC,CAAyC,IAAzC,CAA7E;AACArE,UAAAA,IAAI,CAAC8D,MAAL,CAAY,CAAEyB,QAAQ,CAAC4B,GAAT,CAAaD,aAAb,CAAd,EAA4C,yBAAyB7E,CAAzB,GAA6B,2BAAzE;AAEA2E,UAAAA,cAAc,IAAIE,aAAlB;AACA3B,UAAAA,QAAQ,CAAC/D,GAAT,CAAa0F,aAAb;AACH;AACJ;;AAED,UAAME,SAAS,GAAG,IAAIrD,MAAJ,0DAA6DiD,cAAc,IAAI,QAA/E,8BAA2GA,cAAc,GAAG,MAAH,GAAY,QAArI,gDAA0L,GAA1L,CAAlB;AAEA,aAAO,KAAK1D,KAAL,CAAW,MAAX,EAAmByD,WAAnB,EAAgC,UAAUtF,KAAV,EAAiBC,KAAjB,EAAwBC,OAAxB,EAAiC;AAEpE,YAAM0F,OAAO,GAAGD,SAAS,CAACE,IAAV,CAAe7F,KAAf,CAAhB;;AAEA,YAAI,CAAC4F,OAAL,EAAc;AACV,iBAAO,KAAKnE,WAAL,CAAiB,aAAjB,EAAgC;AAAEzB,YAAAA,KAAK,EAALA;AAAF,WAAhC,EAA2CC,KAA3C,EAAkDC,OAAlD,CAAP;AACH,SANmE,CAQpE;;;AACA,YAAIpB,SAAS,CAACK,YAAV,CAAuByG,OAAO,CAAC,CAAD,CAA9B,MAAuCA,OAAO,CAACA,OAAO,CAAC/E,MAAR,GAAiB,CAAlB,CAAlD,EAAwE;AACpE,iBAAO,KAAKY,WAAL,CAAiB,aAAjB,EAAgC;AAAEzB,YAAAA,KAAK,EAALA;AAAF,WAAhC,EAA2CC,KAA3C,EAAkDC,OAAlD,CAAP;AACH;;AAED,eAAOF,KAAP;AACH,OAdM,CAAP;AAeH;AA3XL;AAAA;AAAA,0BA6XyB;AAAA,UAAjB8F,UAAiB,uEAAJ,EAAI;AAEjBvH,MAAAA,IAAI,CAAC8D,MAAL,CAAY,OAAOyD,UAAP,KAAsB,QAAlC,EAA4C,+BAA5C;AACAvH,MAAAA,IAAI,CAAC8D,MAAL,CAAY,OAAOyD,UAAU,CAACvE,WAAlB,KAAkC,WAAlC,IAAiD,OAAOuE,UAAU,CAACvE,WAAlB,KAAkC,SAA/F,EACI,6BADJ;AAGA,UAAMA,WAAW,GAAGuE,UAAU,CAACvE,WAAX,KAA2B,IAA/C;AACA,UAAMkC,KAAK,GAAG,cAAd;;AAEA,UAAM9B,GAAG,GAAG,KAAKE,KAAL,CAAW,KAAX,EAAkB4B,KAAlB,EAAyB,UAAUzD,KAAV,EAAiBC,KAAjB,EAAwBC,OAAxB,EAAiC;AAElE,YAAIuD,KAAK,CAACtC,IAAN,CAAWnB,KAAX,CAAJ,EAAuB;AACnB,cAAIuB,WAAW,IAAIvB,KAAK,CAACa,MAAN,GAAe,CAAf,KAAqB,CAAxC,EAA2C;AACvC,mBAAO,KAAKY,WAAL,CAAiB,iBAAjB,EAAoC;AAAEzB,cAAAA,KAAK,EAALA;AAAF,aAApC,EAA+CC,KAA/C,EAAsDC,OAAtD,CAAP;AACH;;AACD,iBAAOF,KAAP;AACH;;AAED,eAAO,KAAKyB,WAAL,CAAiB,YAAjB,EAA+B;AAAEzB,UAAAA,KAAK,EAALA;AAAF,SAA/B,EAA0CC,KAA1C,EAAiDC,OAAjD,CAAP;AACH,OAVW,CAAZ;;AAYA,UAAIqB,WAAJ,EAAiB;AACbI,QAAAA,GAAG,CAACvB,MAAJ,CAAWmB,WAAX,GAAyB,IAAzB;AACH;;AAED,aAAOI,GAAP;AACH;AAvZL;AAAA;AAAA,6BAyZ+B;AAAA,UAApBoE,aAAoB,uEAAJ,EAAI;AAEvB;AACAxH,MAAAA,IAAI,CAAC8D,MAAL,CAAY,OAAO0D,aAAP,KAAyB,QAArC,EAA+C,kCAA/C;AACAxH,MAAAA,IAAI,CAAC8D,MAAL,CAAY,OAAO0D,aAAa,CAACC,eAArB,KAAyC,WAAzC,IAAwD,OAAOD,aAAa,CAACC,eAArB,KAAyC,SAA7G,EACI,iCADJ,EAJuB,CAOvB;;AACA,UAAMA,eAAe,GAAGD,aAAa,CAACC,eAAd,KAAkC,KAAlC,GACpBD,aAAa,CAACC,eADM,GAElBD,aAAa,CAACC,eAAd,IAAiC,IAFvC,CARuB,CAYvB;;AACA,UAAMvC,KAAK,GAAGuC,eAAe,GACzB;AACA,2EAFyB,CAGzB;AAHyB,QAIvB,yEAJN;AAMA,aAAO,KAAKnE,KAAL,CAAW,QAAX,EAAqB4B,KAArB,EAA4B,UAAUzD,KAAV,EAAiBC,KAAjB,EAAwBC,OAAxB,EAAiC;AAEhE,YAAIuD,KAAK,CAACtC,IAAN,CAAWnB,KAAX,CAAJ,EAAuB;AACnB,iBAAOA,KAAP;AACH;;AAED,eAAO,KAAKyB,WAAL,CAAiB,eAAjB,EAAkC;AAAEzB,UAAAA,KAAK,EAALA;AAAF,SAAlC,EAA6CC,KAA7C,EAAoDC,OAApD,CAAP;AACH,OAPM,CAAP;AAQH;AApbL;AAAA;AAAA,8BAsbiC;AAAA,UAArB+F,cAAqB,uEAAJ,EAAI;AAEzB,UAAMxC,KAAK,GAAG,kDAAd,CAFyB,CAIzB;;AACA,UAAMuC,eAAe,GAAGC,cAAc,CAACD,eAAf,KAAmC,KAAnC,GACpBC,cAAc,CAACD,eADK,GAElBC,cAAc,CAACD,eAAf,IAAkC,IAFxC;AAIA,UAAME,WAAW,GAAIF,eAAe,GAChC,qEADgC,GAE9B,yEAFN;AAIA,aAAO,KAAKnE,KAAL,CAAW,SAAX,EAAsB4B,KAAtB,EAA6B,UAAUzD,KAAV,EAAiBC,KAAjB,EAAwBC,OAAxB,EAAiC;AAEjE,YAAMiG,OAAO,GAAGnG,KAAK,CAACoG,KAAN,CAAY3C,KAAZ,CAAhB;;AAEA,YAAI0C,OAAJ,EAAa;AACT,cAAI,CAACA,OAAO,CAAC,CAAD,CAAZ,EAAiB;AACb,mBAAOnG,KAAP;AACH;;AAED,cAAImG,OAAO,CAAC,CAAD,CAAP,KAAe,QAAnB,EAA6B;AACzB,mBAAOnG,KAAP;AACH;;AAED,cAAIkG,WAAW,CAAC/E,IAAZ,CAAiBgF,OAAO,CAAC,CAAD,CAAxB,CAAJ,EAAkC;AAC9B,mBAAOnG,KAAP;AACH;AACJ;;AAED,eAAO,KAAKyB,WAAL,CAAiB,gBAAjB,EAAmC;AAAEzB,UAAAA,KAAK,EAALA;AAAF,SAAnC,EAA8CC,KAA9C,EAAqDC,OAArD,CAAP;AACH,OAnBM,CAAP;AAoBH;AAvdL;AAAA;AAAA,+BAyde;AAEP,UAAMuD,KAAK,GAAG,6GAAd;AAEA,aAAO,KAAK5B,KAAL,CAAW,UAAX,EAAuBC,SAAvB,EAAkC,UAAU9B,KAAV,EAAiBC,KAAjB,EAAwBC,OAAxB,EAAiC;AAEtE,YAAKF,KAAK,CAACa,MAAN,IAAgB,GAAhB,IAAuB4C,KAAK,CAACtC,IAAN,CAAWnB,KAAX,CAAxB,IACA3B,GAAG,CAACgI,MAAJ,CAAWrG,KAAX,CADJ,EACuB;AAEnB,iBAAOA,KAAP;AACH;;AAED,eAAO,KAAKyB,WAAL,CAAiB,iBAAjB,EAAoC;AAAEzB,UAAAA,KAAK,EAALA;AAAF,SAApC,EAA+CC,KAA/C,EAAsDC,OAAtD,CAAP;AACH,OATM,CAAP;AAUH;AAveL;AAAA;AAAA,gCAye4B;AAAA,UAAdoG,IAAc,uEAAP,KAAO;AAEpB/H,MAAAA,IAAI,CAAC8D,MAAL,CAAY9D,IAAI,CAACqF,OAAL,CAAa9E,SAAS,CAACa,kBAAvB,EAA2C2G,IAA3C,CAAZ,EAA8D,uCAAuCxH,SAAS,CAACa,kBAAV,CAA6BiD,IAA7B,CAAkC,IAAlC,CAArG;;AAEA,UAAMjB,GAAG,GAAG,KAAKE,KAAL,CAAW,WAAX,EAAwByE,IAAxB,EAA8B,UAAUtG,KAAV,EAAiBC,KAAjB,EAAwBC,OAAxB,EAAiC;AAEvE,YAAIA,OAAO,CAACC,OAAR,IACAH,KAAK,KAAKA,KAAK,CAACK,SAAN,CAAgBiG,IAAhB,CADd,EACqC;AAEjC,iBAAOtG,KAAP;AACH;;AAED,eAAO,KAAKyB,WAAL,CAAiB,kBAAjB,EAAqC;AAAEzB,UAAAA,KAAK,EAALA,KAAF;AAASsG,UAAAA,IAAI,EAAJA;AAAT,SAArC,EAAsDrG,KAAtD,EAA6DC,OAA7D,CAAP;AACH,OATW,CAAZ;;AAWAyB,MAAAA,GAAG,CAACvB,MAAJ,CAAWC,SAAX,GAAuBiG,IAAvB;AACA,aAAO3E,GAAP;AACH;AA1fL;AAAA;AAAA,gCA4fgB;AAER,UAAMA,GAAG,GAAG,KAAKE,KAAL,CAAW,WAAX,EAAwBC,SAAxB,EAAmC,UAAU9B,KAAV,EAAiBC,KAAjB,EAAwBC,OAAxB,EAAiC;AAE5E,YAAIA,OAAO,CAACC,OAAR,IACAH,KAAK,KAAKA,KAAK,CAACQ,iBAAN,EADd,EACyC;AAErC,iBAAOR,KAAP;AACH;;AAED,eAAO,KAAKyB,WAAL,CAAiB,kBAAjB,EAAqC;AAAEzB,UAAAA,KAAK,EAALA;AAAF,SAArC,EAAgDC,KAAhD,EAAuDC,OAAvD,CAAP;AACH,OATW,CAAZ;;AAWAyB,MAAAA,GAAG,CAACvB,MAAJ,CAAWE,IAAX,GAAkB,OAAlB;AACA,aAAOqB,GAAP;AACH;AA3gBL;AAAA;AAAA,gCA6gBgB;AAER,UAAMA,GAAG,GAAG,KAAKE,KAAL,CAAW,WAAX,EAAwBC,SAAxB,EAAmC,UAAU9B,KAAV,EAAiBC,KAAjB,EAAwBC,OAAxB,EAAiC;AAE5E,YAAIA,OAAO,CAACC,OAAR,IACAH,KAAK,KAAKA,KAAK,CAACO,iBAAN,EADd,EACyC;AAErC,iBAAOP,KAAP;AACH;;AAED,eAAO,KAAKyB,WAAL,CAAiB,kBAAjB,EAAqC;AAAEzB,UAAAA,KAAK,EAALA;AAAF,SAArC,EAAgDC,KAAhD,EAAuDC,OAAvD,CAAP;AACH,OATW,CAAZ;;AAWAyB,MAAAA,GAAG,CAACvB,MAAJ,CAAWE,IAAX,GAAkB,OAAlB;AACA,aAAOqB,GAAP;AACH;AA5hBL;AAAA;AAAA,2BA8hByB;AAAA,UAAhB4E,OAAgB,uEAAN,IAAM;AAEjBhI,MAAAA,IAAI,CAAC8D,MAAL,CAAY,OAAOkE,OAAP,KAAmB,SAA/B,EAA0C,0BAA1C;;AAEA,UAAK,KAAKnG,MAAL,CAAYK,IAAZ,IAAoB8F,OAArB,IAAkC,CAAC,KAAKnG,MAAL,CAAYK,IAAb,IAAqB,CAAC8F,OAA5D,EAAsE;AAClE,eAAO,IAAP;AACH;;AAED,UAAI5E,GAAJ;;AACA,UAAI4E,OAAJ,EAAa;AACT5E,QAAAA,GAAG,GAAG,KAAKE,KAAL,CAAW,MAAX,EAAmBC,SAAnB,EAA8B,UAAU9B,KAAV,EAAiBC,KAAjB,EAAwBC,OAAxB,EAAiC;AAEjE,cAAIA,OAAO,CAACC,OAAR,IACAH,KAAK,KAAKA,KAAK,CAACS,IAAN,EADd,EAC4B;AAExB,mBAAOT,KAAP;AACH;;AAED,iBAAO,KAAKyB,WAAL,CAAiB,aAAjB,EAAgC;AAAEzB,YAAAA,KAAK,EAALA;AAAF,WAAhC,EAA2CC,KAA3C,EAAkDC,OAAlD,CAAP;AACH,SATK,CAAN;AAUH,OAXD,MAYK;AACDyB,QAAAA,GAAG,GAAG,KAAKC,KAAL,EAAN;AACAD,QAAAA,GAAG,CAACT,MAAJ,GAAaS,GAAG,CAACT,MAAJ,CAAWyD,MAAX,CAAkB,UAACxD,IAAD;AAAA,iBAAUA,IAAI,CAACC,IAAL,KAAc,MAAxB;AAAA,SAAlB,CAAb;AACH;;AAEDO,MAAAA,GAAG,CAACvB,MAAJ,CAAWK,IAAX,GAAkB8F,OAAlB;AACA,aAAO5E,GAAP;AACH;AA1jBL;AAAA;AAAA,4BA4jBYX,OA5jBZ,EA4jBqBF,WA5jBrB,EA4jBkC;AAE1B,UAAI,OAAOE,OAAP,KAAmB,QAAvB,EAAiC;AAC7BA,QAAAA,OAAO,GAAG,IAAIsB,MAAJ,CAAW/D,IAAI,CAACwG,WAAL,CAAiB/D,OAAjB,CAAX,EAAsC,GAAtC,CAAV;AACH;;AAEDzC,MAAAA,IAAI,CAAC8D,MAAL,CAAYrB,OAAO,YAAYsB,MAA/B,EAAuC,0BAAvC;AACA/D,MAAAA,IAAI,CAAC8D,MAAL,CAAY,OAAOvB,WAAP,KAAuB,QAAnC,EAA6C,8BAA7C,EAP0B,CAS1B;AACA;;AACA,UAAMa,GAAG,GAAG,KAAKC,KAAL,EAAZ;;AAEA,UAAI,CAACD,GAAG,CAACjB,MAAJ,CAAWC,YAAhB,EAA8B;AAC1BgB,QAAAA,GAAG,CAACjB,MAAJ,CAAWC,YAAX,GAA0B,EAA1B;AACH;;AAEDgB,MAAAA,GAAG,CAACjB,MAAJ,CAAWC,YAAX,CAAwBwD,IAAxB,CAA6B;AACzBnD,QAAAA,OAAO,EAAPA,OADyB;AAEzBF,QAAAA,WAAW,EAAXA;AAFyB,OAA7B;;AAKA,aAAOa,GAAP;AACH;AAnlBL;AAAA;AAAA,6BAqlBa4E,OArlBb,EAqlBsB;AAEd,UAAMvG,KAAK,GAAGuG,OAAO,KAAKzE,SAAZ,GAAwB,IAAxB,GAA+B,CAAC,CAACyE,OAA/C;;AAEA,UAAI,KAAKnG,MAAL,CAAYa,QAAZ,KAAyBjB,KAA7B,EAAoC;AAChC,eAAO,IAAP;AACH;;AAED,UAAM2B,GAAG,GAAG,KAAKC,KAAL,EAAZ;AACAD,MAAAA,GAAG,CAACvB,MAAJ,CAAWa,QAAX,GAAsBjB,KAAtB;AACA,aAAO2B,GAAP;AACH;AAhmBL;;AAAA;AAAA,EAAiClD,GAAjC;;AAomBAK,SAAS,CAAC0H,OAAV,GAAoB,UAAUC,IAAV,EAAgBD,OAAhB,EAAyB;AAEzC,SAAO,UAAUE,KAAV,EAAiBC,QAAjB,EAA2B;AAE9B,QAAMC,KAAK,GAAGlI,GAAG,CAACkI,KAAJ,CAAUF,KAAV,CAAd;AAEAnI,IAAAA,IAAI,CAAC8D,MAAL,CAAaa,MAAM,CAACC,aAAP,CAAqBuD,KAArB,KAA+BA,KAAK,IAAI,CAAzC,IAA+CE,KAA3D,EAAkE,+CAAlE;AACArI,IAAAA,IAAI,CAAC8D,MAAL,CAAY,CAACsE,QAAD,IAAaE,MAAM,CAACC,UAAP,CAAkBH,QAAlB,CAAzB,EAAsD,mBAAtD,EAA2EA,QAA3E;AAEA,WAAO,KAAK9E,KAAL,CAAW4E,IAAX,EAAiBC,KAAjB,EAAwB,UAAU1G,KAAV,EAAiBC,KAAjB,EAAwBC,OAAxB,EAAiC;AAE5D,UAAI6G,SAAJ;;AACA,UAAIH,KAAJ,EAAW;AACPG,QAAAA,SAAS,GAAGL,KAAK,CAACzG,KAAK,CAAC+G,SAAN,IAAmB/G,KAAK,CAACgH,MAA1B,EAAkC/G,OAAlC,CAAjB;;AAEA,YAAI,CAACgD,MAAM,CAACC,aAAP,CAAqB4D,SAArB,CAAL,EAAsC;AAClC,iBAAO,KAAKtF,WAAL,CAAiB,YAAjB,EAA+B;AAAEyF,YAAAA,GAAG,EAAER,KAAK,CAAC9B;AAAb,WAA/B,EAAmD3E,KAAnD,EAA0DC,OAA1D,CAAP;AACH;AACJ,OAND,MAOK;AACD6G,QAAAA,SAAS,GAAGL,KAAZ;AACH;;AAED,UAAIF,OAAO,CAACxG,KAAD,EAAQ+G,SAAR,EAAmBJ,QAAnB,CAAX,EAAyC;AACrC,eAAO3G,KAAP;AACH;;AAED,aAAO,KAAKyB,WAAL,CAAiB,YAAYgF,IAA7B,EAAmC;AAAEC,QAAAA,KAAK,EAAEK,SAAT;AAAoB/G,QAAAA,KAAK,EAALA,KAApB;AAA2B2G,QAAAA,QAAQ,EAARA;AAA3B,OAAnC,EAA0E1G,KAA1E,EAAiFC,OAAjF,CAAP;AACH,KAnBM,CAAP;AAoBH,GA3BD;AA4BH,CA9BD;;AAiCApB,SAAS,CAACc,MAAV,CAAiBuH,SAAjB,CAA2BC,GAA3B,GAAiCtI,SAAS,CAAC0H,OAAV,CAAkB,KAAlB,EAAyB,UAACxG,KAAD,EAAQ0G,KAAR,EAAeC,QAAf,EAA4B;AAElF,MAAM9F,MAAM,GAAG8F,QAAQ,GAAGE,MAAM,CAACQ,UAAP,CAAkBrH,KAAlB,EAAyB2G,QAAzB,CAAH,GAAwC3G,KAAK,CAACa,MAArE;AACA,SAAOA,MAAM,IAAI6F,KAAjB;AACH,CAJgC,CAAjC;AAOA5H,SAAS,CAACc,MAAV,CAAiBuH,SAAjB,CAA2BG,GAA3B,GAAiCxI,SAAS,CAAC0H,OAAV,CAAkB,KAAlB,EAAyB,UAACxG,KAAD,EAAQ0G,KAAR,EAAeC,QAAf,EAA4B;AAElF,MAAM9F,MAAM,GAAG8F,QAAQ,GAAGE,MAAM,CAACQ,UAAP,CAAkBrH,KAAlB,EAAyB2G,QAAzB,CAAH,GAAwC3G,KAAK,CAACa,MAArE;AACA,SAAOA,MAAM,IAAI6F,KAAjB;AACH,CAJgC,CAAjC;AAOA5H,SAAS,CAACc,MAAV,CAAiBuH,SAAjB,CAA2BtG,MAA3B,GAAoC/B,SAAS,CAAC0H,OAAV,CAAkB,QAAlB,EAA4B,UAACxG,KAAD,EAAQ0G,KAAR,EAAeC,QAAf,EAA4B;AAExF,MAAM9F,MAAM,GAAG8F,QAAQ,GAAGE,MAAM,CAACQ,UAAP,CAAkBrH,KAAlB,EAAyB2G,QAAzB,CAAH,GAAwC3G,KAAK,CAACa,MAArE;AACA,SAAOA,MAAM,KAAK6F,KAAlB;AACH,CAJmC,CAApC,C,CAMA;;AAEA5H,SAAS,CAACc,MAAV,CAAiBuH,SAAjB,CAA2BI,IAA3B,GAAkCzI,SAAS,CAACc,MAAV,CAAiBuH,SAAjB,CAA2BK,IAA7D;AAEAC,MAAM,CAACC,OAAP,GAAiB,IAAI5I,SAAS,CAACc,MAAd,EAAjB","sourcesContent":["'use strict';\n\n// Load modules\n\nconst Net = require('net');\nconst Hoek = require('hoek');\nlet Isemail;                            // Loaded on demand\nconst Any = require('../any');\nconst Ref = require('../../ref');\nconst JoiDate = require('../date');\nconst Uri = require('./uri');\nconst Ip = require('./ip');\n\n// Declare internals\n\nconst internals = {\n    uriRegex: Uri.createUriRegex(),\n    ipRegex: Ip.createIpRegex(['ipv4', 'ipv6', 'ipvfuture'], 'optional'),\n    guidBrackets: {\n        '{': '}', '[': ']', '(': ')', '': ''\n    },\n    guidVersions: {\n        uuidv1: '1',\n        uuidv2: '2',\n        uuidv3: '3',\n        uuidv4: '4',\n        uuidv5: '5'\n    },\n    cidrPresences: ['required', 'optional', 'forbidden'],\n    normalizationForms: ['NFC', 'NFD', 'NFKC', 'NFKD']\n};\n\ninternals.String = class extends Any {\n\n    constructor() {\n\n        super();\n        this._type = 'string';\n        this._invalids.add('');\n    }\n\n    _base(value, state, options) {\n\n        if (typeof value === 'string' &&\n            options.convert) {\n\n            if (this._flags.normalize) {\n                value = value.normalize(this._flags.normalize);\n            }\n\n            if (this._flags.case) {\n                value = (this._flags.case === 'upper' ? value.toLocaleUpperCase() : value.toLocaleLowerCase());\n            }\n\n            if (this._flags.trim) {\n                value = value.trim();\n            }\n\n            if (this._inner.replacements) {\n\n                for (let i = 0; i < this._inner.replacements.length; ++i) {\n                    const replacement = this._inner.replacements[i];\n                    value = value.replace(replacement.pattern, replacement.replacement);\n                }\n            }\n\n            if (this._flags.truncate) {\n                for (let i = 0; i < this._tests.length; ++i) {\n                    const test = this._tests[i];\n                    if (test.name === 'max') {\n                        value = value.slice(0, test.arg);\n                        break;\n                    }\n                }\n            }\n\n            if (this._flags.byteAligned && value.length % 2 !== 0) {\n                value = `0${value}`;\n            }\n        }\n\n        return {\n            value,\n            errors: (typeof value === 'string') ? null : this.createError('string.base', { value }, state, options)\n        };\n    }\n\n    insensitive() {\n\n        if (this._flags.insensitive) {\n            return this;\n        }\n\n        const obj = this.clone();\n        obj._flags.insensitive = true;\n        return obj;\n    }\n\n    creditCard() {\n\n        return this._test('creditCard', undefined, function (value, state, options) {\n\n            let i = value.length;\n            let sum = 0;\n            let mul = 1;\n\n            while (i--) {\n                const char = value.charAt(i) * mul;\n                sum = sum + (char - (char > 9) * 9);\n                mul = mul ^ 3;\n            }\n\n            const check = (sum % 10 === 0) && (sum > 0);\n            return check ? value : this.createError('string.creditCard', { value }, state, options);\n        });\n    }\n\n    regex(pattern, patternOptions) {\n\n        Hoek.assert(pattern instanceof RegExp, 'pattern must be a RegExp');\n\n        const patternObject = {\n            pattern: new RegExp(pattern.source, pattern.ignoreCase ? 'i' : undefined)         // Future version should break this and forbid unsupported regex flags\n        };\n\n        if (typeof patternOptions === 'string') {\n            patternObject.name = patternOptions;\n        }\n        else if (typeof patternOptions === 'object') {\n            patternObject.invert = !!patternOptions.invert;\n\n            if (patternOptions.name) {\n                patternObject.name = patternOptions.name;\n            }\n        }\n\n        const errorCode = ['string.regex', patternObject.invert ? '.invert' : '', patternObject.name ? '.name' : '.base'].join('');\n\n        return this._test('regex', patternObject, function (value, state, options) {\n\n            const patternMatch = patternObject.pattern.test(value);\n\n            if (patternMatch ^ patternObject.invert) {\n                return value;\n            }\n\n            return this.createError(errorCode, { name: patternObject.name, pattern: patternObject.pattern, value }, state, options);\n        });\n    }\n\n    alphanum() {\n\n        return this._test('alphanum', undefined, function (value, state, options) {\n\n            if (/^[a-zA-Z0-9]+$/.test(value)) {\n                return value;\n            }\n\n            return this.createError('string.alphanum', { value }, state, options);\n        });\n    }\n\n    token() {\n\n        return this._test('token', undefined, function (value, state, options) {\n\n            if (/^\\w+$/.test(value)) {\n                return value;\n            }\n\n            return this.createError('string.token', { value }, state, options);\n        });\n    }\n\n    email(isEmailOptions) {\n\n        if (isEmailOptions) {\n            Hoek.assert(typeof isEmailOptions === 'object', 'email options must be an object');\n            Hoek.assert(typeof isEmailOptions.checkDNS === 'undefined', 'checkDNS option is not supported');\n            Hoek.assert(typeof isEmailOptions.tldWhitelist === 'undefined' ||\n                typeof isEmailOptions.tldWhitelist === 'object', 'tldWhitelist must be an array or object');\n            Hoek.assert(\n                typeof isEmailOptions.minDomainAtoms === 'undefined' ||\n                Number.isSafeInteger(isEmailOptions.minDomainAtoms) &&\n                isEmailOptions.minDomainAtoms > 0,\n                'minDomainAtoms must be a positive integer'\n            );\n            Hoek.assert(\n                typeof isEmailOptions.errorLevel === 'undefined' ||\n                typeof isEmailOptions.errorLevel === 'boolean' ||\n                (\n                    Number.isSafeInteger(isEmailOptions.errorLevel) &&\n                    isEmailOptions.errorLevel >= 0\n                ),\n                'errorLevel must be a non-negative integer or boolean'\n            );\n        }\n\n        return this._test('email', isEmailOptions, function (value, state, options) {\n\n            Isemail = Isemail || require('isemail');\n\n            try {\n                const result = Isemail.validate(value, isEmailOptions);\n                if (result === true || result === 0) {\n                    return value;\n                }\n            }\n            catch (e) { }\n\n            return this.createError('string.email', { value }, state, options);\n        });\n    }\n\n    ip(ipOptions = {}) {\n\n        let regex = internals.ipRegex;\n        Hoek.assert(typeof ipOptions === 'object', 'options must be an object');\n\n        if (ipOptions.cidr) {\n            Hoek.assert(typeof ipOptions.cidr === 'string', 'cidr must be a string');\n            ipOptions.cidr = ipOptions.cidr.toLowerCase();\n\n            Hoek.assert(Hoek.contain(internals.cidrPresences, ipOptions.cidr), 'cidr must be one of ' + internals.cidrPresences.join(', '));\n\n            // If we only received a `cidr` setting, create a regex for it. But we don't need to create one if `cidr` is \"optional\" since that is the default\n            if (!ipOptions.version && ipOptions.cidr !== 'optional') {\n                regex = Ip.createIpRegex(['ipv4', 'ipv6', 'ipvfuture'], ipOptions.cidr);\n            }\n        }\n        else {\n\n            // Set our default cidr strategy\n            ipOptions.cidr = 'optional';\n        }\n\n        let versions;\n        if (ipOptions.version) {\n            if (!Array.isArray(ipOptions.version)) {\n                ipOptions.version = [ipOptions.version];\n            }\n\n            Hoek.assert(ipOptions.version.length >= 1, 'version must have at least 1 version specified');\n\n            versions = [];\n            for (let i = 0; i < ipOptions.version.length; ++i) {\n                let version = ipOptions.version[i];\n                Hoek.assert(typeof version === 'string', 'version at position ' + i + ' must be a string');\n                version = version.toLowerCase();\n                Hoek.assert(Ip.versions[version], 'version at position ' + i + ' must be one of ' + Object.keys(Ip.versions).join(', '));\n                versions.push(version);\n            }\n\n            // Make sure we have a set of versions\n            versions = Hoek.unique(versions);\n\n            regex = Ip.createIpRegex(versions, ipOptions.cidr);\n        }\n\n        return this._test('ip', ipOptions, function (value, state, options) {\n\n            if (regex.test(value)) {\n                return value;\n            }\n\n            if (versions) {\n                return this.createError('string.ipVersion', { value, cidr: ipOptions.cidr, version: versions }, state, options);\n            }\n\n            return this.createError('string.ip', { value, cidr: ipOptions.cidr }, state, options);\n        });\n    }\n\n    uri(uriOptions) {\n\n        let customScheme = '';\n        let allowRelative = false;\n        let relativeOnly = false;\n        let allowQuerySquareBrackets = false;\n        let regex = internals.uriRegex;\n\n        if (uriOptions) {\n            Hoek.assert(typeof uriOptions === 'object', 'options must be an object');\n\n            const unknownOptions = Object.keys(uriOptions).filter((key) => !['scheme', 'allowRelative', 'relativeOnly', 'allowQuerySquareBrackets'].includes(key));\n            Hoek.assert(unknownOptions.length === 0, `options contain unknown keys: ${unknownOptions}`);\n\n            if (uriOptions.scheme) {\n                Hoek.assert(uriOptions.scheme instanceof RegExp || typeof uriOptions.scheme === 'string' || Array.isArray(uriOptions.scheme), 'scheme must be a RegExp, String, or Array');\n\n                if (!Array.isArray(uriOptions.scheme)) {\n                    uriOptions.scheme = [uriOptions.scheme];\n                }\n\n                Hoek.assert(uriOptions.scheme.length >= 1, 'scheme must have at least 1 scheme specified');\n\n                // Flatten the array into a string to be used to match the schemes.\n                for (let i = 0; i < uriOptions.scheme.length; ++i) {\n                    const scheme = uriOptions.scheme[i];\n                    Hoek.assert(scheme instanceof RegExp || typeof scheme === 'string', 'scheme at position ' + i + ' must be a RegExp or String');\n\n                    // Add OR separators if a value already exists\n                    customScheme = customScheme + (customScheme ? '|' : '');\n\n                    // If someone wants to match HTTP or HTTPS for example then we need to support both RegExp and String so we don't escape their pattern unknowingly.\n                    if (scheme instanceof RegExp) {\n                        customScheme = customScheme + scheme.source;\n                    }\n                    else {\n                        Hoek.assert(/[a-zA-Z][a-zA-Z0-9+-\\.]*/.test(scheme), 'scheme at position ' + i + ' must be a valid scheme');\n                        customScheme = customScheme + Hoek.escapeRegex(scheme);\n                    }\n                }\n            }\n\n            if (uriOptions.allowRelative) {\n                allowRelative = true;\n            }\n\n            if (uriOptions.relativeOnly) {\n                relativeOnly = true;\n            }\n\n            if (uriOptions.allowQuerySquareBrackets) {\n                allowQuerySquareBrackets = true;\n            }\n        }\n\n        if (customScheme || allowRelative || relativeOnly || allowQuerySquareBrackets) {\n            regex = Uri.createUriRegex(customScheme, allowRelative, relativeOnly, allowQuerySquareBrackets);\n        }\n\n        return this._test('uri', uriOptions, function (value, state, options) {\n\n            if (regex.test(value)) {\n                return value;\n            }\n\n            if (relativeOnly) {\n                return this.createError('string.uriRelativeOnly', { value }, state, options);\n            }\n\n            if (customScheme) {\n                return this.createError('string.uriCustomScheme', { scheme: customScheme, value }, state, options);\n            }\n\n            return this.createError('string.uri', { value }, state, options);\n        });\n    }\n\n    isoDate() {\n\n        return this._test('isoDate', undefined, function (value, state, options) {\n\n            if (JoiDate._isIsoDate(value)) {\n                if (!options.convert) {\n                    return value;\n                }\n\n                const d = new Date(value);\n                if (!isNaN(d.getTime())) {\n                    return d.toISOString();\n                }\n            }\n\n            return this.createError('string.isoDate', { value }, state, options);\n        });\n    }\n\n    guid(guidOptions) {\n\n        let versionNumbers = '';\n\n        if (guidOptions && guidOptions.version) {\n            if (!Array.isArray(guidOptions.version)) {\n                guidOptions.version = [guidOptions.version];\n            }\n\n            Hoek.assert(guidOptions.version.length >= 1, 'version must have at least 1 valid version specified');\n            const versions = new Set();\n\n            for (let i = 0; i < guidOptions.version.length; ++i) {\n                let version = guidOptions.version[i];\n                Hoek.assert(typeof version === 'string', 'version at position ' + i + ' must be a string');\n                version = version.toLowerCase();\n                const versionNumber = internals.guidVersions[version];\n                Hoek.assert(versionNumber, 'version at position ' + i + ' must be one of ' + Object.keys(internals.guidVersions).join(', '));\n                Hoek.assert(!(versions.has(versionNumber)), 'version at position ' + i + ' must not be a duplicate.');\n\n                versionNumbers += versionNumber;\n                versions.add(versionNumber);\n            }\n        }\n\n        const guidRegex = new RegExp(`^([\\\\[{\\\\(]?)[0-9A-F]{8}([:-]?)[0-9A-F]{4}\\\\2?[${versionNumbers || '0-9A-F'}][0-9A-F]{3}\\\\2?[${versionNumbers ? '89AB' : '0-9A-F'}][0-9A-F]{3}\\\\2?[0-9A-F]{12}([\\\\]}\\\\)]?)$`, 'i');\n\n        return this._test('guid', guidOptions, function (value, state, options) {\n\n            const results = guidRegex.exec(value);\n\n            if (!results) {\n                return this.createError('string.guid', { value }, state, options);\n            }\n\n            // Matching braces\n            if (internals.guidBrackets[results[1]] !== results[results.length - 1]) {\n                return this.createError('string.guid', { value }, state, options);\n            }\n\n            return value;\n        });\n    }\n\n    hex(hexOptions = {}) {\n\n        Hoek.assert(typeof hexOptions === 'object', 'hex options must be an object');\n        Hoek.assert(typeof hexOptions.byteAligned === 'undefined' || typeof hexOptions.byteAligned === 'boolean',\n            'byteAligned must be boolean');\n\n        const byteAligned = hexOptions.byteAligned === true;\n        const regex = /^[a-f0-9]+$/i;\n\n        const obj = this._test('hex', regex, function (value, state, options) {\n\n            if (regex.test(value)) {\n                if (byteAligned && value.length % 2 !== 0) {\n                    return this.createError('string.hexAlign', { value }, state, options);\n                }\n                return value;\n            }\n\n            return this.createError('string.hex', { value }, state, options);\n        });\n\n        if (byteAligned) {\n            obj._flags.byteAligned = true;\n        }\n\n        return obj;\n    }\n\n    base64(base64Options = {}) {\n\n        // Validation.\n        Hoek.assert(typeof base64Options === 'object', 'base64 options must be an object');\n        Hoek.assert(typeof base64Options.paddingRequired === 'undefined' || typeof base64Options.paddingRequired === 'boolean',\n            'paddingRequired must be boolean');\n\n        // Determine if padding is required.\n        const paddingRequired = base64Options.paddingRequired === false ?\n            base64Options.paddingRequired\n            : base64Options.paddingRequired || true;\n\n        // Set validation based on preference.\n        const regex = paddingRequired ?\n            // Padding is required.\n            /^(?:[A-Za-z0-9+\\/]{4})*(?:[A-Za-z0-9+\\/]{2}==|[A-Za-z0-9+\\/]{3}=)?$/\n            // Padding is optional.\n            : /^(?:[A-Za-z0-9+\\/]{4})*(?:[A-Za-z0-9+\\/]{2}(==)?|[A-Za-z0-9+\\/]{3}=?)?$/;\n\n        return this._test('base64', regex, function (value, state, options) {\n\n            if (regex.test(value)) {\n                return value;\n            }\n\n            return this.createError('string.base64', { value }, state, options);\n        });\n    }\n\n    dataUri(dataUriOptions = {}) {\n\n        const regex = /^data:[\\w\\/\\+]+;((charset=[\\w-]+|base64),)?(.*)$/;\n\n        // Determine if padding is required.\n        const paddingRequired = dataUriOptions.paddingRequired === false ?\n            dataUriOptions.paddingRequired\n            : dataUriOptions.paddingRequired || true;\n\n        const base64regex =  paddingRequired ?\n            /^(?:[A-Za-z0-9+\\/]{4})*(?:[A-Za-z0-9+\\/]{2}==|[A-Za-z0-9+\\/]{3}=)?$/\n            : /^(?:[A-Za-z0-9+\\/]{4})*(?:[A-Za-z0-9+\\/]{2}(==)?|[A-Za-z0-9+\\/]{3}=?)?$/;\n\n        return this._test('dataUri', regex, function (value, state, options) {\n\n            const matches = value.match(regex);\n\n            if (matches) {\n                if (!matches[2]) {\n                    return value;\n                }\n\n                if (matches[2] !== 'base64') {\n                    return value;\n                }\n\n                if (base64regex.test(matches[3])) {\n                    return value;\n                }\n            }\n\n            return this.createError('string.dataUri', { value }, state, options);\n        });\n    }\n\n    hostname() {\n\n        const regex = /^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\\-]*[A-Za-z0-9])$/;\n\n        return this._test('hostname', undefined, function (value, state, options) {\n\n            if ((value.length <= 255 && regex.test(value)) ||\n                Net.isIPv6(value)) {\n\n                return value;\n            }\n\n            return this.createError('string.hostname', { value }, state, options);\n        });\n    }\n\n    normalize(form = 'NFC') {\n\n        Hoek.assert(Hoek.contain(internals.normalizationForms, form), 'normalization form must be one of ' + internals.normalizationForms.join(', '));\n\n        const obj = this._test('normalize', form, function (value, state, options) {\n\n            if (options.convert ||\n                value === value.normalize(form)) {\n\n                return value;\n            }\n\n            return this.createError('string.normalize', { value, form }, state, options);\n        });\n\n        obj._flags.normalize = form;\n        return obj;\n    }\n\n    lowercase() {\n\n        const obj = this._test('lowercase', undefined, function (value, state, options) {\n\n            if (options.convert ||\n                value === value.toLocaleLowerCase()) {\n\n                return value;\n            }\n\n            return this.createError('string.lowercase', { value }, state, options);\n        });\n\n        obj._flags.case = 'lower';\n        return obj;\n    }\n\n    uppercase() {\n\n        const obj = this._test('uppercase', undefined, function (value, state, options) {\n\n            if (options.convert ||\n                value === value.toLocaleUpperCase()) {\n\n                return value;\n            }\n\n            return this.createError('string.uppercase', { value }, state, options);\n        });\n\n        obj._flags.case = 'upper';\n        return obj;\n    }\n\n    trim(enabled = true) {\n\n        Hoek.assert(typeof enabled === 'boolean', 'option must be a boolean');\n\n        if ((this._flags.trim && enabled) || (!this._flags.trim && !enabled)) {\n            return this;\n        }\n\n        let obj;\n        if (enabled) {\n            obj = this._test('trim', undefined, function (value, state, options) {\n\n                if (options.convert ||\n                    value === value.trim()) {\n\n                    return value;\n                }\n\n                return this.createError('string.trim', { value }, state, options);\n            });\n        }\n        else {\n            obj = this.clone();\n            obj._tests = obj._tests.filter((test) => test.name !== 'trim');\n        }\n\n        obj._flags.trim = enabled;\n        return obj;\n    }\n\n    replace(pattern, replacement) {\n\n        if (typeof pattern === 'string') {\n            pattern = new RegExp(Hoek.escapeRegex(pattern), 'g');\n        }\n\n        Hoek.assert(pattern instanceof RegExp, 'pattern must be a RegExp');\n        Hoek.assert(typeof replacement === 'string', 'replacement must be a String');\n\n        // This can not be considere a test like trim, we can't \"reject\"\n        // anything from this rule, so just clone the current object\n        const obj = this.clone();\n\n        if (!obj._inner.replacements) {\n            obj._inner.replacements = [];\n        }\n\n        obj._inner.replacements.push({\n            pattern,\n            replacement\n        });\n\n        return obj;\n    }\n\n    truncate(enabled) {\n\n        const value = enabled === undefined ? true : !!enabled;\n\n        if (this._flags.truncate === value) {\n            return this;\n        }\n\n        const obj = this.clone();\n        obj._flags.truncate = value;\n        return obj;\n    }\n\n};\n\ninternals.compare = function (type, compare) {\n\n    return function (limit, encoding) {\n\n        const isRef = Ref.isRef(limit);\n\n        Hoek.assert((Number.isSafeInteger(limit) && limit >= 0) || isRef, 'limit must be a positive integer or reference');\n        Hoek.assert(!encoding || Buffer.isEncoding(encoding), 'Invalid encoding:', encoding);\n\n        return this._test(type, limit, function (value, state, options) {\n\n            let compareTo;\n            if (isRef) {\n                compareTo = limit(state.reference || state.parent, options);\n\n                if (!Number.isSafeInteger(compareTo)) {\n                    return this.createError('string.ref', { ref: limit.key }, state, options);\n                }\n            }\n            else {\n                compareTo = limit;\n            }\n\n            if (compare(value, compareTo, encoding)) {\n                return value;\n            }\n\n            return this.createError('string.' + type, { limit: compareTo, value, encoding }, state, options);\n        });\n    };\n};\n\n\ninternals.String.prototype.min = internals.compare('min', (value, limit, encoding) => {\n\n    const length = encoding ? Buffer.byteLength(value, encoding) : value.length;\n    return length >= limit;\n});\n\n\ninternals.String.prototype.max = internals.compare('max', (value, limit, encoding) => {\n\n    const length = encoding ? Buffer.byteLength(value, encoding) : value.length;\n    return length <= limit;\n});\n\n\ninternals.String.prototype.length = internals.compare('length', (value, limit, encoding) => {\n\n    const length = encoding ? Buffer.byteLength(value, encoding) : value.length;\n    return length === limit;\n});\n\n// Aliases\n\ninternals.String.prototype.uuid = internals.String.prototype.guid;\n\nmodule.exports = new internals.String();\n"]},"metadata":{},"sourceType":"script"}