{"ast":null,"code":"'use strict'; // Load modules\n\nvar _classCallCheck = require(\"/home/cloudmynds/Desktop/admin/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/cloudmynds/Desktop/admin/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _get = require(\"/home/cloudmynds/Desktop/admin/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"/home/cloudmynds/Desktop/admin/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/home/cloudmynds/Desktop/admin/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/home/cloudmynds/Desktop/admin/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar Any = require('../any');\n\nvar Cast = require('../../cast');\n\nvar Ref = require('../../ref');\n\nvar Hoek = require('hoek'); // Declare internals\n\n\nvar internals = {};\n\ninternals.fastSplice = function (arr, i) {\n  var pos = i;\n\n  while (pos < arr.length) {\n    arr[pos++] = arr[pos];\n  }\n\n  --arr.length;\n};\n\ninternals.Array = /*#__PURE__*/function (_Any) {\n  _inherits(_class, _Any);\n\n  var _super = _createSuper(_class);\n\n  function _class() {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    _this = _super.call(this);\n    _this._type = 'array';\n    _this._inner.items = [];\n    _this._inner.ordereds = [];\n    _this._inner.inclusions = [];\n    _this._inner.exclusions = [];\n    _this._inner.requireds = [];\n    _this._flags.sparse = false;\n    return _this;\n  }\n\n  _createClass(_class, [{\n    key: \"_base\",\n    value: function _base(value, state, options) {\n      var result = {\n        value: value\n      };\n\n      if (typeof value === 'string' && options.convert) {\n        internals.safeParse(value, result);\n      }\n\n      var isArray = Array.isArray(result.value);\n      var wasArray = isArray;\n\n      if (options.convert && this._flags.single && !isArray) {\n        result.value = [result.value];\n        isArray = true;\n      }\n\n      if (!isArray) {\n        result.errors = this.createError('array.base', null, state, options);\n        return result;\n      }\n\n      if (this._inner.inclusions.length || this._inner.exclusions.length || this._inner.requireds.length || this._inner.ordereds.length || !this._flags.sparse) {\n        // Clone the array so that we don't modify the original\n        if (wasArray) {\n          result.value = result.value.slice(0);\n        }\n\n        result.errors = this._checkItems.call(this, result.value, wasArray, state, options);\n\n        if (result.errors && wasArray && options.convert && this._flags.single) {\n          // Attempt a 2nd pass by putting the array inside one.\n          var previousErrors = result.errors;\n          result.value = [result.value];\n          result.errors = this._checkItems.call(this, result.value, wasArray, state, options);\n\n          if (result.errors) {\n            // Restore previous errors and value since this didn't validate either.\n            result.errors = previousErrors;\n            result.value = result.value[0];\n          }\n        }\n      }\n\n      return result;\n    }\n  }, {\n    key: \"_checkItems\",\n    value: function _checkItems(items, wasArray, state, options) {\n      var errors = [];\n      var errored;\n\n      var requireds = this._inner.requireds.slice();\n\n      var ordereds = this._inner.ordereds.slice();\n\n      var inclusions = this._inner.inclusions.concat(requireds);\n\n      var il = items.length;\n\n      for (var i = 0; i < il; ++i) {\n        errored = false;\n        var item = items[i];\n        var isValid = false;\n        var key = wasArray ? i : state.key;\n        var path = wasArray ? state.path.concat(i) : state.path;\n        var localState = {\n          key: key,\n          path: path,\n          parent: state.parent,\n          reference: state.reference\n        };\n        var res = void 0; // Sparse\n\n        if (!this._flags.sparse && item === undefined) {\n          errors.push(this.createError('array.sparse', null, {\n            key: state.key,\n            path: localState.path,\n            pos: i\n          }, options));\n\n          if (options.abortEarly) {\n            return errors;\n          }\n\n          ordereds.shift();\n          continue;\n        } // Exclusions\n\n\n        for (var j = 0; j < this._inner.exclusions.length; ++j) {\n          res = this._inner.exclusions[j]._validate(item, localState, {}); // Not passing options to use defaults\n\n          if (!res.errors) {\n            errors.push(this.createError(wasArray ? 'array.excludes' : 'array.excludesSingle', {\n              pos: i,\n              value: item\n            }, {\n              key: state.key,\n              path: localState.path\n            }, options));\n            errored = true;\n\n            if (options.abortEarly) {\n              return errors;\n            }\n\n            ordereds.shift();\n            break;\n          }\n        }\n\n        if (errored) {\n          continue;\n        } // Ordered\n\n\n        if (this._inner.ordereds.length) {\n          if (ordereds.length > 0) {\n            var ordered = ordereds.shift();\n            res = ordered._validate(item, localState, options);\n\n            if (!res.errors) {\n              if (ordered._flags.strip) {\n                internals.fastSplice(items, i);\n                --i;\n                --il;\n              } else if (!this._flags.sparse && res.value === undefined) {\n                errors.push(this.createError('array.sparse', null, {\n                  key: state.key,\n                  path: localState.path,\n                  pos: i\n                }, options));\n\n                if (options.abortEarly) {\n                  return errors;\n                }\n\n                continue;\n              } else {\n                items[i] = res.value;\n              }\n            } else {\n              errors.push(this.createError('array.ordered', {\n                pos: i,\n                reason: res.errors,\n                value: item\n              }, {\n                key: state.key,\n                path: localState.path\n              }, options));\n\n              if (options.abortEarly) {\n                return errors;\n              }\n            }\n\n            continue;\n          } else if (!this._inner.items.length) {\n            errors.push(this.createError('array.orderedLength', {\n              pos: i,\n              limit: this._inner.ordereds.length\n            }, {\n              key: state.key,\n              path: localState.path\n            }, options));\n\n            if (options.abortEarly) {\n              return errors;\n            }\n\n            continue;\n          }\n        } // Requireds\n\n\n        var requiredChecks = [];\n        var jl = requireds.length;\n\n        for (var _j = 0; _j < jl; ++_j) {\n          res = requiredChecks[_j] = requireds[_j]._validate(item, localState, options);\n\n          if (!res.errors) {\n            items[i] = res.value;\n            isValid = true;\n            internals.fastSplice(requireds, _j);\n            --_j;\n            --jl;\n\n            if (!this._flags.sparse && res.value === undefined) {\n              errors.push(this.createError('array.sparse', null, {\n                key: state.key,\n                path: localState.path,\n                pos: i\n              }, options));\n\n              if (options.abortEarly) {\n                return errors;\n              }\n            }\n\n            break;\n          }\n        }\n\n        if (isValid) {\n          continue;\n        } // Inclusions\n\n\n        var stripUnknown = options.stripUnknown ? options.stripUnknown === true ? true : !!options.stripUnknown.arrays : false;\n        jl = inclusions.length;\n\n        for (var _j2 = 0; _j2 < jl; ++_j2) {\n          var inclusion = inclusions[_j2]; // Avoid re-running requireds that already didn't match in the previous loop\n\n          var previousCheck = requireds.indexOf(inclusion);\n\n          if (previousCheck !== -1) {\n            res = requiredChecks[previousCheck];\n          } else {\n            res = inclusion._validate(item, localState, options);\n\n            if (!res.errors) {\n              if (inclusion._flags.strip) {\n                internals.fastSplice(items, i);\n                --i;\n                --il;\n              } else if (!this._flags.sparse && res.value === undefined) {\n                errors.push(this.createError('array.sparse', null, {\n                  key: state.key,\n                  path: localState.path,\n                  pos: i\n                }, options));\n                errored = true;\n              } else {\n                items[i] = res.value;\n              }\n\n              isValid = true;\n              break;\n            }\n          } // Return the actual error if only one inclusion defined\n\n\n          if (jl === 1) {\n            if (stripUnknown) {\n              internals.fastSplice(items, i);\n              --i;\n              --il;\n              isValid = true;\n              break;\n            }\n\n            errors.push(this.createError(wasArray ? 'array.includesOne' : 'array.includesOneSingle', {\n              pos: i,\n              reason: res.errors,\n              value: item\n            }, {\n              key: state.key,\n              path: localState.path\n            }, options));\n            errored = true;\n\n            if (options.abortEarly) {\n              return errors;\n            }\n\n            break;\n          }\n        }\n\n        if (errored) {\n          continue;\n        }\n\n        if (this._inner.inclusions.length && !isValid) {\n          if (stripUnknown) {\n            internals.fastSplice(items, i);\n            --i;\n            --il;\n            continue;\n          }\n\n          errors.push(this.createError(wasArray ? 'array.includes' : 'array.includesSingle', {\n            pos: i,\n            value: item\n          }, {\n            key: state.key,\n            path: localState.path\n          }, options));\n\n          if (options.abortEarly) {\n            return errors;\n          }\n        }\n      }\n\n      if (requireds.length) {\n        this._fillMissedErrors.call(this, errors, requireds, state, options);\n      }\n\n      if (ordereds.length) {\n        this._fillOrderedErrors.call(this, errors, ordereds, state, options);\n      }\n\n      return errors.length ? errors : null;\n    }\n  }, {\n    key: \"describe\",\n    value: function describe() {\n      var description = _get(_getPrototypeOf(_class.prototype), \"describe\", this).call(this);\n\n      if (this._inner.ordereds.length) {\n        description.orderedItems = [];\n\n        for (var i = 0; i < this._inner.ordereds.length; ++i) {\n          description.orderedItems.push(this._inner.ordereds[i].describe());\n        }\n      }\n\n      if (this._inner.items.length) {\n        description.items = [];\n\n        for (var _i = 0; _i < this._inner.items.length; ++_i) {\n          description.items.push(this._inner.items[_i].describe());\n        }\n      }\n\n      return description;\n    }\n  }, {\n    key: \"items\",\n    value: function items() {\n      var _this2 = this;\n\n      var obj = this.clone();\n\n      for (var _len = arguments.length, schemas = new Array(_len), _key = 0; _key < _len; _key++) {\n        schemas[_key] = arguments[_key];\n      }\n\n      Hoek.flatten(schemas).forEach(function (type, index) {\n        try {\n          type = Cast.schema(_this2._currentJoi, type);\n        } catch (castErr) {\n          if (castErr.hasOwnProperty('path')) {\n            castErr.path = index + '.' + castErr.path;\n          } else {\n            castErr.path = index;\n          }\n\n          castErr.message = castErr.message + '(' + castErr.path + ')';\n          throw castErr;\n        }\n\n        obj._inner.items.push(type);\n\n        if (type._flags.presence === 'required') {\n          obj._inner.requireds.push(type);\n        } else if (type._flags.presence === 'forbidden') {\n          obj._inner.exclusions.push(type.optional());\n        } else {\n          obj._inner.inclusions.push(type);\n        }\n      });\n      return obj;\n    }\n  }, {\n    key: \"ordered\",\n    value: function ordered() {\n      var _this3 = this;\n\n      var obj = this.clone();\n\n      for (var _len2 = arguments.length, schemas = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        schemas[_key2] = arguments[_key2];\n      }\n\n      Hoek.flatten(schemas).forEach(function (type, index) {\n        try {\n          type = Cast.schema(_this3._currentJoi, type);\n        } catch (castErr) {\n          if (castErr.hasOwnProperty('path')) {\n            castErr.path = index + '.' + castErr.path;\n          } else {\n            castErr.path = index;\n          }\n\n          castErr.message = castErr.message + '(' + castErr.path + ')';\n          throw castErr;\n        }\n\n        obj._inner.ordereds.push(type);\n      });\n      return obj;\n    }\n  }, {\n    key: \"min\",\n    value: function min(limit) {\n      var isRef = Ref.isRef(limit);\n      Hoek.assert(Number.isSafeInteger(limit) && limit >= 0 || isRef, 'limit must be a positive integer or reference');\n      return this._test('min', limit, function (value, state, options) {\n        var compareTo;\n\n        if (isRef) {\n          compareTo = limit(state.reference || state.parent, options);\n\n          if (!(Number.isSafeInteger(compareTo) && compareTo >= 0)) {\n            return this.createError('array.ref', {\n              ref: limit.key\n            }, state, options);\n          }\n        } else {\n          compareTo = limit;\n        }\n\n        if (value.length >= compareTo) {\n          return value;\n        }\n\n        return this.createError('array.min', {\n          limit: limit,\n          value: value\n        }, state, options);\n      });\n    }\n  }, {\n    key: \"max\",\n    value: function max(limit) {\n      var isRef = Ref.isRef(limit);\n      Hoek.assert(Number.isSafeInteger(limit) && limit >= 0 || isRef, 'limit must be a positive integer or reference');\n      return this._test('max', limit, function (value, state, options) {\n        var compareTo;\n\n        if (isRef) {\n          compareTo = limit(state.reference || state.parent, options);\n\n          if (!(Number.isSafeInteger(compareTo) && compareTo >= 0)) {\n            return this.createError('array.ref', {\n              ref: limit.key\n            }, state, options);\n          }\n        } else {\n          compareTo = limit;\n        }\n\n        if (value.length <= compareTo) {\n          return value;\n        }\n\n        return this.createError('array.max', {\n          limit: limit,\n          value: value\n        }, state, options);\n      });\n    }\n  }, {\n    key: \"length\",\n    value: function length(limit) {\n      var isRef = Ref.isRef(limit);\n      Hoek.assert(Number.isSafeInteger(limit) && limit >= 0 || isRef, 'limit must be a positive integer or reference');\n      return this._test('length', limit, function (value, state, options) {\n        var compareTo;\n\n        if (isRef) {\n          compareTo = limit(state.reference || state.parent, options);\n\n          if (!(Number.isSafeInteger(compareTo) && compareTo >= 0)) {\n            return this.createError('array.ref', {\n              ref: limit.key\n            }, state, options);\n          }\n        } else {\n          compareTo = limit;\n        }\n\n        if (value.length === compareTo) {\n          return value;\n        }\n\n        return this.createError('array.length', {\n          limit: limit,\n          value: value\n        }, state, options);\n      });\n    }\n  }, {\n    key: \"unique\",\n    value: function unique(comparator, configs) {\n      Hoek.assert(comparator === undefined || typeof comparator === 'function' || typeof comparator === 'string', 'comparator must be a function or a string');\n      Hoek.assert(configs === undefined || typeof configs === 'object', 'configs must be an object');\n      var settings = {\n        ignoreUndefined: configs && configs.ignoreUndefined || false\n      };\n\n      if (typeof comparator === 'string') {\n        settings.path = comparator;\n      } else if (typeof comparator === 'function') {\n        settings.comparator = comparator;\n      }\n\n      return this._test('unique', settings, function (value, state, options) {\n        var found = {\n          string: Object.create(null),\n          number: Object.create(null),\n          undefined: Object.create(null),\n          boolean: Object.create(null),\n          object: new Map(),\n          function: new Map(),\n          custom: new Map()\n        };\n        var compare = settings.comparator || Hoek.deepEqual;\n        var ignoreUndefined = settings.ignoreUndefined;\n\n        for (var i = 0; i < value.length; ++i) {\n          var item = settings.path ? Hoek.reach(value[i], settings.path) : value[i];\n          var records = settings.comparator ? found.custom : found[typeof item]; // All available types are supported, so it's not possible to reach 100% coverage without ignoring this line.\n          // I still want to keep the test for future js versions with new types (eg. Symbol).\n\n          if (\n          /* $lab:coverage:off$ */\n          records\n          /* $lab:coverage:on$ */\n          ) {\n              if (records instanceof Map) {\n                var entries = records.entries();\n                var current = void 0;\n\n                while (!(current = entries.next()).done) {\n                  if (compare(current.value[0], item)) {\n                    var localState = {\n                      key: state.key,\n                      path: state.path.concat(i),\n                      parent: state.parent,\n                      reference: state.reference\n                    };\n                    var context = {\n                      pos: i,\n                      value: value[i],\n                      dupePos: current.value[1],\n                      dupeValue: value[current.value[1]]\n                    };\n\n                    if (settings.path) {\n                      context.path = settings.path;\n                    }\n\n                    return this.createError('array.unique', context, localState, options);\n                  }\n                }\n\n                records.set(item, i);\n              } else {\n                if ((!ignoreUndefined || item !== undefined) && records[item] !== undefined) {\n                  var _localState = {\n                    key: state.key,\n                    path: state.path.concat(i),\n                    parent: state.parent,\n                    reference: state.reference\n                  };\n                  var _context = {\n                    pos: i,\n                    value: value[i],\n                    dupePos: records[item],\n                    dupeValue: value[records[item]]\n                  };\n\n                  if (settings.path) {\n                    _context.path = settings.path;\n                  }\n\n                  return this.createError('array.unique', _context, _localState, options);\n                }\n\n                records[item] = i;\n              }\n            }\n        }\n\n        return value;\n      });\n    }\n  }, {\n    key: \"sparse\",\n    value: function sparse(enabled) {\n      var value = enabled === undefined ? true : !!enabled;\n\n      if (this._flags.sparse === value) {\n        return this;\n      }\n\n      var obj = this.clone();\n      obj._flags.sparse = value;\n      return obj;\n    }\n  }, {\n    key: \"single\",\n    value: function single(enabled) {\n      var value = enabled === undefined ? true : !!enabled;\n\n      if (this._flags.single === value) {\n        return this;\n      }\n\n      var obj = this.clone();\n      obj._flags.single = value;\n      return obj;\n    }\n  }, {\n    key: \"_fillMissedErrors\",\n    value: function _fillMissedErrors(errors, requireds, state, options) {\n      var knownMisses = [];\n      var unknownMisses = 0;\n\n      for (var i = 0; i < requireds.length; ++i) {\n        var label = requireds[i]._getLabel();\n\n        if (label) {\n          knownMisses.push(label);\n        } else {\n          ++unknownMisses;\n        }\n      }\n\n      if (knownMisses.length) {\n        if (unknownMisses) {\n          errors.push(this.createError('array.includesRequiredBoth', {\n            knownMisses: knownMisses,\n            unknownMisses: unknownMisses\n          }, {\n            key: state.key,\n            path: state.path\n          }, options));\n        } else {\n          errors.push(this.createError('array.includesRequiredKnowns', {\n            knownMisses: knownMisses\n          }, {\n            key: state.key,\n            path: state.path\n          }, options));\n        }\n      } else {\n        errors.push(this.createError('array.includesRequiredUnknowns', {\n          unknownMisses: unknownMisses\n        }, {\n          key: state.key,\n          path: state.path\n        }, options));\n      }\n    }\n  }, {\n    key: \"_fillOrderedErrors\",\n    value: function _fillOrderedErrors(errors, ordereds, state, options) {\n      var requiredOrdereds = [];\n\n      for (var i = 0; i < ordereds.length; ++i) {\n        var presence = Hoek.reach(ordereds[i], '_flags.presence');\n\n        if (presence === 'required') {\n          requiredOrdereds.push(ordereds[i]);\n        }\n      }\n\n      if (requiredOrdereds.length) {\n        this._fillMissedErrors.call(this, errors, requiredOrdereds, state, options);\n      }\n    }\n  }]);\n\n  return _class;\n}(Any);\n\ninternals.safeParse = function (value, result) {\n  try {\n    var converted = JSON.parse(value);\n\n    if (Array.isArray(converted)) {\n      result.value = converted;\n    }\n  } catch (e) {}\n};\n\nmodule.exports = new internals.Array();","map":{"version":3,"sources":["/home/cloudmynds/Desktop/admin/node_modules/joi/lib/types/array/index.js"],"names":["Any","require","Cast","Ref","Hoek","internals","fastSplice","arr","i","pos","length","Array","_type","_inner","items","ordereds","inclusions","exclusions","requireds","_flags","sparse","value","state","options","result","convert","safeParse","isArray","wasArray","single","errors","createError","slice","_checkItems","call","previousErrors","errored","concat","il","item","isValid","key","path","localState","parent","reference","res","undefined","push","abortEarly","shift","j","_validate","ordered","strip","reason","limit","requiredChecks","jl","stripUnknown","arrays","inclusion","previousCheck","indexOf","_fillMissedErrors","_fillOrderedErrors","description","orderedItems","describe","obj","clone","schemas","flatten","forEach","type","index","schema","_currentJoi","castErr","hasOwnProperty","message","presence","optional","isRef","assert","Number","isSafeInteger","_test","compareTo","ref","comparator","configs","settings","ignoreUndefined","found","string","Object","create","number","boolean","object","Map","function","custom","compare","deepEqual","reach","records","entries","current","next","done","context","dupePos","dupeValue","set","enabled","knownMisses","unknownMisses","label","_getLabel","requiredOrdereds","converted","JSON","parse","e","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\n// Load modules\n\nconst Any = require('../any');\nconst Cast = require('../../cast');\nconst Ref = require('../../ref');\nconst Hoek = require('hoek');\n\n\n// Declare internals\n\nconst internals = {};\n\n\ninternals.fastSplice = function (arr, i) {\n\n    let pos = i;\n    while (pos < arr.length) {\n        arr[pos++] = arr[pos];\n    }\n\n    --arr.length;\n};\n\n\ninternals.Array = class extends Any {\n\n    constructor() {\n\n        super();\n        this._type = 'array';\n        this._inner.items = [];\n        this._inner.ordereds = [];\n        this._inner.inclusions = [];\n        this._inner.exclusions = [];\n        this._inner.requireds = [];\n        this._flags.sparse = false;\n    }\n\n    _base(value, state, options) {\n\n        const result = {\n            value\n        };\n\n        if (typeof value === 'string' &&\n            options.convert) {\n\n            internals.safeParse(value, result);\n        }\n\n        let isArray = Array.isArray(result.value);\n        const wasArray = isArray;\n        if (options.convert && this._flags.single && !isArray) {\n            result.value = [result.value];\n            isArray = true;\n        }\n\n        if (!isArray) {\n            result.errors = this.createError('array.base', null, state, options);\n            return result;\n        }\n\n        if (this._inner.inclusions.length ||\n            this._inner.exclusions.length ||\n            this._inner.requireds.length ||\n            this._inner.ordereds.length ||\n            !this._flags.sparse) {\n\n            // Clone the array so that we don't modify the original\n            if (wasArray) {\n                result.value = result.value.slice(0);\n            }\n\n            result.errors = this._checkItems.call(this, result.value, wasArray, state, options);\n\n            if (result.errors && wasArray && options.convert && this._flags.single) {\n\n                // Attempt a 2nd pass by putting the array inside one.\n                const previousErrors = result.errors;\n\n                result.value = [result.value];\n                result.errors = this._checkItems.call(this, result.value, wasArray, state, options);\n\n                if (result.errors) {\n\n                    // Restore previous errors and value since this didn't validate either.\n                    result.errors = previousErrors;\n                    result.value = result.value[0];\n                }\n            }\n        }\n\n        return result;\n    }\n\n    _checkItems(items, wasArray, state, options) {\n\n        const errors = [];\n        let errored;\n\n        const requireds = this._inner.requireds.slice();\n        const ordereds = this._inner.ordereds.slice();\n        const inclusions = this._inner.inclusions.concat(requireds);\n\n        let il = items.length;\n        for (let i = 0; i < il; ++i) {\n            errored = false;\n            const item = items[i];\n            let isValid = false;\n            const key = wasArray ? i : state.key;\n            const path = wasArray ? state.path.concat(i) : state.path;\n            const localState = { key, path, parent: state.parent, reference: state.reference };\n            let res;\n\n            // Sparse\n\n            if (!this._flags.sparse && item === undefined) {\n                errors.push(this.createError('array.sparse', null, { key: state.key, path: localState.path, pos: i }, options));\n\n                if (options.abortEarly) {\n                    return errors;\n                }\n\n                ordereds.shift();\n\n                continue;\n            }\n\n            // Exclusions\n\n            for (let j = 0; j < this._inner.exclusions.length; ++j) {\n                res = this._inner.exclusions[j]._validate(item, localState, {});                // Not passing options to use defaults\n\n                if (!res.errors) {\n                    errors.push(this.createError(wasArray ? 'array.excludes' : 'array.excludesSingle', { pos: i, value: item }, { key: state.key, path: localState.path }, options));\n                    errored = true;\n\n                    if (options.abortEarly) {\n                        return errors;\n                    }\n\n                    ordereds.shift();\n\n                    break;\n                }\n            }\n\n            if (errored) {\n                continue;\n            }\n\n            // Ordered\n            if (this._inner.ordereds.length) {\n                if (ordereds.length > 0) {\n                    const ordered = ordereds.shift();\n                    res = ordered._validate(item, localState, options);\n                    if (!res.errors) {\n                        if (ordered._flags.strip) {\n                            internals.fastSplice(items, i);\n                            --i;\n                            --il;\n                        }\n                        else if (!this._flags.sparse && res.value === undefined) {\n                            errors.push(this.createError('array.sparse', null, { key: state.key, path: localState.path, pos: i }, options));\n\n                            if (options.abortEarly) {\n                                return errors;\n                            }\n\n                            continue;\n                        }\n                        else {\n                            items[i] = res.value;\n                        }\n                    }\n                    else {\n                        errors.push(this.createError('array.ordered', { pos: i, reason: res.errors, value: item }, { key: state.key, path: localState.path }, options));\n                        if (options.abortEarly) {\n                            return errors;\n                        }\n                    }\n                    continue;\n                }\n                else if (!this._inner.items.length) {\n                    errors.push(this.createError('array.orderedLength', { pos: i, limit: this._inner.ordereds.length }, { key: state.key, path: localState.path }, options));\n                    if (options.abortEarly) {\n                        return errors;\n                    }\n                    continue;\n                }\n            }\n\n            // Requireds\n\n            const requiredChecks = [];\n            let jl = requireds.length;\n            for (let j = 0; j < jl; ++j) {\n                res = requiredChecks[j] = requireds[j]._validate(item, localState, options);\n                if (!res.errors) {\n                    items[i] = res.value;\n                    isValid = true;\n                    internals.fastSplice(requireds, j);\n                    --j;\n                    --jl;\n\n                    if (!this._flags.sparse && res.value === undefined) {\n                        errors.push(this.createError('array.sparse', null, { key: state.key, path: localState.path, pos: i }, options));\n\n                        if (options.abortEarly) {\n                            return errors;\n                        }\n                    }\n\n                    break;\n                }\n            }\n\n            if (isValid) {\n                continue;\n            }\n\n            // Inclusions\n\n            const stripUnknown = options.stripUnknown\n                ? (options.stripUnknown === true ? true : !!options.stripUnknown.arrays)\n                : false;\n\n            jl = inclusions.length;\n            for (let j = 0; j < jl; ++j) {\n                const inclusion = inclusions[j];\n\n                // Avoid re-running requireds that already didn't match in the previous loop\n                const previousCheck = requireds.indexOf(inclusion);\n                if (previousCheck !== -1) {\n                    res = requiredChecks[previousCheck];\n                }\n                else {\n                    res = inclusion._validate(item, localState, options);\n\n                    if (!res.errors) {\n                        if (inclusion._flags.strip) {\n                            internals.fastSplice(items, i);\n                            --i;\n                            --il;\n                        }\n                        else if (!this._flags.sparse && res.value === undefined) {\n                            errors.push(this.createError('array.sparse', null, { key: state.key, path: localState.path, pos: i }, options));\n                            errored = true;\n                        }\n                        else {\n                            items[i] = res.value;\n                        }\n                        isValid = true;\n                        break;\n                    }\n                }\n\n                // Return the actual error if only one inclusion defined\n                if (jl === 1) {\n                    if (stripUnknown) {\n                        internals.fastSplice(items, i);\n                        --i;\n                        --il;\n                        isValid = true;\n                        break;\n                    }\n\n                    errors.push(this.createError(wasArray ? 'array.includesOne' : 'array.includesOneSingle', { pos: i, reason: res.errors, value: item }, { key: state.key, path: localState.path }, options));\n                    errored = true;\n\n                    if (options.abortEarly) {\n                        return errors;\n                    }\n\n                    break;\n                }\n            }\n\n            if (errored) {\n                continue;\n            }\n\n            if (this._inner.inclusions.length && !isValid) {\n                if (stripUnknown) {\n                    internals.fastSplice(items, i);\n                    --i;\n                    --il;\n                    continue;\n                }\n\n                errors.push(this.createError(wasArray ? 'array.includes' : 'array.includesSingle', { pos: i, value: item }, { key: state.key, path: localState.path }, options));\n\n                if (options.abortEarly) {\n                    return errors;\n                }\n            }\n        }\n\n        if (requireds.length) {\n            this._fillMissedErrors.call(this, errors, requireds, state, options);\n        }\n\n        if (ordereds.length) {\n            this._fillOrderedErrors.call(this, errors, ordereds, state, options);\n        }\n\n        return errors.length ? errors : null;\n    }\n\n    describe() {\n\n        const description = super.describe();\n\n        if (this._inner.ordereds.length) {\n            description.orderedItems = [];\n\n            for (let i = 0; i < this._inner.ordereds.length; ++i) {\n                description.orderedItems.push(this._inner.ordereds[i].describe());\n            }\n        }\n\n        if (this._inner.items.length) {\n            description.items = [];\n\n            for (let i = 0; i < this._inner.items.length; ++i) {\n                description.items.push(this._inner.items[i].describe());\n            }\n        }\n\n        return description;\n    }\n\n    items(...schemas) {\n\n        const obj = this.clone();\n\n        Hoek.flatten(schemas).forEach((type, index) => {\n\n            try {\n                type = Cast.schema(this._currentJoi, type);\n            }\n            catch (castErr) {\n                if (castErr.hasOwnProperty('path')) {\n                    castErr.path = index + '.' + castErr.path;\n                }\n                else {\n                    castErr.path = index;\n                }\n                castErr.message = castErr.message + '(' + castErr.path + ')';\n                throw castErr;\n            }\n\n            obj._inner.items.push(type);\n\n            if (type._flags.presence === 'required') {\n                obj._inner.requireds.push(type);\n            }\n            else if (type._flags.presence === 'forbidden') {\n                obj._inner.exclusions.push(type.optional());\n            }\n            else {\n                obj._inner.inclusions.push(type);\n            }\n        });\n\n        return obj;\n    }\n\n    ordered(...schemas) {\n\n        const obj = this.clone();\n\n        Hoek.flatten(schemas).forEach((type, index) => {\n\n            try {\n                type = Cast.schema(this._currentJoi, type);\n            }\n            catch (castErr) {\n                if (castErr.hasOwnProperty('path')) {\n                    castErr.path = index + '.' + castErr.path;\n                }\n                else {\n                    castErr.path = index;\n                }\n                castErr.message = castErr.message + '(' + castErr.path + ')';\n                throw castErr;\n            }\n            obj._inner.ordereds.push(type);\n        });\n\n        return obj;\n    }\n\n    min(limit) {\n\n        const isRef = Ref.isRef(limit);\n\n        Hoek.assert((Number.isSafeInteger(limit) && limit >= 0) || isRef, 'limit must be a positive integer or reference');\n\n        return this._test('min', limit, function (value, state, options) {\n\n            let compareTo;\n            if (isRef) {\n                compareTo = limit(state.reference || state.parent, options);\n\n                if (!(Number.isSafeInteger(compareTo) && compareTo >= 0)) {\n                    return this.createError('array.ref', { ref: limit.key }, state, options);\n                }\n            }\n            else {\n                compareTo = limit;\n            }\n\n            if (value.length >= compareTo) {\n                return value;\n            }\n\n            return this.createError('array.min', { limit, value }, state, options);\n        });\n    }\n\n    max(limit) {\n\n        const isRef = Ref.isRef(limit);\n\n        Hoek.assert((Number.isSafeInteger(limit) && limit >= 0) || isRef, 'limit must be a positive integer or reference');\n\n        return this._test('max', limit, function (value, state, options) {\n\n            let compareTo;\n            if (isRef) {\n                compareTo = limit(state.reference || state.parent, options);\n\n                if (!(Number.isSafeInteger(compareTo) && compareTo >= 0)) {\n                    return this.createError('array.ref', { ref: limit.key }, state, options);\n                }\n            }\n            else {\n                compareTo = limit;\n            }\n\n            if (value.length <= compareTo) {\n                return value;\n            }\n\n            return this.createError('array.max', { limit, value }, state, options);\n        });\n    }\n\n    length(limit) {\n\n        const isRef = Ref.isRef(limit);\n\n        Hoek.assert((Number.isSafeInteger(limit) && limit >= 0) || isRef, 'limit must be a positive integer or reference');\n\n        return this._test('length', limit, function (value, state, options) {\n\n            let compareTo;\n            if (isRef) {\n                compareTo = limit(state.reference || state.parent, options);\n\n                if (!(Number.isSafeInteger(compareTo) && compareTo >= 0)) {\n                    return this.createError('array.ref', { ref: limit.key }, state, options);\n                }\n            }\n            else {\n                compareTo = limit;\n            }\n\n            if (value.length === compareTo) {\n                return value;\n            }\n\n            return this.createError('array.length', { limit, value }, state, options);\n        });\n    }\n\n    unique(comparator, configs) {\n\n        Hoek.assert(comparator === undefined ||\n            typeof comparator === 'function' ||\n            typeof comparator === 'string', 'comparator must be a function or a string');\n\n        Hoek.assert(configs === undefined ||\n            typeof configs === 'object', 'configs must be an object');\n\n        const settings = {\n            ignoreUndefined: (configs && configs.ignoreUndefined) || false\n        };\n\n\n        if (typeof comparator === 'string') {\n            settings.path = comparator;\n        }\n        else if (typeof comparator === 'function') {\n            settings.comparator = comparator;\n        }\n\n        return this._test('unique', settings, function (value, state, options) {\n\n            const found = {\n                string: Object.create(null),\n                number: Object.create(null),\n                undefined: Object.create(null),\n                boolean: Object.create(null),\n                object: new Map(),\n                function: new Map(),\n                custom: new Map()\n            };\n\n            const compare = settings.comparator || Hoek.deepEqual;\n            const ignoreUndefined = settings.ignoreUndefined;\n\n            for (let i = 0; i < value.length; ++i) {\n                const item = settings.path ? Hoek.reach(value[i], settings.path) : value[i];\n                const records = settings.comparator ? found.custom : found[typeof item];\n\n                // All available types are supported, so it's not possible to reach 100% coverage without ignoring this line.\n                // I still want to keep the test for future js versions with new types (eg. Symbol).\n                if (/* $lab:coverage:off$ */ records /* $lab:coverage:on$ */) {\n                    if (records instanceof Map) {\n                        const entries = records.entries();\n                        let current;\n                        while (!(current = entries.next()).done) {\n                            if (compare(current.value[0], item)) {\n                                const localState = {\n                                    key: state.key,\n                                    path: state.path.concat(i),\n                                    parent: state.parent,\n                                    reference: state.reference\n                                };\n\n                                const context = {\n                                    pos: i,\n                                    value: value[i],\n                                    dupePos: current.value[1],\n                                    dupeValue: value[current.value[1]]\n                                };\n\n                                if (settings.path) {\n                                    context.path = settings.path;\n                                }\n\n                                return this.createError('array.unique', context, localState, options);\n                            }\n                        }\n\n                        records.set(item, i);\n                    }\n                    else {\n                        if ((!ignoreUndefined || item !== undefined) && records[item] !== undefined) {\n                            const localState = {\n                                key: state.key,\n                                path: state.path.concat(i),\n                                parent: state.parent,\n                                reference: state.reference\n                            };\n\n                            const context = {\n                                pos: i,\n                                value: value[i],\n                                dupePos: records[item],\n                                dupeValue: value[records[item]]\n                            };\n\n                            if (settings.path) {\n                                context.path = settings.path;\n                            }\n\n                            return this.createError('array.unique', context, localState, options);\n                        }\n\n                        records[item] = i;\n                    }\n                }\n            }\n\n            return value;\n        });\n    }\n\n    sparse(enabled) {\n\n        const value = enabled === undefined ? true : !!enabled;\n\n        if (this._flags.sparse === value) {\n            return this;\n        }\n\n        const obj = this.clone();\n        obj._flags.sparse = value;\n        return obj;\n    }\n\n    single(enabled) {\n\n        const value = enabled === undefined ? true : !!enabled;\n\n        if (this._flags.single === value) {\n            return this;\n        }\n\n        const obj = this.clone();\n        obj._flags.single = value;\n        return obj;\n    }\n\n    _fillMissedErrors(errors, requireds, state, options) {\n\n        const knownMisses = [];\n        let unknownMisses = 0;\n        for (let i = 0; i < requireds.length; ++i) {\n            const label = requireds[i]._getLabel();\n            if (label) {\n                knownMisses.push(label);\n            }\n            else {\n                ++unknownMisses;\n            }\n        }\n\n        if (knownMisses.length) {\n            if (unknownMisses) {\n                errors.push(this.createError('array.includesRequiredBoth', { knownMisses, unknownMisses }, { key: state.key, path: state.path }, options));\n            }\n            else {\n                errors.push(this.createError('array.includesRequiredKnowns', { knownMisses }, { key: state.key, path: state.path }, options));\n            }\n        }\n        else {\n            errors.push(this.createError('array.includesRequiredUnknowns', { unknownMisses }, { key: state.key, path: state.path }, options));\n        }\n    }\n\n\n    _fillOrderedErrors(errors, ordereds, state, options) {\n\n        const requiredOrdereds = [];\n\n        for (let i = 0; i < ordereds.length; ++i) {\n            const presence = Hoek.reach(ordereds[i], '_flags.presence');\n            if (presence === 'required') {\n                requiredOrdereds.push(ordereds[i]);\n            }\n        }\n\n        if (requiredOrdereds.length) {\n            this._fillMissedErrors.call(this, errors, requiredOrdereds, state, options);\n        }\n    }\n\n};\n\n\ninternals.safeParse = function (value, result) {\n\n    try {\n        const converted = JSON.parse(value);\n        if (Array.isArray(converted)) {\n            result.value = converted;\n        }\n    }\n    catch (e) { }\n};\n\n\nmodule.exports = new internals.Array();\n"]},"metadata":{},"sourceType":"script"}