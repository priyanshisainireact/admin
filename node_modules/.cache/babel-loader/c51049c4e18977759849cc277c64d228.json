{"ast":null,"code":"'use strict'; // Load modules\n\nvar Crypto = require('crypto');\n\nvar Path = require('path');\n\nvar Util = require('util');\n\nvar Escape = require('./escape'); // Declare internals\n\n\nvar internals = {}; // Clone object or array\n\nexports.clone = function (obj, seen) {\n  if (typeof obj !== 'object' || obj === null) {\n    return obj;\n  }\n\n  seen = seen || new Map();\n  var lookup = seen.get(obj);\n\n  if (lookup) {\n    return lookup;\n  }\n\n  var newObj;\n  var cloneDeep = false;\n\n  if (!Array.isArray(obj)) {\n    if (Buffer.isBuffer(obj)) {\n      newObj = new Buffer(obj);\n    } else if (obj instanceof Date) {\n      newObj = new Date(obj.getTime());\n    } else if (obj instanceof RegExp) {\n      newObj = new RegExp(obj);\n    } else {\n      var proto = Object.getPrototypeOf(obj);\n\n      if (proto && proto.isImmutable) {\n        newObj = obj;\n      } else {\n        newObj = Object.create(proto);\n        cloneDeep = true;\n      }\n    }\n  } else {\n    newObj = [];\n    cloneDeep = true;\n  }\n\n  seen.set(obj, newObj);\n\n  if (cloneDeep) {\n    var keys = Object.getOwnPropertyNames(obj);\n\n    for (var i = 0; i < keys.length; ++i) {\n      var key = keys[i];\n      var descriptor = Object.getOwnPropertyDescriptor(obj, key);\n\n      if (descriptor && (descriptor.get || descriptor.set)) {\n        Object.defineProperty(newObj, key, descriptor);\n      } else {\n        newObj[key] = exports.clone(obj[key], seen);\n      }\n    }\n  }\n\n  return newObj;\n}; // Merge all the properties of source into target, source wins in conflict, and by default null and undefined from source are applied\n\n/*eslint-disable */\n\n\nexports.merge = function (target, source, isNullOverride\n/* = true */\n, isMergeArrays\n/* = true */\n) {\n  /*eslint-enable */\n  exports.assert(target && typeof target === 'object', 'Invalid target value: must be an object');\n  exports.assert(source === null || source === undefined || typeof source === 'object', 'Invalid source value: must be null, undefined, or an object');\n\n  if (!source) {\n    return target;\n  }\n\n  if (Array.isArray(source)) {\n    exports.assert(Array.isArray(target), 'Cannot merge array onto an object');\n\n    if (isMergeArrays === false) {\n      // isMergeArrays defaults to true\n      target.length = 0; // Must not change target assignment\n    }\n\n    for (var i = 0; i < source.length; ++i) {\n      target.push(exports.clone(source[i]));\n    }\n\n    return target;\n  }\n\n  var keys = Object.keys(source);\n\n  for (var _i = 0; _i < keys.length; ++_i) {\n    var key = keys[_i];\n\n    if (key === '__proto__') {\n      continue;\n    }\n\n    var value = source[key];\n\n    if (value && typeof value === 'object') {\n      if (!target[key] || typeof target[key] !== 'object' || Array.isArray(target[key]) !== Array.isArray(value) || value instanceof Date || Buffer.isBuffer(value) || value instanceof RegExp) {\n        target[key] = exports.clone(value);\n      } else {\n        exports.merge(target[key], value, isNullOverride, isMergeArrays);\n      }\n    } else {\n      if (value !== null && value !== undefined) {\n        // Explicit to preserve empty strings\n        target[key] = value;\n      } else if (isNullOverride !== false) {\n        // Defaults to true\n        target[key] = value;\n      }\n    }\n  }\n\n  return target;\n}; // Apply options to a copy of the defaults\n\n\nexports.applyToDefaults = function (defaults, options, isNullOverride) {\n  exports.assert(defaults && typeof defaults === 'object', 'Invalid defaults value: must be an object');\n  exports.assert(!options || options === true || typeof options === 'object', 'Invalid options value: must be true, falsy or an object');\n\n  if (!options) {\n    // If no options, return null\n    return null;\n  }\n\n  var copy = exports.clone(defaults);\n\n  if (options === true) {\n    // If options is set to true, use defaults\n    return copy;\n  }\n\n  return exports.merge(copy, options, isNullOverride === true, false);\n}; // Clone an object except for the listed keys which are shallow copied\n\n\nexports.cloneWithShallow = function (source, keys) {\n  if (!source || typeof source !== 'object') {\n    return source;\n  }\n\n  var storage = internals.store(source, keys); // Move shallow copy items to storage\n\n  var copy = exports.clone(source); // Deep copy the rest\n\n  internals.restore(copy, source, storage); // Shallow copy the stored items and restore\n\n  return copy;\n};\n\ninternals.store = function (source, keys) {\n  var storage = {};\n\n  for (var i = 0; i < keys.length; ++i) {\n    var key = keys[i];\n    var value = exports.reach(source, key);\n\n    if (value !== undefined) {\n      storage[key] = value;\n      internals.reachSet(source, key, undefined);\n    }\n  }\n\n  return storage;\n};\n\ninternals.restore = function (copy, source, storage) {\n  var keys = Object.keys(storage);\n\n  for (var i = 0; i < keys.length; ++i) {\n    var key = keys[i];\n    internals.reachSet(copy, key, storage[key]);\n    internals.reachSet(source, key, storage[key]);\n  }\n};\n\ninternals.reachSet = function (obj, key, value) {\n  var path = key.split('.');\n  var ref = obj;\n\n  for (var i = 0; i < path.length; ++i) {\n    var segment = path[i];\n\n    if (i + 1 === path.length) {\n      ref[segment] = value;\n    }\n\n    ref = ref[segment];\n  }\n}; // Apply options to defaults except for the listed keys which are shallow copied from option without merging\n\n\nexports.applyToDefaultsWithShallow = function (defaults, options, keys) {\n  exports.assert(defaults && typeof defaults === 'object', 'Invalid defaults value: must be an object');\n  exports.assert(!options || options === true || typeof options === 'object', 'Invalid options value: must be true, falsy or an object');\n  exports.assert(keys && Array.isArray(keys), 'Invalid keys');\n\n  if (!options) {\n    // If no options, return null\n    return null;\n  }\n\n  var copy = exports.cloneWithShallow(defaults, keys);\n\n  if (options === true) {\n    // If options is set to true, use defaults\n    return copy;\n  }\n\n  var storage = internals.store(options, keys); // Move shallow copy items to storage\n\n  exports.merge(copy, options, false, false); // Deep copy the rest\n\n  internals.restore(copy, options, storage); // Shallow copy the stored items and restore\n\n  return copy;\n}; // Deep object or array comparison\n\n\nexports.deepEqual = function (obj, ref, options, seen) {\n  options = options || {\n    prototype: true\n  };\n  var type = typeof obj;\n\n  if (type !== typeof ref) {\n    return false;\n  }\n\n  if (type !== 'object' || obj === null || ref === null) {\n    if (obj === ref) {\n      // Copied from Deep-eql, copyright(c) 2013 Jake Luer, jake@alogicalparadox.com, MIT Licensed, https://github.com/chaijs/deep-eql\n      return obj !== 0 || 1 / obj === 1 / ref; // -0 / +0\n    }\n\n    return obj !== obj && ref !== ref; // NaN\n  }\n\n  seen = seen || [];\n\n  if (seen.indexOf(obj) !== -1) {\n    return true; // If previous comparison failed, it would have stopped execution\n  }\n\n  seen.push(obj);\n\n  if (Array.isArray(obj)) {\n    if (!Array.isArray(ref)) {\n      return false;\n    }\n\n    if (!options.part && obj.length !== ref.length) {\n      return false;\n    }\n\n    for (var i = 0; i < obj.length; ++i) {\n      if (options.part) {\n        var found = false;\n\n        for (var j = 0; j < ref.length; ++j) {\n          if (exports.deepEqual(obj[i], ref[j], options)) {\n            found = true;\n            break;\n          }\n        }\n\n        return found;\n      }\n\n      if (!exports.deepEqual(obj[i], ref[i], options)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  if (Buffer.isBuffer(obj)) {\n    if (!Buffer.isBuffer(ref)) {\n      return false;\n    }\n\n    if (obj.length !== ref.length) {\n      return false;\n    }\n\n    for (var _i2 = 0; _i2 < obj.length; ++_i2) {\n      if (obj[_i2] !== ref[_i2]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  if (obj instanceof Date) {\n    return ref instanceof Date && obj.getTime() === ref.getTime();\n  }\n\n  if (obj instanceof RegExp) {\n    return ref instanceof RegExp && obj.toString() === ref.toString();\n  }\n\n  if (options.prototype) {\n    if (Object.getPrototypeOf(obj) !== Object.getPrototypeOf(ref)) {\n      return false;\n    }\n  }\n\n  var keys = Object.getOwnPropertyNames(obj);\n\n  if (!options.part && keys.length !== Object.getOwnPropertyNames(ref).length) {\n    return false;\n  }\n\n  for (var _i3 = 0; _i3 < keys.length; ++_i3) {\n    var key = keys[_i3];\n    var descriptor = Object.getOwnPropertyDescriptor(obj, key);\n\n    if (descriptor.get) {\n      if (!exports.deepEqual(descriptor, Object.getOwnPropertyDescriptor(ref, key), options, seen)) {\n        return false;\n      }\n    } else if (!exports.deepEqual(obj[key], ref[key], options, seen)) {\n      return false;\n    }\n  }\n\n  return true;\n}; // Remove duplicate items from array\n\n\nexports.unique = function (array, key) {\n  var result;\n\n  if (key) {\n    result = [];\n    var index = new Set();\n    array.forEach(function (item) {\n      var identifier = item[key];\n\n      if (!index.has(identifier)) {\n        index.add(identifier);\n        result.push(item);\n      }\n    });\n  } else {\n    result = Array.from(new Set(array));\n  }\n\n  return result;\n}; // Convert array into object\n\n\nexports.mapToObject = function (array, key) {\n  if (!array) {\n    return null;\n  }\n\n  var obj = {};\n\n  for (var i = 0; i < array.length; ++i) {\n    if (key) {\n      if (array[i][key]) {\n        obj[array[i][key]] = true;\n      }\n    } else {\n      obj[array[i]] = true;\n    }\n  }\n\n  return obj;\n}; // Find the common unique items in two arrays\n\n\nexports.intersect = function (array1, array2, justFirst) {\n  if (!array1 || !array2) {\n    return [];\n  }\n\n  var common = [];\n  var hash = Array.isArray(array1) ? exports.mapToObject(array1) : array1;\n  var found = {};\n\n  for (var i = 0; i < array2.length; ++i) {\n    if (hash[array2[i]] && !found[array2[i]]) {\n      if (justFirst) {\n        return array2[i];\n      }\n\n      common.push(array2[i]);\n      found[array2[i]] = true;\n    }\n  }\n\n  return justFirst ? null : common;\n}; // Test if the reference contains the values\n\n\nexports.contain = function (ref, values, options) {\n  /*\n      string -> string(s)\n      array -> item(s)\n      object -> key(s)\n      object -> object (key:value)\n  */\n  var valuePairs = null;\n\n  if (typeof ref === 'object' && typeof values === 'object' && !Array.isArray(ref) && !Array.isArray(values)) {\n    valuePairs = values;\n    values = Object.keys(values);\n  } else {\n    values = [].concat(values);\n  }\n\n  options = options || {}; // deep, once, only, part\n\n  exports.assert(arguments.length >= 2, 'Insufficient arguments');\n  exports.assert(typeof ref === 'string' || typeof ref === 'object', 'Reference must be string or an object');\n  exports.assert(values.length, 'Values array cannot be empty');\n  var compare;\n  var compareFlags;\n\n  if (options.deep) {\n    compare = exports.deepEqual;\n    var hasOnly = options.hasOwnProperty('only');\n    var hasPart = options.hasOwnProperty('part');\n    compareFlags = {\n      prototype: hasOnly ? options.only : hasPart ? !options.part : false,\n      part: hasOnly ? !options.only : hasPart ? options.part : true\n    };\n  } else {\n    compare = function compare(a, b) {\n      return a === b;\n    };\n  }\n\n  var misses = false;\n  var matches = new Array(values.length);\n\n  for (var i = 0; i < matches.length; ++i) {\n    matches[i] = 0;\n  }\n\n  if (typeof ref === 'string') {\n    var pattern = '(';\n\n    for (var _i4 = 0; _i4 < values.length; ++_i4) {\n      var value = values[_i4];\n      exports.assert(typeof value === 'string', 'Cannot compare string reference to non-string value');\n      pattern += (_i4 ? '|' : '') + exports.escapeRegex(value);\n    }\n\n    var regex = new RegExp(pattern + ')', 'g');\n    var leftovers = ref.replace(regex, function ($0, $1) {\n      var index = values.indexOf($1);\n      ++matches[index];\n      return ''; // Remove from string\n    });\n    misses = !!leftovers;\n  } else if (Array.isArray(ref)) {\n    for (var _i5 = 0; _i5 < ref.length; ++_i5) {\n      var matched = false;\n\n      for (var j = 0; j < values.length && matched === false; ++j) {\n        matched = compare(values[j], ref[_i5], compareFlags) && j;\n      }\n\n      if (matched !== false) {\n        ++matches[matched];\n      } else {\n        misses = true;\n      }\n    }\n  } else {\n    var keys = Object.getOwnPropertyNames(ref);\n\n    for (var _i6 = 0; _i6 < keys.length; ++_i6) {\n      var key = keys[_i6];\n      var pos = values.indexOf(key);\n\n      if (pos !== -1) {\n        if (valuePairs && !compare(valuePairs[key], ref[key], compareFlags)) {\n          return false;\n        }\n\n        ++matches[pos];\n      } else {\n        misses = true;\n      }\n    }\n  }\n\n  var result = false;\n\n  for (var _i7 = 0; _i7 < matches.length; ++_i7) {\n    result = result || !!matches[_i7];\n\n    if (options.once && matches[_i7] > 1 || !options.part && !matches[_i7]) {\n      return false;\n    }\n  }\n\n  if (options.only && misses) {\n    return false;\n  }\n\n  return result;\n}; // Flatten array\n\n\nexports.flatten = function (array, target) {\n  var result = target || [];\n\n  for (var i = 0; i < array.length; ++i) {\n    if (Array.isArray(array[i])) {\n      exports.flatten(array[i], result);\n    } else {\n      result.push(array[i]);\n    }\n  }\n\n  return result;\n}; // Convert an object key chain string ('a.b.c') to reference (object[a][b][c])\n\n\nexports.reach = function (obj, chain, options) {\n  if (chain === false || chain === null || typeof chain === 'undefined') {\n    return obj;\n  }\n\n  options = options || {};\n\n  if (typeof options === 'string') {\n    options = {\n      separator: options\n    };\n  }\n\n  var path = chain.split(options.separator || '.');\n  var ref = obj;\n\n  for (var i = 0; i < path.length; ++i) {\n    var key = path[i];\n\n    if (key[0] === '-' && Array.isArray(ref)) {\n      key = key.slice(1, key.length);\n      key = ref.length - key;\n    }\n\n    if (!ref || !((typeof ref === 'object' || typeof ref === 'function') && key in ref) || typeof ref !== 'object' && options.functions === false) {\n      // Only object and function can have properties\n      exports.assert(!options.strict || i + 1 === path.length, 'Missing segment', key, 'in reach path ', chain);\n      exports.assert(typeof ref === 'object' || options.functions === true || typeof ref !== 'function', 'Invalid segment', key, 'in reach path ', chain);\n      ref = options.default;\n      break;\n    }\n\n    ref = ref[key];\n  }\n\n  return ref;\n};\n\nexports.reachTemplate = function (obj, template, options) {\n  return template.replace(/{([^}]+)}/g, function ($0, chain) {\n    var value = exports.reach(obj, chain, options);\n    return value === undefined || value === null ? '' : value;\n  });\n};\n\nexports.formatStack = function (stack) {\n  var trace = [];\n\n  for (var i = 0; i < stack.length; ++i) {\n    var item = stack[i];\n    trace.push([item.getFileName(), item.getLineNumber(), item.getColumnNumber(), item.getFunctionName(), item.isConstructor()]);\n  }\n\n  return trace;\n};\n\nexports.formatTrace = function (trace) {\n  var display = [];\n\n  for (var i = 0; i < trace.length; ++i) {\n    var row = trace[i];\n    display.push((row[4] ? 'new ' : '') + row[3] + ' (' + row[0] + ':' + row[1] + ':' + row[2] + ')');\n  }\n\n  return display;\n};\n\nexports.callStack = function (slice) {\n  // http://code.google.com/p/v8/wiki/JavaScriptStackTraceApi\n  var v8 = Error.prepareStackTrace;\n\n  Error.prepareStackTrace = function (_, stack) {\n    return stack;\n  };\n\n  var capture = {};\n  Error.captureStackTrace(capture, this); // arguments.callee is not supported in strict mode so we use this and slice the trace of this off the result\n\n  var stack = capture.stack;\n  Error.prepareStackTrace = v8;\n  var trace = exports.formatStack(stack);\n  return trace.slice(1 + slice);\n};\n\nexports.displayStack = function (slice) {\n  var trace = exports.callStack(slice === undefined ? 1 : slice + 1);\n  return exports.formatTrace(trace);\n};\n\nexports.abortThrow = false;\n\nexports.abort = function (message, hideStack) {\n  if (process.env.NODE_ENV === 'test' || exports.abortThrow === true) {\n    throw new Error(message || 'Unknown error');\n  }\n\n  var stack = '';\n\n  if (!hideStack) {\n    stack = exports.displayStack(1).join('\\n\\t');\n  }\n\n  console.log('ABORT: ' + message + '\\n\\t' + stack);\n  process.exit(1);\n};\n\nexports.assert = function (condition\n/*, msg1, msg2, msg3 */\n) {\n  if (condition) {\n    return;\n  }\n\n  if (arguments.length === 2 && arguments[1] instanceof Error) {\n    throw arguments[1];\n  }\n\n  var msgs = [];\n\n  for (var i = 1; i < arguments.length; ++i) {\n    if (arguments[i] !== '') {\n      msgs.push(arguments[i]); // Avoids Array.slice arguments leak, allowing for V8 optimizations\n    }\n  }\n\n  msgs = msgs.map(function (msg) {\n    return typeof msg === 'string' ? msg : msg instanceof Error ? msg.message : exports.stringify(msg);\n  });\n  throw new Error(msgs.join(' ') || 'Unknown error');\n};\n\nexports.Timer = function () {\n  this.ts = 0;\n  this.reset();\n};\n\nexports.Timer.prototype.reset = function () {\n  this.ts = Date.now();\n};\n\nexports.Timer.prototype.elapsed = function () {\n  return Date.now() - this.ts;\n};\n\nexports.Bench = function () {\n  this.ts = 0;\n  this.reset();\n};\n\nexports.Bench.prototype.reset = function () {\n  this.ts = exports.Bench.now();\n};\n\nexports.Bench.prototype.elapsed = function () {\n  return exports.Bench.now() - this.ts;\n};\n\nexports.Bench.now = function () {\n  var ts = process.hrtime();\n  return ts[0] * 1e3 + ts[1] / 1e6;\n}; // Escape string for Regex construction\n\n\nexports.escapeRegex = function (string) {\n  // Escape ^$.*+-?=!:|\\/()[]{},\n  return string.replace(/[\\^\\$\\.\\*\\+\\-\\?\\=\\!\\:\\|\\\\\\/\\(\\)\\[\\]\\{\\}\\,]/g, '\\\\$&');\n}; // Base64url (RFC 4648) encode\n\n\nexports.base64urlEncode = function (value, encoding) {\n  exports.assert(typeof value === 'string' || Buffer.isBuffer(value), 'value must be string or buffer');\n  var buf = Buffer.isBuffer(value) ? value : new Buffer(value, encoding || 'binary');\n  return buf.toString('base64').replace(/\\+/g, '-').replace(/\\//g, '_').replace(/\\=/g, '');\n}; // Base64url (RFC 4648) decode\n\n\nexports.base64urlDecode = function (value, encoding) {\n  if (typeof value !== 'string') {\n    return new Error('Value not a string');\n  }\n\n  if (!/^[\\w\\-]*$/.test(value)) {\n    return new Error('Invalid character');\n  }\n\n  var buf = new Buffer(value, 'base64');\n  return encoding === 'buffer' ? buf : buf.toString(encoding || 'binary');\n}; // Escape attribute value for use in HTTP header\n\n\nexports.escapeHeaderAttribute = function (attribute) {\n  // Allowed value characters: !#$%&'()*+,-./:;<=>?@[]^_`{|}~ and space, a-z, A-Z, 0-9, \\, \"\n  exports.assert(/^[ \\w\\!#\\$%&'\\(\\)\\*\\+,\\-\\.\\/\\:;<\\=>\\?@\\[\\]\\^`\\{\\|\\}~\\\"\\\\]*$/.test(attribute), 'Bad attribute value (' + attribute + ')');\n  return attribute.replace(/\\\\/g, '\\\\\\\\').replace(/\\\"/g, '\\\\\"'); // Escape quotes and slash\n};\n\nexports.escapeHtml = function (string) {\n  return Escape.escapeHtml(string);\n};\n\nexports.escapeJavaScript = function (string) {\n  return Escape.escapeJavaScript(string);\n};\n\nexports.escapeJson = function (string) {\n  return Escape.escapeJson(string);\n};\n\nexports.nextTick = function (callback) {\n  return function () {\n    var args = arguments;\n    process.nextTick(function () {\n      callback.apply(null, args);\n    });\n  };\n};\n\nexports.once = function (method) {\n  if (method._hoekOnce) {\n    return method;\n  }\n\n  var once = false;\n\n  var wrapped = function wrapped() {\n    if (!once) {\n      once = true;\n      method.apply(null, arguments);\n    }\n  };\n\n  wrapped._hoekOnce = true;\n  return wrapped;\n};\n\nexports.isInteger = Number.isSafeInteger;\n\nexports.ignore = function () {};\n\nexports.inherits = Util.inherits;\nexports.format = Util.format;\n\nexports.transform = function (source, transform, options) {\n  exports.assert(source === null || source === undefined || typeof source === 'object' || Array.isArray(source), 'Invalid source object: must be null, undefined, an object, or an array');\n  var separator = typeof options === 'object' && options !== null ? options.separator || '.' : '.';\n\n  if (Array.isArray(source)) {\n    var results = [];\n\n    for (var i = 0; i < source.length; ++i) {\n      results.push(exports.transform(source[i], transform, options));\n    }\n\n    return results;\n  }\n\n  var result = {};\n  var keys = Object.keys(transform);\n\n  for (var _i8 = 0; _i8 < keys.length; ++_i8) {\n    var key = keys[_i8];\n    var path = key.split(separator);\n    var sourcePath = transform[key];\n    exports.assert(typeof sourcePath === 'string', 'All mappings must be \".\" delineated strings');\n    var segment = void 0;\n    var res = result;\n\n    while (path.length > 1) {\n      segment = path.shift();\n\n      if (!res[segment]) {\n        res[segment] = {};\n      }\n\n      res = res[segment];\n    }\n\n    segment = path.shift();\n    res[segment] = exports.reach(source, sourcePath, options);\n  }\n\n  return result;\n};\n\nexports.uniqueFilename = function (path, extension) {\n  if (extension) {\n    extension = extension[0] !== '.' ? '.' + extension : extension;\n  } else {\n    extension = '';\n  }\n\n  path = Path.resolve(path);\n  var name = [Date.now(), process.pid, Crypto.randomBytes(8).toString('hex')].join('-') + extension;\n  return Path.join(path, name);\n};\n\nexports.stringify = function () {\n  try {\n    return JSON.stringify.apply(null, arguments);\n  } catch (err) {\n    return '[Cannot display object: ' + err.message + ']';\n  }\n};\n\nexports.shallow = function (source) {\n  var target = {};\n  var keys = Object.keys(source);\n\n  for (var i = 0; i < keys.length; ++i) {\n    var key = keys[i];\n    target[key] = source[key];\n  }\n\n  return target;\n};","map":{"version":3,"sources":["/home/cloudmynds/Desktop/admin/node_modules/hoek/lib/index.js"],"names":["Crypto","require","Path","Util","Escape","internals","exports","clone","obj","seen","Map","lookup","get","newObj","cloneDeep","Array","isArray","Buffer","isBuffer","Date","getTime","RegExp","proto","Object","getPrototypeOf","isImmutable","create","set","keys","getOwnPropertyNames","i","length","key","descriptor","getOwnPropertyDescriptor","defineProperty","merge","target","source","isNullOverride","isMergeArrays","assert","undefined","push","value","applyToDefaults","defaults","options","copy","cloneWithShallow","storage","store","restore","reach","reachSet","path","split","ref","segment","applyToDefaultsWithShallow","deepEqual","prototype","type","indexOf","part","found","j","toString","unique","array","result","index","Set","forEach","item","identifier","has","add","from","mapToObject","intersect","array1","array2","justFirst","common","hash","contain","values","valuePairs","concat","arguments","compare","compareFlags","deep","hasOnly","hasOwnProperty","hasPart","only","a","b","misses","matches","pattern","escapeRegex","regex","leftovers","replace","$0","$1","matched","pos","once","flatten","chain","separator","slice","functions","strict","default","reachTemplate","template","formatStack","stack","trace","getFileName","getLineNumber","getColumnNumber","getFunctionName","isConstructor","formatTrace","display","row","callStack","v8","Error","prepareStackTrace","_","capture","captureStackTrace","displayStack","abortThrow","abort","message","hideStack","process","env","NODE_ENV","join","console","log","exit","condition","msgs","map","msg","stringify","Timer","ts","reset","now","elapsed","Bench","hrtime","string","base64urlEncode","encoding","buf","base64urlDecode","test","escapeHeaderAttribute","attribute","escapeHtml","escapeJavaScript","escapeJson","nextTick","callback","args","apply","method","_hoekOnce","wrapped","isInteger","Number","isSafeInteger","ignore","inherits","format","transform","results","sourcePath","res","shift","uniqueFilename","extension","resolve","name","pid","randomBytes","JSON","err","shallow"],"mappings":"AAAA,a,CAEA;;AAEA,IAAMA,MAAM,GAAGC,OAAO,CAAC,QAAD,CAAtB;;AACA,IAAMC,IAAI,GAAGD,OAAO,CAAC,MAAD,CAApB;;AACA,IAAME,IAAI,GAAGF,OAAO,CAAC,MAAD,CAApB;;AACA,IAAMG,MAAM,GAAGH,OAAO,CAAC,UAAD,CAAtB,C,CAGA;;;AAEA,IAAMI,SAAS,GAAG,EAAlB,C,CAGA;;AAEAC,OAAO,CAACC,KAAR,GAAgB,UAAUC,GAAV,EAAeC,IAAf,EAAqB;AAEjC,MAAI,OAAOD,GAAP,KAAe,QAAf,IACAA,GAAG,KAAK,IADZ,EACkB;AAEd,WAAOA,GAAP;AACH;;AAEDC,EAAAA,IAAI,GAAGA,IAAI,IAAI,IAAIC,GAAJ,EAAf;AAEA,MAAMC,MAAM,GAAGF,IAAI,CAACG,GAAL,CAASJ,GAAT,CAAf;;AACA,MAAIG,MAAJ,EAAY;AACR,WAAOA,MAAP;AACH;;AAED,MAAIE,MAAJ;AACA,MAAIC,SAAS,GAAG,KAAhB;;AAEA,MAAI,CAACC,KAAK,CAACC,OAAN,CAAcR,GAAd,CAAL,EAAyB;AACrB,QAAIS,MAAM,CAACC,QAAP,CAAgBV,GAAhB,CAAJ,EAA0B;AACtBK,MAAAA,MAAM,GAAG,IAAII,MAAJ,CAAWT,GAAX,CAAT;AACH,KAFD,MAGK,IAAIA,GAAG,YAAYW,IAAnB,EAAyB;AAC1BN,MAAAA,MAAM,GAAG,IAAIM,IAAJ,CAASX,GAAG,CAACY,OAAJ,EAAT,CAAT;AACH,KAFI,MAGA,IAAIZ,GAAG,YAAYa,MAAnB,EAA2B;AAC5BR,MAAAA,MAAM,GAAG,IAAIQ,MAAJ,CAAWb,GAAX,CAAT;AACH,KAFI,MAGA;AACD,UAAMc,KAAK,GAAGC,MAAM,CAACC,cAAP,CAAsBhB,GAAtB,CAAd;;AACA,UAAIc,KAAK,IACLA,KAAK,CAACG,WADV,EACuB;AAEnBZ,QAAAA,MAAM,GAAGL,GAAT;AACH,OAJD,MAKK;AACDK,QAAAA,MAAM,GAAGU,MAAM,CAACG,MAAP,CAAcJ,KAAd,CAAT;AACAR,QAAAA,SAAS,GAAG,IAAZ;AACH;AACJ;AACJ,GAtBD,MAuBK;AACDD,IAAAA,MAAM,GAAG,EAAT;AACAC,IAAAA,SAAS,GAAG,IAAZ;AACH;;AAEDL,EAAAA,IAAI,CAACkB,GAAL,CAASnB,GAAT,EAAcK,MAAd;;AAEA,MAAIC,SAAJ,EAAe;AACX,QAAMc,IAAI,GAAGL,MAAM,CAACM,mBAAP,CAA2BrB,GAA3B,CAAb;;AACA,SAAK,IAAIsB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,IAAI,CAACG,MAAzB,EAAiC,EAAED,CAAnC,EAAsC;AAClC,UAAME,GAAG,GAAGJ,IAAI,CAACE,CAAD,CAAhB;AACA,UAAMG,UAAU,GAAGV,MAAM,CAACW,wBAAP,CAAgC1B,GAAhC,EAAqCwB,GAArC,CAAnB;;AACA,UAAIC,UAAU,KACTA,UAAU,CAACrB,GAAX,IACAqB,UAAU,CAACN,GAFF,CAAd,EAEsB;AAElBJ,QAAAA,MAAM,CAACY,cAAP,CAAsBtB,MAAtB,EAA8BmB,GAA9B,EAAmCC,UAAnC;AACH,OALD,MAMK;AACDpB,QAAAA,MAAM,CAACmB,GAAD,CAAN,GAAc1B,OAAO,CAACC,KAAR,CAAcC,GAAG,CAACwB,GAAD,CAAjB,EAAwBvB,IAAxB,CAAd;AACH;AACJ;AACJ;;AAED,SAAOI,MAAP;AACH,CAlED,C,CAqEA;;AAEA;;;AACAP,OAAO,CAAC8B,KAAR,GAAgB,UAAUC,MAAV,EAAkBC,MAAlB,EAA0BC;AAAe;AAAzC,EAAuDC;AAAc;AAArE,EAAmF;AACnG;AAEIlC,EAAAA,OAAO,CAACmC,MAAR,CAAeJ,MAAM,IAAI,OAAOA,MAAP,KAAkB,QAA3C,EAAqD,yCAArD;AACA/B,EAAAA,OAAO,CAACmC,MAAR,CAAeH,MAAM,KAAK,IAAX,IAAmBA,MAAM,KAAKI,SAA9B,IAA2C,OAAOJ,MAAP,KAAkB,QAA5E,EAAsF,6DAAtF;;AAEA,MAAI,CAACA,MAAL,EAAa;AACT,WAAOD,MAAP;AACH;;AAED,MAAItB,KAAK,CAACC,OAAN,CAAcsB,MAAd,CAAJ,EAA2B;AACvBhC,IAAAA,OAAO,CAACmC,MAAR,CAAe1B,KAAK,CAACC,OAAN,CAAcqB,MAAd,CAAf,EAAsC,mCAAtC;;AACA,QAAIG,aAAa,KAAK,KAAtB,EAA6B;AAAmD;AAC5EH,MAAAA,MAAM,CAACN,MAAP,GAAgB,CAAhB,CADyB,CACmD;AAC/E;;AAED,SAAK,IAAID,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGQ,MAAM,CAACP,MAA3B,EAAmC,EAAED,CAArC,EAAwC;AACpCO,MAAAA,MAAM,CAACM,IAAP,CAAYrC,OAAO,CAACC,KAAR,CAAc+B,MAAM,CAACR,CAAD,CAApB,CAAZ;AACH;;AAED,WAAOO,MAAP;AACH;;AAED,MAAMT,IAAI,GAAGL,MAAM,CAACK,IAAP,CAAYU,MAAZ,CAAb;;AACA,OAAK,IAAIR,EAAC,GAAG,CAAb,EAAgBA,EAAC,GAAGF,IAAI,CAACG,MAAzB,EAAiC,EAAED,EAAnC,EAAsC;AAClC,QAAME,GAAG,GAAGJ,IAAI,CAACE,EAAD,CAAhB;;AACA,QAAIE,GAAG,KAAK,WAAZ,EAAyB;AACrB;AACH;;AAED,QAAMY,KAAK,GAAGN,MAAM,CAACN,GAAD,CAApB;;AACA,QAAIY,KAAK,IACL,OAAOA,KAAP,KAAiB,QADrB,EAC+B;AAE3B,UAAI,CAACP,MAAM,CAACL,GAAD,CAAP,IACA,OAAOK,MAAM,CAACL,GAAD,CAAb,KAAuB,QADvB,IAECjB,KAAK,CAACC,OAAN,CAAcqB,MAAM,CAACL,GAAD,CAApB,MAA+BjB,KAAK,CAACC,OAAN,CAAc4B,KAAd,CAFhC,IAGAA,KAAK,YAAYzB,IAHjB,IAIAF,MAAM,CAACC,QAAP,CAAgB0B,KAAhB,CAJA,IAKAA,KAAK,YAAYvB,MALrB,EAK6B;AAEzBgB,QAAAA,MAAM,CAACL,GAAD,CAAN,GAAc1B,OAAO,CAACC,KAAR,CAAcqC,KAAd,CAAd;AACH,OARD,MASK;AACDtC,QAAAA,OAAO,CAAC8B,KAAR,CAAcC,MAAM,CAACL,GAAD,CAApB,EAA2BY,KAA3B,EAAkCL,cAAlC,EAAkDC,aAAlD;AACH;AACJ,KAfD,MAgBK;AACD,UAAII,KAAK,KAAK,IAAV,IACAA,KAAK,KAAKF,SADd,EACyB;AAA+B;AAEpDL,QAAAA,MAAM,CAACL,GAAD,CAAN,GAAcY,KAAd;AACH,OAJD,MAKK,IAAIL,cAAc,KAAK,KAAvB,EAA8B;AAAqB;AACpDF,QAAAA,MAAM,CAACL,GAAD,CAAN,GAAcY,KAAd;AACH;AACJ;AACJ;;AAED,SAAOP,MAAP;AACH,CA5DD,C,CA+DA;;;AAEA/B,OAAO,CAACuC,eAAR,GAA0B,UAAUC,QAAV,EAAoBC,OAApB,EAA6BR,cAA7B,EAA6C;AAEnEjC,EAAAA,OAAO,CAACmC,MAAR,CAAeK,QAAQ,IAAI,OAAOA,QAAP,KAAoB,QAA/C,EAAyD,2CAAzD;AACAxC,EAAAA,OAAO,CAACmC,MAAR,CAAe,CAACM,OAAD,IAAYA,OAAO,KAAK,IAAxB,IAAgC,OAAOA,OAAP,KAAmB,QAAlE,EAA4E,yDAA5E;;AAEA,MAAI,CAACA,OAAL,EAAc;AAAkD;AAC5D,WAAO,IAAP;AACH;;AAED,MAAMC,IAAI,GAAG1C,OAAO,CAACC,KAAR,CAAcuC,QAAd,CAAb;;AAEA,MAAIC,OAAO,KAAK,IAAhB,EAAsB;AAA0C;AAC5D,WAAOC,IAAP;AACH;;AAED,SAAO1C,OAAO,CAAC8B,KAAR,CAAcY,IAAd,EAAoBD,OAApB,EAA6BR,cAAc,KAAK,IAAhD,EAAsD,KAAtD,CAAP;AACH,CAhBD,C,CAmBA;;;AAEAjC,OAAO,CAAC2C,gBAAR,GAA2B,UAAUX,MAAV,EAAkBV,IAAlB,EAAwB;AAE/C,MAAI,CAACU,MAAD,IACA,OAAOA,MAAP,KAAkB,QADtB,EACgC;AAE5B,WAAOA,MAAP;AACH;;AAED,MAAMY,OAAO,GAAG7C,SAAS,CAAC8C,KAAV,CAAgBb,MAAhB,EAAwBV,IAAxB,CAAhB,CAR+C,CAQG;;AAClD,MAAMoB,IAAI,GAAG1C,OAAO,CAACC,KAAR,CAAc+B,MAAd,CAAb,CAT+C,CASG;;AAClDjC,EAAAA,SAAS,CAAC+C,OAAV,CAAkBJ,IAAlB,EAAwBV,MAAxB,EAAgCY,OAAhC,EAV+C,CAUC;;AAChD,SAAOF,IAAP;AACH,CAZD;;AAeA3C,SAAS,CAAC8C,KAAV,GAAkB,UAAUb,MAAV,EAAkBV,IAAlB,EAAwB;AAEtC,MAAMsB,OAAO,GAAG,EAAhB;;AACA,OAAK,IAAIpB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,IAAI,CAACG,MAAzB,EAAiC,EAAED,CAAnC,EAAsC;AAClC,QAAME,GAAG,GAAGJ,IAAI,CAACE,CAAD,CAAhB;AACA,QAAMc,KAAK,GAAGtC,OAAO,CAAC+C,KAAR,CAAcf,MAAd,EAAsBN,GAAtB,CAAd;;AACA,QAAIY,KAAK,KAAKF,SAAd,EAAyB;AACrBQ,MAAAA,OAAO,CAAClB,GAAD,CAAP,GAAeY,KAAf;AACAvC,MAAAA,SAAS,CAACiD,QAAV,CAAmBhB,MAAnB,EAA2BN,GAA3B,EAAgCU,SAAhC;AACH;AACJ;;AAED,SAAOQ,OAAP;AACH,CAbD;;AAgBA7C,SAAS,CAAC+C,OAAV,GAAoB,UAAUJ,IAAV,EAAgBV,MAAhB,EAAwBY,OAAxB,EAAiC;AAEjD,MAAMtB,IAAI,GAAGL,MAAM,CAACK,IAAP,CAAYsB,OAAZ,CAAb;;AACA,OAAK,IAAIpB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,IAAI,CAACG,MAAzB,EAAiC,EAAED,CAAnC,EAAsC;AAClC,QAAME,GAAG,GAAGJ,IAAI,CAACE,CAAD,CAAhB;AACAzB,IAAAA,SAAS,CAACiD,QAAV,CAAmBN,IAAnB,EAAyBhB,GAAzB,EAA8BkB,OAAO,CAAClB,GAAD,CAArC;AACA3B,IAAAA,SAAS,CAACiD,QAAV,CAAmBhB,MAAnB,EAA2BN,GAA3B,EAAgCkB,OAAO,CAAClB,GAAD,CAAvC;AACH;AACJ,CARD;;AAWA3B,SAAS,CAACiD,QAAV,GAAqB,UAAU9C,GAAV,EAAewB,GAAf,EAAoBY,KAApB,EAA2B;AAE5C,MAAMW,IAAI,GAAGvB,GAAG,CAACwB,KAAJ,CAAU,GAAV,CAAb;AACA,MAAIC,GAAG,GAAGjD,GAAV;;AACA,OAAK,IAAIsB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGyB,IAAI,CAACxB,MAAzB,EAAiC,EAAED,CAAnC,EAAsC;AAClC,QAAM4B,OAAO,GAAGH,IAAI,CAACzB,CAAD,CAApB;;AACA,QAAIA,CAAC,GAAG,CAAJ,KAAUyB,IAAI,CAACxB,MAAnB,EAA2B;AACvB0B,MAAAA,GAAG,CAACC,OAAD,CAAH,GAAed,KAAf;AACH;;AAEDa,IAAAA,GAAG,GAAGA,GAAG,CAACC,OAAD,CAAT;AACH;AACJ,CAZD,C,CAeA;;;AAEApD,OAAO,CAACqD,0BAAR,GAAqC,UAAUb,QAAV,EAAoBC,OAApB,EAA6BnB,IAA7B,EAAmC;AAEpEtB,EAAAA,OAAO,CAACmC,MAAR,CAAeK,QAAQ,IAAI,OAAOA,QAAP,KAAoB,QAA/C,EAAyD,2CAAzD;AACAxC,EAAAA,OAAO,CAACmC,MAAR,CAAe,CAACM,OAAD,IAAYA,OAAO,KAAK,IAAxB,IAAgC,OAAOA,OAAP,KAAmB,QAAlE,EAA4E,yDAA5E;AACAzC,EAAAA,OAAO,CAACmC,MAAR,CAAeb,IAAI,IAAIb,KAAK,CAACC,OAAN,CAAcY,IAAd,CAAvB,EAA4C,cAA5C;;AAEA,MAAI,CAACmB,OAAL,EAAc;AAAkD;AAC5D,WAAO,IAAP;AACH;;AAED,MAAMC,IAAI,GAAG1C,OAAO,CAAC2C,gBAAR,CAAyBH,QAAzB,EAAmClB,IAAnC,CAAb;;AAEA,MAAImB,OAAO,KAAK,IAAhB,EAAsB;AAA0C;AAC5D,WAAOC,IAAP;AACH;;AAED,MAAME,OAAO,GAAG7C,SAAS,CAAC8C,KAAV,CAAgBJ,OAAhB,EAAyBnB,IAAzB,CAAhB,CAhBoE,CAgBlB;;AAClDtB,EAAAA,OAAO,CAAC8B,KAAR,CAAcY,IAAd,EAAoBD,OAApB,EAA6B,KAA7B,EAAoC,KAApC,EAjBoE,CAiBpB;;AAChD1C,EAAAA,SAAS,CAAC+C,OAAV,CAAkBJ,IAAlB,EAAwBD,OAAxB,EAAiCG,OAAjC,EAlBoE,CAkBpB;;AAChD,SAAOF,IAAP;AACH,CApBD,C,CAuBA;;;AAEA1C,OAAO,CAACsD,SAAR,GAAoB,UAAUpD,GAAV,EAAeiD,GAAf,EAAoBV,OAApB,EAA6BtC,IAA7B,EAAmC;AAEnDsC,EAAAA,OAAO,GAAGA,OAAO,IAAI;AAAEc,IAAAA,SAAS,EAAE;AAAb,GAArB;AAEA,MAAMC,IAAI,GAAG,OAAOtD,GAApB;;AAEA,MAAIsD,IAAI,KAAK,OAAOL,GAApB,EAAyB;AACrB,WAAO,KAAP;AACH;;AAED,MAAIK,IAAI,KAAK,QAAT,IACAtD,GAAG,KAAK,IADR,IAEAiD,GAAG,KAAK,IAFZ,EAEkB;AAEd,QAAIjD,GAAG,KAAKiD,GAAZ,EAAiB;AAAuD;AACpE,aAAOjD,GAAG,KAAK,CAAR,IAAa,IAAIA,GAAJ,KAAY,IAAIiD,GAApC,CADa,CACmC;AACnD;;AAED,WAAOjD,GAAG,KAAKA,GAAR,IAAeiD,GAAG,KAAKA,GAA9B,CANc,CAMsC;AACvD;;AAEDhD,EAAAA,IAAI,GAAGA,IAAI,IAAI,EAAf;;AACA,MAAIA,IAAI,CAACsD,OAAL,CAAavD,GAAb,MAAsB,CAAC,CAA3B,EAA8B;AAC1B,WAAO,IAAP,CAD0B,CACc;AAC3C;;AAEDC,EAAAA,IAAI,CAACkC,IAAL,CAAUnC,GAAV;;AAEA,MAAIO,KAAK,CAACC,OAAN,CAAcR,GAAd,CAAJ,EAAwB;AACpB,QAAI,CAACO,KAAK,CAACC,OAAN,CAAcyC,GAAd,CAAL,EAAyB;AACrB,aAAO,KAAP;AACH;;AAED,QAAI,CAACV,OAAO,CAACiB,IAAT,IAAiBxD,GAAG,CAACuB,MAAJ,KAAe0B,GAAG,CAAC1B,MAAxC,EAAgD;AAC5C,aAAO,KAAP;AACH;;AAED,SAAK,IAAID,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGtB,GAAG,CAACuB,MAAxB,EAAgC,EAAED,CAAlC,EAAqC;AACjC,UAAIiB,OAAO,CAACiB,IAAZ,EAAkB;AACd,YAAIC,KAAK,GAAG,KAAZ;;AACA,aAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGT,GAAG,CAAC1B,MAAxB,EAAgC,EAAEmC,CAAlC,EAAqC;AACjC,cAAI5D,OAAO,CAACsD,SAAR,CAAkBpD,GAAG,CAACsB,CAAD,CAArB,EAA0B2B,GAAG,CAACS,CAAD,CAA7B,EAAkCnB,OAAlC,CAAJ,EAAgD;AAC5CkB,YAAAA,KAAK,GAAG,IAAR;AACA;AACH;AACJ;;AAED,eAAOA,KAAP;AACH;;AAED,UAAI,CAAC3D,OAAO,CAACsD,SAAR,CAAkBpD,GAAG,CAACsB,CAAD,CAArB,EAA0B2B,GAAG,CAAC3B,CAAD,CAA7B,EAAkCiB,OAAlC,CAAL,EAAiD;AAC7C,eAAO,KAAP;AACH;AACJ;;AAED,WAAO,IAAP;AACH;;AAED,MAAI9B,MAAM,CAACC,QAAP,CAAgBV,GAAhB,CAAJ,EAA0B;AACtB,QAAI,CAACS,MAAM,CAACC,QAAP,CAAgBuC,GAAhB,CAAL,EAA2B;AACvB,aAAO,KAAP;AACH;;AAED,QAAIjD,GAAG,CAACuB,MAAJ,KAAe0B,GAAG,CAAC1B,MAAvB,EAA+B;AAC3B,aAAO,KAAP;AACH;;AAED,SAAK,IAAID,GAAC,GAAG,CAAb,EAAgBA,GAAC,GAAGtB,GAAG,CAACuB,MAAxB,EAAgC,EAAED,GAAlC,EAAqC;AACjC,UAAItB,GAAG,CAACsB,GAAD,CAAH,KAAW2B,GAAG,CAAC3B,GAAD,CAAlB,EAAuB;AACnB,eAAO,KAAP;AACH;AACJ;;AAED,WAAO,IAAP;AACH;;AAED,MAAItB,GAAG,YAAYW,IAAnB,EAAyB;AACrB,WAAQsC,GAAG,YAAYtC,IAAf,IAAuBX,GAAG,CAACY,OAAJ,OAAkBqC,GAAG,CAACrC,OAAJ,EAAjD;AACH;;AAED,MAAIZ,GAAG,YAAYa,MAAnB,EAA2B;AACvB,WAAQoC,GAAG,YAAYpC,MAAf,IAAyBb,GAAG,CAAC2D,QAAJ,OAAmBV,GAAG,CAACU,QAAJ,EAApD;AACH;;AAED,MAAIpB,OAAO,CAACc,SAAZ,EAAuB;AACnB,QAAItC,MAAM,CAACC,cAAP,CAAsBhB,GAAtB,MAA+Be,MAAM,CAACC,cAAP,CAAsBiC,GAAtB,CAAnC,EAA+D;AAC3D,aAAO,KAAP;AACH;AACJ;;AAED,MAAM7B,IAAI,GAAGL,MAAM,CAACM,mBAAP,CAA2BrB,GAA3B,CAAb;;AAEA,MAAI,CAACuC,OAAO,CAACiB,IAAT,IAAiBpC,IAAI,CAACG,MAAL,KAAgBR,MAAM,CAACM,mBAAP,CAA2B4B,GAA3B,EAAgC1B,MAArE,EAA6E;AACzE,WAAO,KAAP;AACH;;AAED,OAAK,IAAID,GAAC,GAAG,CAAb,EAAgBA,GAAC,GAAGF,IAAI,CAACG,MAAzB,EAAiC,EAAED,GAAnC,EAAsC;AAClC,QAAME,GAAG,GAAGJ,IAAI,CAACE,GAAD,CAAhB;AACA,QAAMG,UAAU,GAAGV,MAAM,CAACW,wBAAP,CAAgC1B,GAAhC,EAAqCwB,GAArC,CAAnB;;AACA,QAAIC,UAAU,CAACrB,GAAf,EAAoB;AAChB,UAAI,CAACN,OAAO,CAACsD,SAAR,CAAkB3B,UAAlB,EAA8BV,MAAM,CAACW,wBAAP,CAAgCuB,GAAhC,EAAqCzB,GAArC,CAA9B,EAAyEe,OAAzE,EAAkFtC,IAAlF,CAAL,EAA8F;AAC1F,eAAO,KAAP;AACH;AACJ,KAJD,MAKK,IAAI,CAACH,OAAO,CAACsD,SAAR,CAAkBpD,GAAG,CAACwB,GAAD,CAArB,EAA4ByB,GAAG,CAACzB,GAAD,CAA/B,EAAsCe,OAAtC,EAA+CtC,IAA/C,CAAL,EAA2D;AAC5D,aAAO,KAAP;AACH;AACJ;;AAED,SAAO,IAAP;AACH,CA9GD,C,CAiHA;;;AAEAH,OAAO,CAAC8D,MAAR,GAAiB,UAACC,KAAD,EAAQrC,GAAR,EAAgB;AAE7B,MAAIsC,MAAJ;;AACA,MAAItC,GAAJ,EAAS;AACLsC,IAAAA,MAAM,GAAG,EAAT;AACA,QAAMC,KAAK,GAAG,IAAIC,GAAJ,EAAd;AACAH,IAAAA,KAAK,CAACI,OAAN,CAAc,UAACC,IAAD,EAAU;AAEpB,UAAMC,UAAU,GAAGD,IAAI,CAAC1C,GAAD,CAAvB;;AACA,UAAI,CAACuC,KAAK,CAACK,GAAN,CAAUD,UAAV,CAAL,EAA4B;AACxBJ,QAAAA,KAAK,CAACM,GAAN,CAAUF,UAAV;AACAL,QAAAA,MAAM,CAAC3B,IAAP,CAAY+B,IAAZ;AACH;AACJ,KAPD;AAQH,GAXD,MAYK;AACDJ,IAAAA,MAAM,GAAGvD,KAAK,CAAC+D,IAAN,CAAW,IAAIN,GAAJ,CAAQH,KAAR,CAAX,CAAT;AACH;;AAED,SAAOC,MAAP;AACH,CApBD,C,CAuBA;;;AAEAhE,OAAO,CAACyE,WAAR,GAAsB,UAAUV,KAAV,EAAiBrC,GAAjB,EAAsB;AAExC,MAAI,CAACqC,KAAL,EAAY;AACR,WAAO,IAAP;AACH;;AAED,MAAM7D,GAAG,GAAG,EAAZ;;AACA,OAAK,IAAIsB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGuC,KAAK,CAACtC,MAA1B,EAAkC,EAAED,CAApC,EAAuC;AACnC,QAAIE,GAAJ,EAAS;AACL,UAAIqC,KAAK,CAACvC,CAAD,CAAL,CAASE,GAAT,CAAJ,EAAmB;AACfxB,QAAAA,GAAG,CAAC6D,KAAK,CAACvC,CAAD,CAAL,CAASE,GAAT,CAAD,CAAH,GAAqB,IAArB;AACH;AACJ,KAJD,MAKK;AACDxB,MAAAA,GAAG,CAAC6D,KAAK,CAACvC,CAAD,CAAN,CAAH,GAAgB,IAAhB;AACH;AACJ;;AAED,SAAOtB,GAAP;AACH,CAnBD,C,CAsBA;;;AAEAF,OAAO,CAAC0E,SAAR,GAAoB,UAAUC,MAAV,EAAkBC,MAAlB,EAA0BC,SAA1B,EAAqC;AAErD,MAAI,CAACF,MAAD,IAAW,CAACC,MAAhB,EAAwB;AACpB,WAAO,EAAP;AACH;;AAED,MAAME,MAAM,GAAG,EAAf;AACA,MAAMC,IAAI,GAAItE,KAAK,CAACC,OAAN,CAAciE,MAAd,IAAwB3E,OAAO,CAACyE,WAAR,CAAoBE,MAApB,CAAxB,GAAsDA,MAApE;AACA,MAAMhB,KAAK,GAAG,EAAd;;AACA,OAAK,IAAInC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGoD,MAAM,CAACnD,MAA3B,EAAmC,EAAED,CAArC,EAAwC;AACpC,QAAIuD,IAAI,CAACH,MAAM,CAACpD,CAAD,CAAP,CAAJ,IAAmB,CAACmC,KAAK,CAACiB,MAAM,CAACpD,CAAD,CAAP,CAA7B,EAA0C;AACtC,UAAIqD,SAAJ,EAAe;AACX,eAAOD,MAAM,CAACpD,CAAD,CAAb;AACH;;AAEDsD,MAAAA,MAAM,CAACzC,IAAP,CAAYuC,MAAM,CAACpD,CAAD,CAAlB;AACAmC,MAAAA,KAAK,CAACiB,MAAM,CAACpD,CAAD,CAAP,CAAL,GAAmB,IAAnB;AACH;AACJ;;AAED,SAAQqD,SAAS,GAAG,IAAH,GAAUC,MAA3B;AACH,CArBD,C,CAwBA;;;AAEA9E,OAAO,CAACgF,OAAR,GAAkB,UAAU7B,GAAV,EAAe8B,MAAf,EAAuBxC,OAAvB,EAAgC;AAE9C;;;;;;AAOA,MAAIyC,UAAU,GAAG,IAAjB;;AACA,MAAI,OAAO/B,GAAP,KAAe,QAAf,IACA,OAAO8B,MAAP,KAAkB,QADlB,IAEA,CAACxE,KAAK,CAACC,OAAN,CAAcyC,GAAd,CAFD,IAGA,CAAC1C,KAAK,CAACC,OAAN,CAAcuE,MAAd,CAHL,EAG4B;AAExBC,IAAAA,UAAU,GAAGD,MAAb;AACAA,IAAAA,MAAM,GAAGhE,MAAM,CAACK,IAAP,CAAY2D,MAAZ,CAAT;AACH,GAPD,MAQK;AACDA,IAAAA,MAAM,GAAG,GAAGE,MAAH,CAAUF,MAAV,CAAT;AACH;;AAEDxC,EAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB,CAtB8C,CAsBV;;AAEpCzC,EAAAA,OAAO,CAACmC,MAAR,CAAeiD,SAAS,CAAC3D,MAAV,IAAoB,CAAnC,EAAsC,wBAAtC;AACAzB,EAAAA,OAAO,CAACmC,MAAR,CAAe,OAAOgB,GAAP,KAAe,QAAf,IAA2B,OAAOA,GAAP,KAAe,QAAzD,EAAmE,uCAAnE;AACAnD,EAAAA,OAAO,CAACmC,MAAR,CAAe8C,MAAM,CAACxD,MAAtB,EAA8B,8BAA9B;AAEA,MAAI4D,OAAJ;AACA,MAAIC,YAAJ;;AACA,MAAI7C,OAAO,CAAC8C,IAAZ,EAAkB;AACdF,IAAAA,OAAO,GAAGrF,OAAO,CAACsD,SAAlB;AAEA,QAAMkC,OAAO,GAAG/C,OAAO,CAACgD,cAAR,CAAuB,MAAvB,CAAhB;AACA,QAAMC,OAAO,GAAGjD,OAAO,CAACgD,cAAR,CAAuB,MAAvB,CAAhB;AAEAH,IAAAA,YAAY,GAAG;AACX/B,MAAAA,SAAS,EAAEiC,OAAO,GAAG/C,OAAO,CAACkD,IAAX,GAAkBD,OAAO,GAAG,CAACjD,OAAO,CAACiB,IAAZ,GAAmB,KADnD;AAEXA,MAAAA,IAAI,EAAE8B,OAAO,GAAG,CAAC/C,OAAO,CAACkD,IAAZ,GAAmBD,OAAO,GAAGjD,OAAO,CAACiB,IAAX,GAAkB;AAF9C,KAAf;AAIH,GAVD,MAWK;AACD2B,IAAAA,OAAO,GAAG,iBAACO,CAAD,EAAIC,CAAJ;AAAA,aAAUD,CAAC,KAAKC,CAAhB;AAAA,KAAV;AACH;;AAED,MAAIC,MAAM,GAAG,KAAb;AACA,MAAMC,OAAO,GAAG,IAAItF,KAAJ,CAAUwE,MAAM,CAACxD,MAAjB,CAAhB;;AACA,OAAK,IAAID,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGuE,OAAO,CAACtE,MAA5B,EAAoC,EAAED,CAAtC,EAAyC;AACrCuE,IAAAA,OAAO,CAACvE,CAAD,CAAP,GAAa,CAAb;AACH;;AAED,MAAI,OAAO2B,GAAP,KAAe,QAAnB,EAA6B;AACzB,QAAI6C,OAAO,GAAG,GAAd;;AACA,SAAK,IAAIxE,GAAC,GAAG,CAAb,EAAgBA,GAAC,GAAGyD,MAAM,CAACxD,MAA3B,EAAmC,EAAED,GAArC,EAAwC;AACpC,UAAMc,KAAK,GAAG2C,MAAM,CAACzD,GAAD,CAApB;AACAxB,MAAAA,OAAO,CAACmC,MAAR,CAAe,OAAOG,KAAP,KAAiB,QAAhC,EAA0C,qDAA1C;AACA0D,MAAAA,OAAO,IAAI,CAACxE,GAAC,GAAG,GAAH,GAAS,EAAX,IAAiBxB,OAAO,CAACiG,WAAR,CAAoB3D,KAApB,CAA5B;AACH;;AAED,QAAM4D,KAAK,GAAG,IAAInF,MAAJ,CAAWiF,OAAO,GAAG,GAArB,EAA0B,GAA1B,CAAd;AACA,QAAMG,SAAS,GAAGhD,GAAG,CAACiD,OAAJ,CAAYF,KAAZ,EAAmB,UAACG,EAAD,EAAKC,EAAL,EAAY;AAE7C,UAAMrC,KAAK,GAAGgB,MAAM,CAACxB,OAAP,CAAe6C,EAAf,CAAd;AACA,QAAEP,OAAO,CAAC9B,KAAD,CAAT;AACA,aAAO,EAAP,CAJ6C,CAIzB;AACvB,KALiB,CAAlB;AAOA6B,IAAAA,MAAM,GAAG,CAAC,CAACK,SAAX;AACH,GAjBD,MAkBK,IAAI1F,KAAK,CAACC,OAAN,CAAcyC,GAAd,CAAJ,EAAwB;AACzB,SAAK,IAAI3B,GAAC,GAAG,CAAb,EAAgBA,GAAC,GAAG2B,GAAG,CAAC1B,MAAxB,EAAgC,EAAED,GAAlC,EAAqC;AACjC,UAAI+E,OAAO,GAAG,KAAd;;AACA,WAAK,IAAI3C,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGqB,MAAM,CAACxD,MAAX,IAAqB8E,OAAO,KAAK,KAAjD,EAAwD,EAAE3C,CAA1D,EAA6D;AACzD2C,QAAAA,OAAO,GAAGlB,OAAO,CAACJ,MAAM,CAACrB,CAAD,CAAP,EAAYT,GAAG,CAAC3B,GAAD,CAAf,EAAoB8D,YAApB,CAAP,IAA4C1B,CAAtD;AACH;;AAED,UAAI2C,OAAO,KAAK,KAAhB,EAAuB;AACnB,UAAER,OAAO,CAACQ,OAAD,CAAT;AACH,OAFD,MAGK;AACDT,QAAAA,MAAM,GAAG,IAAT;AACH;AACJ;AACJ,GAdI,MAeA;AACD,QAAMxE,IAAI,GAAGL,MAAM,CAACM,mBAAP,CAA2B4B,GAA3B,CAAb;;AACA,SAAK,IAAI3B,GAAC,GAAG,CAAb,EAAgBA,GAAC,GAAGF,IAAI,CAACG,MAAzB,EAAiC,EAAED,GAAnC,EAAsC;AAClC,UAAME,GAAG,GAAGJ,IAAI,CAACE,GAAD,CAAhB;AACA,UAAMgF,GAAG,GAAGvB,MAAM,CAACxB,OAAP,CAAe/B,GAAf,CAAZ;;AACA,UAAI8E,GAAG,KAAK,CAAC,CAAb,EAAgB;AACZ,YAAItB,UAAU,IACV,CAACG,OAAO,CAACH,UAAU,CAACxD,GAAD,CAAX,EAAkByB,GAAG,CAACzB,GAAD,CAArB,EAA4B4D,YAA5B,CADZ,EACuD;AAEnD,iBAAO,KAAP;AACH;;AAED,UAAES,OAAO,CAACS,GAAD,CAAT;AACH,OARD,MASK;AACDV,QAAAA,MAAM,GAAG,IAAT;AACH;AACJ;AACJ;;AAED,MAAI9B,MAAM,GAAG,KAAb;;AACA,OAAK,IAAIxC,GAAC,GAAG,CAAb,EAAgBA,GAAC,GAAGuE,OAAO,CAACtE,MAA5B,EAAoC,EAAED,GAAtC,EAAyC;AACrCwC,IAAAA,MAAM,GAAGA,MAAM,IAAI,CAAC,CAAC+B,OAAO,CAACvE,GAAD,CAA5B;;AACA,QAAKiB,OAAO,CAACgE,IAAR,IAAgBV,OAAO,CAACvE,GAAD,CAAP,GAAa,CAA9B,IACC,CAACiB,OAAO,CAACiB,IAAT,IAAiB,CAACqC,OAAO,CAACvE,GAAD,CAD9B,EACoC;AAEhC,aAAO,KAAP;AACH;AACJ;;AAED,MAAIiB,OAAO,CAACkD,IAAR,IACAG,MADJ,EACY;AAER,WAAO,KAAP;AACH;;AAED,SAAO9B,MAAP;AACH,CAzHD,C,CA4HA;;;AAEAhE,OAAO,CAAC0G,OAAR,GAAkB,UAAU3C,KAAV,EAAiBhC,MAAjB,EAAyB;AAEvC,MAAMiC,MAAM,GAAGjC,MAAM,IAAI,EAAzB;;AAEA,OAAK,IAAIP,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGuC,KAAK,CAACtC,MAA1B,EAAkC,EAAED,CAApC,EAAuC;AACnC,QAAIf,KAAK,CAACC,OAAN,CAAcqD,KAAK,CAACvC,CAAD,CAAnB,CAAJ,EAA6B;AACzBxB,MAAAA,OAAO,CAAC0G,OAAR,CAAgB3C,KAAK,CAACvC,CAAD,CAArB,EAA0BwC,MAA1B;AACH,KAFD,MAGK;AACDA,MAAAA,MAAM,CAAC3B,IAAP,CAAY0B,KAAK,CAACvC,CAAD,CAAjB;AACH;AACJ;;AAED,SAAOwC,MAAP;AACH,CAdD,C,CAiBA;;;AAEAhE,OAAO,CAAC+C,KAAR,GAAgB,UAAU7C,GAAV,EAAeyG,KAAf,EAAsBlE,OAAtB,EAA+B;AAE3C,MAAIkE,KAAK,KAAK,KAAV,IACAA,KAAK,KAAK,IADV,IAEA,OAAOA,KAAP,KAAiB,WAFrB,EAEkC;AAE9B,WAAOzG,GAAP;AACH;;AAEDuC,EAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;;AACA,MAAI,OAAOA,OAAP,KAAmB,QAAvB,EAAiC;AAC7BA,IAAAA,OAAO,GAAG;AAAEmE,MAAAA,SAAS,EAAEnE;AAAb,KAAV;AACH;;AAED,MAAMQ,IAAI,GAAG0D,KAAK,CAACzD,KAAN,CAAYT,OAAO,CAACmE,SAAR,IAAqB,GAAjC,CAAb;AACA,MAAIzD,GAAG,GAAGjD,GAAV;;AACA,OAAK,IAAIsB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGyB,IAAI,CAACxB,MAAzB,EAAiC,EAAED,CAAnC,EAAsC;AAClC,QAAIE,GAAG,GAAGuB,IAAI,CAACzB,CAAD,CAAd;;AACA,QAAIE,GAAG,CAAC,CAAD,CAAH,KAAW,GAAX,IAAkBjB,KAAK,CAACC,OAAN,CAAcyC,GAAd,CAAtB,EAA0C;AACtCzB,MAAAA,GAAG,GAAGA,GAAG,CAACmF,KAAJ,CAAU,CAAV,EAAanF,GAAG,CAACD,MAAjB,CAAN;AACAC,MAAAA,GAAG,GAAGyB,GAAG,CAAC1B,MAAJ,GAAaC,GAAnB;AACH;;AAED,QAAI,CAACyB,GAAD,IACA,EAAE,CAAC,OAAOA,GAAP,KAAe,QAAf,IAA2B,OAAOA,GAAP,KAAe,UAA3C,KAA0DzB,GAAG,IAAIyB,GAAnE,CADA,IAEC,OAAOA,GAAP,KAAe,QAAf,IAA2BV,OAAO,CAACqE,SAAR,KAAsB,KAFtD,EAE8D;AAAU;AAEpE9G,MAAAA,OAAO,CAACmC,MAAR,CAAe,CAACM,OAAO,CAACsE,MAAT,IAAmBvF,CAAC,GAAG,CAAJ,KAAUyB,IAAI,CAACxB,MAAjD,EAAyD,iBAAzD,EAA4EC,GAA5E,EAAiF,gBAAjF,EAAmGiF,KAAnG;AACA3G,MAAAA,OAAO,CAACmC,MAAR,CAAe,OAAOgB,GAAP,KAAe,QAAf,IAA2BV,OAAO,CAACqE,SAAR,KAAsB,IAAjD,IAAyD,OAAO3D,GAAP,KAAe,UAAvF,EAAmG,iBAAnG,EAAsHzB,GAAtH,EAA2H,gBAA3H,EAA6IiF,KAA7I;AACAxD,MAAAA,GAAG,GAAGV,OAAO,CAACuE,OAAd;AACA;AACH;;AAED7D,IAAAA,GAAG,GAAGA,GAAG,CAACzB,GAAD,CAAT;AACH;;AAED,SAAOyB,GAAP;AACH,CArCD;;AAwCAnD,OAAO,CAACiH,aAAR,GAAwB,UAAU/G,GAAV,EAAegH,QAAf,EAAyBzE,OAAzB,EAAkC;AAEtD,SAAOyE,QAAQ,CAACd,OAAT,CAAiB,YAAjB,EAA+B,UAACC,EAAD,EAAKM,KAAL,EAAe;AAEjD,QAAMrE,KAAK,GAAGtC,OAAO,CAAC+C,KAAR,CAAc7C,GAAd,EAAmByG,KAAnB,EAA0BlE,OAA1B,CAAd;AACA,WAAQH,KAAK,KAAKF,SAAV,IAAuBE,KAAK,KAAK,IAAjC,GAAwC,EAAxC,GAA6CA,KAArD;AACH,GAJM,CAAP;AAKH,CAPD;;AAUAtC,OAAO,CAACmH,WAAR,GAAsB,UAAUC,KAAV,EAAiB;AAEnC,MAAMC,KAAK,GAAG,EAAd;;AACA,OAAK,IAAI7F,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG4F,KAAK,CAAC3F,MAA1B,EAAkC,EAAED,CAApC,EAAuC;AACnC,QAAM4C,IAAI,GAAGgD,KAAK,CAAC5F,CAAD,CAAlB;AACA6F,IAAAA,KAAK,CAAChF,IAAN,CAAW,CAAC+B,IAAI,CAACkD,WAAL,EAAD,EAAqBlD,IAAI,CAACmD,aAAL,EAArB,EAA2CnD,IAAI,CAACoD,eAAL,EAA3C,EAAmEpD,IAAI,CAACqD,eAAL,EAAnE,EAA2FrD,IAAI,CAACsD,aAAL,EAA3F,CAAX;AACH;;AAED,SAAOL,KAAP;AACH,CATD;;AAYArH,OAAO,CAAC2H,WAAR,GAAsB,UAAUN,KAAV,EAAiB;AAEnC,MAAMO,OAAO,GAAG,EAAhB;;AAEA,OAAK,IAAIpG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG6F,KAAK,CAAC5F,MAA1B,EAAkC,EAAED,CAApC,EAAuC;AACnC,QAAMqG,GAAG,GAAGR,KAAK,CAAC7F,CAAD,CAAjB;AACAoG,IAAAA,OAAO,CAACvF,IAAR,CAAa,CAACwF,GAAG,CAAC,CAAD,CAAH,GAAS,MAAT,GAAkB,EAAnB,IAAyBA,GAAG,CAAC,CAAD,CAA5B,GAAkC,IAAlC,GAAyCA,GAAG,CAAC,CAAD,CAA5C,GAAkD,GAAlD,GAAwDA,GAAG,CAAC,CAAD,CAA3D,GAAiE,GAAjE,GAAuEA,GAAG,CAAC,CAAD,CAA1E,GAAgF,GAA7F;AACH;;AAED,SAAOD,OAAP;AACH,CAVD;;AAaA5H,OAAO,CAAC8H,SAAR,GAAoB,UAAUjB,KAAV,EAAiB;AAEjC;AAEA,MAAMkB,EAAE,GAAGC,KAAK,CAACC,iBAAjB;;AACAD,EAAAA,KAAK,CAACC,iBAAN,GAA0B,UAAUC,CAAV,EAAad,KAAb,EAAoB;AAE1C,WAAOA,KAAP;AACH,GAHD;;AAKA,MAAMe,OAAO,GAAG,EAAhB;AACAH,EAAAA,KAAK,CAACI,iBAAN,CAAwBD,OAAxB,EAAiC,IAAjC,EAXiC,CAWW;;AAC5C,MAAMf,KAAK,GAAGe,OAAO,CAACf,KAAtB;AAEAY,EAAAA,KAAK,CAACC,iBAAN,GAA0BF,EAA1B;AAEA,MAAMV,KAAK,GAAGrH,OAAO,CAACmH,WAAR,CAAoBC,KAApB,CAAd;AAEA,SAAOC,KAAK,CAACR,KAAN,CAAY,IAAIA,KAAhB,CAAP;AACH,CAnBD;;AAsBA7G,OAAO,CAACqI,YAAR,GAAuB,UAAUxB,KAAV,EAAiB;AAEpC,MAAMQ,KAAK,GAAGrH,OAAO,CAAC8H,SAAR,CAAkBjB,KAAK,KAAKzE,SAAV,GAAsB,CAAtB,GAA0ByE,KAAK,GAAG,CAApD,CAAd;AAEA,SAAO7G,OAAO,CAAC2H,WAAR,CAAoBN,KAApB,CAAP;AACH,CALD;;AAQArH,OAAO,CAACsI,UAAR,GAAqB,KAArB;;AAGAtI,OAAO,CAACuI,KAAR,GAAgB,UAAUC,OAAV,EAAmBC,SAAnB,EAA8B;AAE1C,MAAIC,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,MAAzB,IAAmC5I,OAAO,CAACsI,UAAR,KAAuB,IAA9D,EAAoE;AAChE,UAAM,IAAIN,KAAJ,CAAUQ,OAAO,IAAI,eAArB,CAAN;AACH;;AAED,MAAIpB,KAAK,GAAG,EAAZ;;AACA,MAAI,CAACqB,SAAL,EAAgB;AACZrB,IAAAA,KAAK,GAAGpH,OAAO,CAACqI,YAAR,CAAqB,CAArB,EAAwBQ,IAAxB,CAA6B,MAA7B,CAAR;AACH;;AACDC,EAAAA,OAAO,CAACC,GAAR,CAAY,YAAYP,OAAZ,GAAsB,MAAtB,GAA+BpB,KAA3C;AACAsB,EAAAA,OAAO,CAACM,IAAR,CAAa,CAAb;AACH,CAZD;;AAeAhJ,OAAO,CAACmC,MAAR,GAAiB,UAAU8G;AAAU;AAApB,EAA6C;AAE1D,MAAIA,SAAJ,EAAe;AACX;AACH;;AAED,MAAI7D,SAAS,CAAC3D,MAAV,KAAqB,CAArB,IAA0B2D,SAAS,CAAC,CAAD,CAAT,YAAwB4C,KAAtD,EAA6D;AACzD,UAAM5C,SAAS,CAAC,CAAD,CAAf;AACH;;AAED,MAAI8D,IAAI,GAAG,EAAX;;AACA,OAAK,IAAI1H,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG4D,SAAS,CAAC3D,MAA9B,EAAsC,EAAED,CAAxC,EAA2C;AACvC,QAAI4D,SAAS,CAAC5D,CAAD,CAAT,KAAiB,EAArB,EAAyB;AACrB0H,MAAAA,IAAI,CAAC7G,IAAL,CAAU+C,SAAS,CAAC5D,CAAD,CAAnB,EADqB,CACe;AACvC;AACJ;;AAED0H,EAAAA,IAAI,GAAGA,IAAI,CAACC,GAAL,CAAS,UAACC,GAAD,EAAS;AAErB,WAAO,OAAOA,GAAP,KAAe,QAAf,GAA0BA,GAA1B,GAAgCA,GAAG,YAAYpB,KAAf,GAAuBoB,GAAG,CAACZ,OAA3B,GAAqCxI,OAAO,CAACqJ,SAAR,CAAkBD,GAAlB,CAA5E;AACH,GAHM,CAAP;AAKA,QAAM,IAAIpB,KAAJ,CAAUkB,IAAI,CAACL,IAAL,CAAU,GAAV,KAAkB,eAA5B,CAAN;AACH,CAvBD;;AA0BA7I,OAAO,CAACsJ,KAAR,GAAgB,YAAY;AAExB,OAAKC,EAAL,GAAU,CAAV;AACA,OAAKC,KAAL;AACH,CAJD;;AAOAxJ,OAAO,CAACsJ,KAAR,CAAc/F,SAAd,CAAwBiG,KAAxB,GAAgC,YAAY;AAExC,OAAKD,EAAL,GAAU1I,IAAI,CAAC4I,GAAL,EAAV;AACH,CAHD;;AAMAzJ,OAAO,CAACsJ,KAAR,CAAc/F,SAAd,CAAwBmG,OAAxB,GAAkC,YAAY;AAE1C,SAAO7I,IAAI,CAAC4I,GAAL,KAAa,KAAKF,EAAzB;AACH,CAHD;;AAMAvJ,OAAO,CAAC2J,KAAR,GAAgB,YAAY;AAExB,OAAKJ,EAAL,GAAU,CAAV;AACA,OAAKC,KAAL;AACH,CAJD;;AAOAxJ,OAAO,CAAC2J,KAAR,CAAcpG,SAAd,CAAwBiG,KAAxB,GAAgC,YAAY;AAExC,OAAKD,EAAL,GAAUvJ,OAAO,CAAC2J,KAAR,CAAcF,GAAd,EAAV;AACH,CAHD;;AAMAzJ,OAAO,CAAC2J,KAAR,CAAcpG,SAAd,CAAwBmG,OAAxB,GAAkC,YAAY;AAE1C,SAAO1J,OAAO,CAAC2J,KAAR,CAAcF,GAAd,KAAsB,KAAKF,EAAlC;AACH,CAHD;;AAMAvJ,OAAO,CAAC2J,KAAR,CAAcF,GAAd,GAAoB,YAAY;AAE5B,MAAMF,EAAE,GAAGb,OAAO,CAACkB,MAAR,EAAX;AACA,SAAQL,EAAE,CAAC,CAAD,CAAF,GAAQ,GAAT,GAAiBA,EAAE,CAAC,CAAD,CAAF,GAAQ,GAAhC;AACH,CAJD,C,CAOA;;;AAEAvJ,OAAO,CAACiG,WAAR,GAAsB,UAAU4D,MAAV,EAAkB;AAEpC;AACA,SAAOA,MAAM,CAACzD,OAAP,CAAe,6CAAf,EAA8D,MAA9D,CAAP;AACH,CAJD,C,CAOA;;;AAEApG,OAAO,CAAC8J,eAAR,GAA0B,UAAUxH,KAAV,EAAiByH,QAAjB,EAA2B;AAEjD/J,EAAAA,OAAO,CAACmC,MAAR,CAAe,OAAOG,KAAP,KAAiB,QAAjB,IAA6B3B,MAAM,CAACC,QAAP,CAAgB0B,KAAhB,CAA5C,EAAoE,gCAApE;AACA,MAAM0H,GAAG,GAAIrJ,MAAM,CAACC,QAAP,CAAgB0B,KAAhB,IAAyBA,KAAzB,GAAiC,IAAI3B,MAAJ,CAAW2B,KAAX,EAAkByH,QAAQ,IAAI,QAA9B,CAA9C;AACA,SAAOC,GAAG,CAACnG,QAAJ,CAAa,QAAb,EAAuBuC,OAAvB,CAA+B,KAA/B,EAAsC,GAAtC,EAA2CA,OAA3C,CAAmD,KAAnD,EAA0D,GAA1D,EAA+DA,OAA/D,CAAuE,KAAvE,EAA8E,EAA9E,CAAP;AACH,CALD,C,CAQA;;;AAEApG,OAAO,CAACiK,eAAR,GAA0B,UAAU3H,KAAV,EAAiByH,QAAjB,EAA2B;AAEjD,MAAI,OAAOzH,KAAP,KAAiB,QAArB,EAA+B;AAE3B,WAAO,IAAI0F,KAAJ,CAAU,oBAAV,CAAP;AACH;;AAED,MAAI,CAAC,YAAYkC,IAAZ,CAAiB5H,KAAjB,CAAL,EAA8B;AAE1B,WAAO,IAAI0F,KAAJ,CAAU,mBAAV,CAAP;AACH;;AAED,MAAMgC,GAAG,GAAG,IAAIrJ,MAAJ,CAAW2B,KAAX,EAAkB,QAAlB,CAAZ;AACA,SAAQyH,QAAQ,KAAK,QAAb,GAAwBC,GAAxB,GAA8BA,GAAG,CAACnG,QAAJ,CAAakG,QAAQ,IAAI,QAAzB,CAAtC;AACH,CAdD,C,CAiBA;;;AAEA/J,OAAO,CAACmK,qBAAR,GAAgC,UAAUC,SAAV,EAAqB;AAEjD;AAEApK,EAAAA,OAAO,CAACmC,MAAR,CAAe,8DAA8D+H,IAA9D,CAAmEE,SAAnE,CAAf,EAA8F,0BAA0BA,SAA1B,GAAsC,GAApI;AAEA,SAAOA,SAAS,CAAChE,OAAV,CAAkB,KAAlB,EAAyB,MAAzB,EAAiCA,OAAjC,CAAyC,KAAzC,EAAgD,KAAhD,CAAP,CANiD,CAM0C;AAC9F,CAPD;;AAUApG,OAAO,CAACqK,UAAR,GAAqB,UAAUR,MAAV,EAAkB;AAEnC,SAAO/J,MAAM,CAACuK,UAAP,CAAkBR,MAAlB,CAAP;AACH,CAHD;;AAMA7J,OAAO,CAACsK,gBAAR,GAA2B,UAAUT,MAAV,EAAkB;AAEzC,SAAO/J,MAAM,CAACwK,gBAAP,CAAwBT,MAAxB,CAAP;AACH,CAHD;;AAKA7J,OAAO,CAACuK,UAAR,GAAqB,UAAUV,MAAV,EAAkB;AAEnC,SAAO/J,MAAM,CAACyK,UAAP,CAAkBV,MAAlB,CAAP;AACH,CAHD;;AAKA7J,OAAO,CAACwK,QAAR,GAAmB,UAAUC,QAAV,EAAoB;AAEnC,SAAO,YAAY;AAEf,QAAMC,IAAI,GAAGtF,SAAb;AACAsD,IAAAA,OAAO,CAAC8B,QAAR,CAAiB,YAAM;AAEnBC,MAAAA,QAAQ,CAACE,KAAT,CAAe,IAAf,EAAqBD,IAArB;AACH,KAHD;AAIH,GAPD;AAQH,CAVD;;AAaA1K,OAAO,CAACyG,IAAR,GAAe,UAAUmE,MAAV,EAAkB;AAE7B,MAAIA,MAAM,CAACC,SAAX,EAAsB;AAClB,WAAOD,MAAP;AACH;;AAED,MAAInE,IAAI,GAAG,KAAX;;AACA,MAAMqE,OAAO,GAAG,SAAVA,OAAU,GAAY;AAExB,QAAI,CAACrE,IAAL,EAAW;AACPA,MAAAA,IAAI,GAAG,IAAP;AACAmE,MAAAA,MAAM,CAACD,KAAP,CAAa,IAAb,EAAmBvF,SAAnB;AACH;AACJ,GAND;;AAQA0F,EAAAA,OAAO,CAACD,SAAR,GAAoB,IAApB;AAEA,SAAOC,OAAP;AACH,CAlBD;;AAqBA9K,OAAO,CAAC+K,SAAR,GAAoBC,MAAM,CAACC,aAA3B;;AAGAjL,OAAO,CAACkL,MAAR,GAAiB,YAAY,CAAG,CAAhC;;AAGAlL,OAAO,CAACmL,QAAR,GAAmBtL,IAAI,CAACsL,QAAxB;AAGAnL,OAAO,CAACoL,MAAR,GAAiBvL,IAAI,CAACuL,MAAtB;;AAGApL,OAAO,CAACqL,SAAR,GAAoB,UAAUrJ,MAAV,EAAkBqJ,SAAlB,EAA6B5I,OAA7B,EAAsC;AAEtDzC,EAAAA,OAAO,CAACmC,MAAR,CAAeH,MAAM,KAAK,IAAX,IAAmBA,MAAM,KAAKI,SAA9B,IAA2C,OAAOJ,MAAP,KAAkB,QAA7D,IAAyEvB,KAAK,CAACC,OAAN,CAAcsB,MAAd,CAAxF,EAA+G,wEAA/G;AACA,MAAM4E,SAAS,GAAI,OAAOnE,OAAP,KAAmB,QAAnB,IAA+BA,OAAO,KAAK,IAA5C,GAAqDA,OAAO,CAACmE,SAAR,IAAqB,GAA1E,GAAiF,GAAnG;;AAEA,MAAInG,KAAK,CAACC,OAAN,CAAcsB,MAAd,CAAJ,EAA2B;AACvB,QAAMsJ,OAAO,GAAG,EAAhB;;AACA,SAAK,IAAI9J,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGQ,MAAM,CAACP,MAA3B,EAAmC,EAAED,CAArC,EAAwC;AACpC8J,MAAAA,OAAO,CAACjJ,IAAR,CAAarC,OAAO,CAACqL,SAAR,CAAkBrJ,MAAM,CAACR,CAAD,CAAxB,EAA6B6J,SAA7B,EAAwC5I,OAAxC,CAAb;AACH;;AACD,WAAO6I,OAAP;AACH;;AAED,MAAMtH,MAAM,GAAG,EAAf;AACA,MAAM1C,IAAI,GAAGL,MAAM,CAACK,IAAP,CAAY+J,SAAZ,CAAb;;AAEA,OAAK,IAAI7J,GAAC,GAAG,CAAb,EAAgBA,GAAC,GAAGF,IAAI,CAACG,MAAzB,EAAiC,EAAED,GAAnC,EAAsC;AAClC,QAAME,GAAG,GAAGJ,IAAI,CAACE,GAAD,CAAhB;AACA,QAAMyB,IAAI,GAAGvB,GAAG,CAACwB,KAAJ,CAAU0D,SAAV,CAAb;AACA,QAAM2E,UAAU,GAAGF,SAAS,CAAC3J,GAAD,CAA5B;AAEA1B,IAAAA,OAAO,CAACmC,MAAR,CAAe,OAAOoJ,UAAP,KAAsB,QAArC,EAA+C,6CAA/C;AAEA,QAAInI,OAAO,SAAX;AACA,QAAIoI,GAAG,GAAGxH,MAAV;;AAEA,WAAOf,IAAI,CAACxB,MAAL,GAAc,CAArB,EAAwB;AACpB2B,MAAAA,OAAO,GAAGH,IAAI,CAACwI,KAAL,EAAV;;AACA,UAAI,CAACD,GAAG,CAACpI,OAAD,CAAR,EAAmB;AACfoI,QAAAA,GAAG,CAACpI,OAAD,CAAH,GAAe,EAAf;AACH;;AACDoI,MAAAA,GAAG,GAAGA,GAAG,CAACpI,OAAD,CAAT;AACH;;AACDA,IAAAA,OAAO,GAAGH,IAAI,CAACwI,KAAL,EAAV;AACAD,IAAAA,GAAG,CAACpI,OAAD,CAAH,GAAepD,OAAO,CAAC+C,KAAR,CAAcf,MAAd,EAAsBuJ,UAAtB,EAAkC9I,OAAlC,CAAf;AACH;;AAED,SAAOuB,MAAP;AACH,CAtCD;;AAyCAhE,OAAO,CAAC0L,cAAR,GAAyB,UAAUzI,IAAV,EAAgB0I,SAAhB,EAA2B;AAEhD,MAAIA,SAAJ,EAAe;AACXA,IAAAA,SAAS,GAAGA,SAAS,CAAC,CAAD,CAAT,KAAiB,GAAjB,GAAuB,MAAMA,SAA7B,GAAyCA,SAArD;AACH,GAFD,MAGK;AACDA,IAAAA,SAAS,GAAG,EAAZ;AACH;;AAED1I,EAAAA,IAAI,GAAGrD,IAAI,CAACgM,OAAL,CAAa3I,IAAb,CAAP;AACA,MAAM4I,IAAI,GAAG,CAAChL,IAAI,CAAC4I,GAAL,EAAD,EAAaf,OAAO,CAACoD,GAArB,EAA0BpM,MAAM,CAACqM,WAAP,CAAmB,CAAnB,EAAsBlI,QAAtB,CAA+B,KAA/B,CAA1B,EAAiEgF,IAAjE,CAAsE,GAAtE,IAA6E8C,SAA1F;AACA,SAAO/L,IAAI,CAACiJ,IAAL,CAAU5F,IAAV,EAAgB4I,IAAhB,CAAP;AACH,CAZD;;AAeA7L,OAAO,CAACqJ,SAAR,GAAoB,YAAY;AAE5B,MAAI;AACA,WAAO2C,IAAI,CAAC3C,SAAL,CAAesB,KAAf,CAAqB,IAArB,EAA2BvF,SAA3B,CAAP;AACH,GAFD,CAGA,OAAO6G,GAAP,EAAY;AACR,WAAO,6BAA6BA,GAAG,CAACzD,OAAjC,GAA2C,GAAlD;AACH;AACJ,CARD;;AAWAxI,OAAO,CAACkM,OAAR,GAAkB,UAAUlK,MAAV,EAAkB;AAEhC,MAAMD,MAAM,GAAG,EAAf;AACA,MAAMT,IAAI,GAAGL,MAAM,CAACK,IAAP,CAAYU,MAAZ,CAAb;;AACA,OAAK,IAAIR,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,IAAI,CAACG,MAAzB,EAAiC,EAAED,CAAnC,EAAsC;AAClC,QAAME,GAAG,GAAGJ,IAAI,CAACE,CAAD,CAAhB;AACAO,IAAAA,MAAM,CAACL,GAAD,CAAN,GAAcM,MAAM,CAACN,GAAD,CAApB;AACH;;AAED,SAAOK,MAAP;AACH,CAVD","sourcesContent":["'use strict';\n\n// Load modules\n\nconst Crypto = require('crypto');\nconst Path = require('path');\nconst Util = require('util');\nconst Escape = require('./escape');\n\n\n// Declare internals\n\nconst internals = {};\n\n\n// Clone object or array\n\nexports.clone = function (obj, seen) {\n\n    if (typeof obj !== 'object' ||\n        obj === null) {\n\n        return obj;\n    }\n\n    seen = seen || new Map();\n\n    const lookup = seen.get(obj);\n    if (lookup) {\n        return lookup;\n    }\n\n    let newObj;\n    let cloneDeep = false;\n\n    if (!Array.isArray(obj)) {\n        if (Buffer.isBuffer(obj)) {\n            newObj = new Buffer(obj);\n        }\n        else if (obj instanceof Date) {\n            newObj = new Date(obj.getTime());\n        }\n        else if (obj instanceof RegExp) {\n            newObj = new RegExp(obj);\n        }\n        else {\n            const proto = Object.getPrototypeOf(obj);\n            if (proto &&\n                proto.isImmutable) {\n\n                newObj = obj;\n            }\n            else {\n                newObj = Object.create(proto);\n                cloneDeep = true;\n            }\n        }\n    }\n    else {\n        newObj = [];\n        cloneDeep = true;\n    }\n\n    seen.set(obj, newObj);\n\n    if (cloneDeep) {\n        const keys = Object.getOwnPropertyNames(obj);\n        for (let i = 0; i < keys.length; ++i) {\n            const key = keys[i];\n            const descriptor = Object.getOwnPropertyDescriptor(obj, key);\n            if (descriptor &&\n                (descriptor.get ||\n                 descriptor.set)) {\n\n                Object.defineProperty(newObj, key, descriptor);\n            }\n            else {\n                newObj[key] = exports.clone(obj[key], seen);\n            }\n        }\n    }\n\n    return newObj;\n};\n\n\n// Merge all the properties of source into target, source wins in conflict, and by default null and undefined from source are applied\n\n/*eslint-disable */\nexports.merge = function (target, source, isNullOverride /* = true */, isMergeArrays /* = true */) {\n/*eslint-enable */\n\n    exports.assert(target && typeof target === 'object', 'Invalid target value: must be an object');\n    exports.assert(source === null || source === undefined || typeof source === 'object', 'Invalid source value: must be null, undefined, or an object');\n\n    if (!source) {\n        return target;\n    }\n\n    if (Array.isArray(source)) {\n        exports.assert(Array.isArray(target), 'Cannot merge array onto an object');\n        if (isMergeArrays === false) {                                                  // isMergeArrays defaults to true\n            target.length = 0;                                                          // Must not change target assignment\n        }\n\n        for (let i = 0; i < source.length; ++i) {\n            target.push(exports.clone(source[i]));\n        }\n\n        return target;\n    }\n\n    const keys = Object.keys(source);\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i];\n        if (key === '__proto__') {\n            continue;\n        }\n\n        const value = source[key];\n        if (value &&\n            typeof value === 'object') {\n\n            if (!target[key] ||\n                typeof target[key] !== 'object' ||\n                (Array.isArray(target[key]) !== Array.isArray(value)) ||\n                value instanceof Date ||\n                Buffer.isBuffer(value) ||\n                value instanceof RegExp) {\n\n                target[key] = exports.clone(value);\n            }\n            else {\n                exports.merge(target[key], value, isNullOverride, isMergeArrays);\n            }\n        }\n        else {\n            if (value !== null &&\n                value !== undefined) {                              // Explicit to preserve empty strings\n\n                target[key] = value;\n            }\n            else if (isNullOverride !== false) {                    // Defaults to true\n                target[key] = value;\n            }\n        }\n    }\n\n    return target;\n};\n\n\n// Apply options to a copy of the defaults\n\nexports.applyToDefaults = function (defaults, options, isNullOverride) {\n\n    exports.assert(defaults && typeof defaults === 'object', 'Invalid defaults value: must be an object');\n    exports.assert(!options || options === true || typeof options === 'object', 'Invalid options value: must be true, falsy or an object');\n\n    if (!options) {                                                 // If no options, return null\n        return null;\n    }\n\n    const copy = exports.clone(defaults);\n\n    if (options === true) {                                         // If options is set to true, use defaults\n        return copy;\n    }\n\n    return exports.merge(copy, options, isNullOverride === true, false);\n};\n\n\n// Clone an object except for the listed keys which are shallow copied\n\nexports.cloneWithShallow = function (source, keys) {\n\n    if (!source ||\n        typeof source !== 'object') {\n\n        return source;\n    }\n\n    const storage = internals.store(source, keys);    // Move shallow copy items to storage\n    const copy = exports.clone(source);               // Deep copy the rest\n    internals.restore(copy, source, storage);       // Shallow copy the stored items and restore\n    return copy;\n};\n\n\ninternals.store = function (source, keys) {\n\n    const storage = {};\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i];\n        const value = exports.reach(source, key);\n        if (value !== undefined) {\n            storage[key] = value;\n            internals.reachSet(source, key, undefined);\n        }\n    }\n\n    return storage;\n};\n\n\ninternals.restore = function (copy, source, storage) {\n\n    const keys = Object.keys(storage);\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i];\n        internals.reachSet(copy, key, storage[key]);\n        internals.reachSet(source, key, storage[key]);\n    }\n};\n\n\ninternals.reachSet = function (obj, key, value) {\n\n    const path = key.split('.');\n    let ref = obj;\n    for (let i = 0; i < path.length; ++i) {\n        const segment = path[i];\n        if (i + 1 === path.length) {\n            ref[segment] = value;\n        }\n\n        ref = ref[segment];\n    }\n};\n\n\n// Apply options to defaults except for the listed keys which are shallow copied from option without merging\n\nexports.applyToDefaultsWithShallow = function (defaults, options, keys) {\n\n    exports.assert(defaults && typeof defaults === 'object', 'Invalid defaults value: must be an object');\n    exports.assert(!options || options === true || typeof options === 'object', 'Invalid options value: must be true, falsy or an object');\n    exports.assert(keys && Array.isArray(keys), 'Invalid keys');\n\n    if (!options) {                                                 // If no options, return null\n        return null;\n    }\n\n    const copy = exports.cloneWithShallow(defaults, keys);\n\n    if (options === true) {                                         // If options is set to true, use defaults\n        return copy;\n    }\n\n    const storage = internals.store(options, keys);   // Move shallow copy items to storage\n    exports.merge(copy, options, false, false);     // Deep copy the rest\n    internals.restore(copy, options, storage);      // Shallow copy the stored items and restore\n    return copy;\n};\n\n\n// Deep object or array comparison\n\nexports.deepEqual = function (obj, ref, options, seen) {\n\n    options = options || { prototype: true };\n\n    const type = typeof obj;\n\n    if (type !== typeof ref) {\n        return false;\n    }\n\n    if (type !== 'object' ||\n        obj === null ||\n        ref === null) {\n\n        if (obj === ref) {                                                      // Copied from Deep-eql, copyright(c) 2013 Jake Luer, jake@alogicalparadox.com, MIT Licensed, https://github.com/chaijs/deep-eql\n            return obj !== 0 || 1 / obj === 1 / ref;        // -0 / +0\n        }\n\n        return obj !== obj && ref !== ref;                  // NaN\n    }\n\n    seen = seen || [];\n    if (seen.indexOf(obj) !== -1) {\n        return true;                            // If previous comparison failed, it would have stopped execution\n    }\n\n    seen.push(obj);\n\n    if (Array.isArray(obj)) {\n        if (!Array.isArray(ref)) {\n            return false;\n        }\n\n        if (!options.part && obj.length !== ref.length) {\n            return false;\n        }\n\n        for (let i = 0; i < obj.length; ++i) {\n            if (options.part) {\n                let found = false;\n                for (let j = 0; j < ref.length; ++j) {\n                    if (exports.deepEqual(obj[i], ref[j], options)) {\n                        found = true;\n                        break;\n                    }\n                }\n\n                return found;\n            }\n\n            if (!exports.deepEqual(obj[i], ref[i], options)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    if (Buffer.isBuffer(obj)) {\n        if (!Buffer.isBuffer(ref)) {\n            return false;\n        }\n\n        if (obj.length !== ref.length) {\n            return false;\n        }\n\n        for (let i = 0; i < obj.length; ++i) {\n            if (obj[i] !== ref[i]) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    if (obj instanceof Date) {\n        return (ref instanceof Date && obj.getTime() === ref.getTime());\n    }\n\n    if (obj instanceof RegExp) {\n        return (ref instanceof RegExp && obj.toString() === ref.toString());\n    }\n\n    if (options.prototype) {\n        if (Object.getPrototypeOf(obj) !== Object.getPrototypeOf(ref)) {\n            return false;\n        }\n    }\n\n    const keys = Object.getOwnPropertyNames(obj);\n\n    if (!options.part && keys.length !== Object.getOwnPropertyNames(ref).length) {\n        return false;\n    }\n\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i];\n        const descriptor = Object.getOwnPropertyDescriptor(obj, key);\n        if (descriptor.get) {\n            if (!exports.deepEqual(descriptor, Object.getOwnPropertyDescriptor(ref, key), options, seen)) {\n                return false;\n            }\n        }\n        else if (!exports.deepEqual(obj[key], ref[key], options, seen)) {\n            return false;\n        }\n    }\n\n    return true;\n};\n\n\n// Remove duplicate items from array\n\nexports.unique = (array, key) => {\n\n    let result;\n    if (key) {\n        result = [];\n        const index = new Set();\n        array.forEach((item) => {\n\n            const identifier = item[key];\n            if (!index.has(identifier)) {\n                index.add(identifier);\n                result.push(item);\n            }\n        });\n    }\n    else {\n        result = Array.from(new Set(array));\n    }\n\n    return result;\n};\n\n\n// Convert array into object\n\nexports.mapToObject = function (array, key) {\n\n    if (!array) {\n        return null;\n    }\n\n    const obj = {};\n    for (let i = 0; i < array.length; ++i) {\n        if (key) {\n            if (array[i][key]) {\n                obj[array[i][key]] = true;\n            }\n        }\n        else {\n            obj[array[i]] = true;\n        }\n    }\n\n    return obj;\n};\n\n\n// Find the common unique items in two arrays\n\nexports.intersect = function (array1, array2, justFirst) {\n\n    if (!array1 || !array2) {\n        return [];\n    }\n\n    const common = [];\n    const hash = (Array.isArray(array1) ? exports.mapToObject(array1) : array1);\n    const found = {};\n    for (let i = 0; i < array2.length; ++i) {\n        if (hash[array2[i]] && !found[array2[i]]) {\n            if (justFirst) {\n                return array2[i];\n            }\n\n            common.push(array2[i]);\n            found[array2[i]] = true;\n        }\n    }\n\n    return (justFirst ? null : common);\n};\n\n\n// Test if the reference contains the values\n\nexports.contain = function (ref, values, options) {\n\n    /*\n        string -> string(s)\n        array -> item(s)\n        object -> key(s)\n        object -> object (key:value)\n    */\n\n    let valuePairs = null;\n    if (typeof ref === 'object' &&\n        typeof values === 'object' &&\n        !Array.isArray(ref) &&\n        !Array.isArray(values)) {\n\n        valuePairs = values;\n        values = Object.keys(values);\n    }\n    else {\n        values = [].concat(values);\n    }\n\n    options = options || {};            // deep, once, only, part\n\n    exports.assert(arguments.length >= 2, 'Insufficient arguments');\n    exports.assert(typeof ref === 'string' || typeof ref === 'object', 'Reference must be string or an object');\n    exports.assert(values.length, 'Values array cannot be empty');\n\n    let compare;\n    let compareFlags;\n    if (options.deep) {\n        compare = exports.deepEqual;\n\n        const hasOnly = options.hasOwnProperty('only');\n        const hasPart = options.hasOwnProperty('part');\n\n        compareFlags = {\n            prototype: hasOnly ? options.only : hasPart ? !options.part : false,\n            part: hasOnly ? !options.only : hasPart ? options.part : true\n        };\n    }\n    else {\n        compare = (a, b) => a === b;\n    }\n\n    let misses = false;\n    const matches = new Array(values.length);\n    for (let i = 0; i < matches.length; ++i) {\n        matches[i] = 0;\n    }\n\n    if (typeof ref === 'string') {\n        let pattern = '(';\n        for (let i = 0; i < values.length; ++i) {\n            const value = values[i];\n            exports.assert(typeof value === 'string', 'Cannot compare string reference to non-string value');\n            pattern += (i ? '|' : '') + exports.escapeRegex(value);\n        }\n\n        const regex = new RegExp(pattern + ')', 'g');\n        const leftovers = ref.replace(regex, ($0, $1) => {\n\n            const index = values.indexOf($1);\n            ++matches[index];\n            return '';          // Remove from string\n        });\n\n        misses = !!leftovers;\n    }\n    else if (Array.isArray(ref)) {\n        for (let i = 0; i < ref.length; ++i) {\n            let matched = false;\n            for (let j = 0; j < values.length && matched === false; ++j) {\n                matched = compare(values[j], ref[i], compareFlags) && j;\n            }\n\n            if (matched !== false) {\n                ++matches[matched];\n            }\n            else {\n                misses = true;\n            }\n        }\n    }\n    else {\n        const keys = Object.getOwnPropertyNames(ref);\n        for (let i = 0; i < keys.length; ++i) {\n            const key = keys[i];\n            const pos = values.indexOf(key);\n            if (pos !== -1) {\n                if (valuePairs &&\n                    !compare(valuePairs[key], ref[key], compareFlags)) {\n\n                    return false;\n                }\n\n                ++matches[pos];\n            }\n            else {\n                misses = true;\n            }\n        }\n    }\n\n    let result = false;\n    for (let i = 0; i < matches.length; ++i) {\n        result = result || !!matches[i];\n        if ((options.once && matches[i] > 1) ||\n            (!options.part && !matches[i])) {\n\n            return false;\n        }\n    }\n\n    if (options.only &&\n        misses) {\n\n        return false;\n    }\n\n    return result;\n};\n\n\n// Flatten array\n\nexports.flatten = function (array, target) {\n\n    const result = target || [];\n\n    for (let i = 0; i < array.length; ++i) {\n        if (Array.isArray(array[i])) {\n            exports.flatten(array[i], result);\n        }\n        else {\n            result.push(array[i]);\n        }\n    }\n\n    return result;\n};\n\n\n// Convert an object key chain string ('a.b.c') to reference (object[a][b][c])\n\nexports.reach = function (obj, chain, options) {\n\n    if (chain === false ||\n        chain === null ||\n        typeof chain === 'undefined') {\n\n        return obj;\n    }\n\n    options = options || {};\n    if (typeof options === 'string') {\n        options = { separator: options };\n    }\n\n    const path = chain.split(options.separator || '.');\n    let ref = obj;\n    for (let i = 0; i < path.length; ++i) {\n        let key = path[i];\n        if (key[0] === '-' && Array.isArray(ref)) {\n            key = key.slice(1, key.length);\n            key = ref.length - key;\n        }\n\n        if (!ref ||\n            !((typeof ref === 'object' || typeof ref === 'function') && key in ref) ||\n            (typeof ref !== 'object' && options.functions === false)) {         // Only object and function can have properties\n\n            exports.assert(!options.strict || i + 1 === path.length, 'Missing segment', key, 'in reach path ', chain);\n            exports.assert(typeof ref === 'object' || options.functions === true || typeof ref !== 'function', 'Invalid segment', key, 'in reach path ', chain);\n            ref = options.default;\n            break;\n        }\n\n        ref = ref[key];\n    }\n\n    return ref;\n};\n\n\nexports.reachTemplate = function (obj, template, options) {\n\n    return template.replace(/{([^}]+)}/g, ($0, chain) => {\n\n        const value = exports.reach(obj, chain, options);\n        return (value === undefined || value === null ? '' : value);\n    });\n};\n\n\nexports.formatStack = function (stack) {\n\n    const trace = [];\n    for (let i = 0; i < stack.length; ++i) {\n        const item = stack[i];\n        trace.push([item.getFileName(), item.getLineNumber(), item.getColumnNumber(), item.getFunctionName(), item.isConstructor()]);\n    }\n\n    return trace;\n};\n\n\nexports.formatTrace = function (trace) {\n\n    const display = [];\n\n    for (let i = 0; i < trace.length; ++i) {\n        const row = trace[i];\n        display.push((row[4] ? 'new ' : '') + row[3] + ' (' + row[0] + ':' + row[1] + ':' + row[2] + ')');\n    }\n\n    return display;\n};\n\n\nexports.callStack = function (slice) {\n\n    // http://code.google.com/p/v8/wiki/JavaScriptStackTraceApi\n\n    const v8 = Error.prepareStackTrace;\n    Error.prepareStackTrace = function (_, stack) {\n\n        return stack;\n    };\n\n    const capture = {};\n    Error.captureStackTrace(capture, this);     // arguments.callee is not supported in strict mode so we use this and slice the trace of this off the result\n    const stack = capture.stack;\n\n    Error.prepareStackTrace = v8;\n\n    const trace = exports.formatStack(stack);\n\n    return trace.slice(1 + slice);\n};\n\n\nexports.displayStack = function (slice) {\n\n    const trace = exports.callStack(slice === undefined ? 1 : slice + 1);\n\n    return exports.formatTrace(trace);\n};\n\n\nexports.abortThrow = false;\n\n\nexports.abort = function (message, hideStack) {\n\n    if (process.env.NODE_ENV === 'test' || exports.abortThrow === true) {\n        throw new Error(message || 'Unknown error');\n    }\n\n    let stack = '';\n    if (!hideStack) {\n        stack = exports.displayStack(1).join('\\n\\t');\n    }\n    console.log('ABORT: ' + message + '\\n\\t' + stack);\n    process.exit(1);\n};\n\n\nexports.assert = function (condition /*, msg1, msg2, msg3 */) {\n\n    if (condition) {\n        return;\n    }\n\n    if (arguments.length === 2 && arguments[1] instanceof Error) {\n        throw arguments[1];\n    }\n\n    let msgs = [];\n    for (let i = 1; i < arguments.length; ++i) {\n        if (arguments[i] !== '') {\n            msgs.push(arguments[i]);            // Avoids Array.slice arguments leak, allowing for V8 optimizations\n        }\n    }\n\n    msgs = msgs.map((msg) => {\n\n        return typeof msg === 'string' ? msg : msg instanceof Error ? msg.message : exports.stringify(msg);\n    });\n\n    throw new Error(msgs.join(' ') || 'Unknown error');\n};\n\n\nexports.Timer = function () {\n\n    this.ts = 0;\n    this.reset();\n};\n\n\nexports.Timer.prototype.reset = function () {\n\n    this.ts = Date.now();\n};\n\n\nexports.Timer.prototype.elapsed = function () {\n\n    return Date.now() - this.ts;\n};\n\n\nexports.Bench = function () {\n\n    this.ts = 0;\n    this.reset();\n};\n\n\nexports.Bench.prototype.reset = function () {\n\n    this.ts = exports.Bench.now();\n};\n\n\nexports.Bench.prototype.elapsed = function () {\n\n    return exports.Bench.now() - this.ts;\n};\n\n\nexports.Bench.now = function () {\n\n    const ts = process.hrtime();\n    return (ts[0] * 1e3) + (ts[1] / 1e6);\n};\n\n\n// Escape string for Regex construction\n\nexports.escapeRegex = function (string) {\n\n    // Escape ^$.*+-?=!:|\\/()[]{},\n    return string.replace(/[\\^\\$\\.\\*\\+\\-\\?\\=\\!\\:\\|\\\\\\/\\(\\)\\[\\]\\{\\}\\,]/g, '\\\\$&');\n};\n\n\n// Base64url (RFC 4648) encode\n\nexports.base64urlEncode = function (value, encoding) {\n\n    exports.assert(typeof value === 'string' || Buffer.isBuffer(value), 'value must be string or buffer');\n    const buf = (Buffer.isBuffer(value) ? value : new Buffer(value, encoding || 'binary'));\n    return buf.toString('base64').replace(/\\+/g, '-').replace(/\\//g, '_').replace(/\\=/g, '');\n};\n\n\n// Base64url (RFC 4648) decode\n\nexports.base64urlDecode = function (value, encoding) {\n\n    if (typeof value !== 'string') {\n\n        return new Error('Value not a string');\n    }\n\n    if (!/^[\\w\\-]*$/.test(value)) {\n\n        return new Error('Invalid character');\n    }\n\n    const buf = new Buffer(value, 'base64');\n    return (encoding === 'buffer' ? buf : buf.toString(encoding || 'binary'));\n};\n\n\n// Escape attribute value for use in HTTP header\n\nexports.escapeHeaderAttribute = function (attribute) {\n\n    // Allowed value characters: !#$%&'()*+,-./:;<=>?@[]^_`{|}~ and space, a-z, A-Z, 0-9, \\, \"\n\n    exports.assert(/^[ \\w\\!#\\$%&'\\(\\)\\*\\+,\\-\\.\\/\\:;<\\=>\\?@\\[\\]\\^`\\{\\|\\}~\\\"\\\\]*$/.test(attribute), 'Bad attribute value (' + attribute + ')');\n\n    return attribute.replace(/\\\\/g, '\\\\\\\\').replace(/\\\"/g, '\\\\\"');                             // Escape quotes and slash\n};\n\n\nexports.escapeHtml = function (string) {\n\n    return Escape.escapeHtml(string);\n};\n\n\nexports.escapeJavaScript = function (string) {\n\n    return Escape.escapeJavaScript(string);\n};\n\nexports.escapeJson = function (string) {\n\n    return Escape.escapeJson(string);\n};\n\nexports.nextTick = function (callback) {\n\n    return function () {\n\n        const args = arguments;\n        process.nextTick(() => {\n\n            callback.apply(null, args);\n        });\n    };\n};\n\n\nexports.once = function (method) {\n\n    if (method._hoekOnce) {\n        return method;\n    }\n\n    let once = false;\n    const wrapped = function () {\n\n        if (!once) {\n            once = true;\n            method.apply(null, arguments);\n        }\n    };\n\n    wrapped._hoekOnce = true;\n\n    return wrapped;\n};\n\n\nexports.isInteger = Number.isSafeInteger;\n\n\nexports.ignore = function () { };\n\n\nexports.inherits = Util.inherits;\n\n\nexports.format = Util.format;\n\n\nexports.transform = function (source, transform, options) {\n\n    exports.assert(source === null || source === undefined || typeof source === 'object' || Array.isArray(source), 'Invalid source object: must be null, undefined, an object, or an array');\n    const separator = (typeof options === 'object' && options !== null) ? (options.separator || '.') : '.';\n\n    if (Array.isArray(source)) {\n        const results = [];\n        for (let i = 0; i < source.length; ++i) {\n            results.push(exports.transform(source[i], transform, options));\n        }\n        return results;\n    }\n\n    const result = {};\n    const keys = Object.keys(transform);\n\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i];\n        const path = key.split(separator);\n        const sourcePath = transform[key];\n\n        exports.assert(typeof sourcePath === 'string', 'All mappings must be \".\" delineated strings');\n\n        let segment;\n        let res = result;\n\n        while (path.length > 1) {\n            segment = path.shift();\n            if (!res[segment]) {\n                res[segment] = {};\n            }\n            res = res[segment];\n        }\n        segment = path.shift();\n        res[segment] = exports.reach(source, sourcePath, options);\n    }\n\n    return result;\n};\n\n\nexports.uniqueFilename = function (path, extension) {\n\n    if (extension) {\n        extension = extension[0] !== '.' ? '.' + extension : extension;\n    }\n    else {\n        extension = '';\n    }\n\n    path = Path.resolve(path);\n    const name = [Date.now(), process.pid, Crypto.randomBytes(8).toString('hex')].join('-') + extension;\n    return Path.join(path, name);\n};\n\n\nexports.stringify = function () {\n\n    try {\n        return JSON.stringify.apply(null, arguments);\n    }\n    catch (err) {\n        return '[Cannot display object: ' + err.message + ']';\n    }\n};\n\n\nexports.shallow = function (source) {\n\n    const target = {};\n    const keys = Object.keys(source);\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i];\n        target[key] = source[key];\n    }\n\n    return target;\n};\n"]},"metadata":{},"sourceType":"script"}