{"ast":null,"code":"'use strict'; // Load modules\n\nvar _classCallCheck = require(\"/home/cloudmynds/Desktop/admin/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/cloudmynds/Desktop/admin/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _get = require(\"/home/cloudmynds/Desktop/admin/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"/home/cloudmynds/Desktop/admin/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/home/cloudmynds/Desktop/admin/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/home/cloudmynds/Desktop/admin/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar Hoek = require('hoek');\n\nvar Any = require('../any');\n\nvar Cast = require('../../cast');\n\nvar Ref = require('../../ref'); // Declare internals\n\n\nvar internals = {};\n\ninternals.Alternatives = /*#__PURE__*/function (_Any) {\n  _inherits(_class, _Any);\n\n  var _super = _createSuper(_class);\n\n  function _class() {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    _this = _super.call(this);\n    _this._type = 'alternatives';\n\n    _this._invalids.remove(null);\n\n    _this._inner.matches = [];\n    return _this;\n  }\n\n  _createClass(_class, [{\n    key: \"_init\",\n    value: function _init() {\n      return arguments.length ? this.try.apply(this, arguments) : this;\n    }\n  }, {\n    key: \"_base\",\n    value: function _base(value, state, options) {\n      var errors = [];\n      var il = this._inner.matches.length;\n      var baseType = this._baseType;\n\n      for (var i = 0; i < il; ++i) {\n        var item = this._inner.matches[i];\n\n        if (!item.schema) {\n          var schema = item.peek || item.is;\n          var input = item.is ? item.ref(state.reference || state.parent, options) : value;\n\n          var failed = schema._validate(input, null, options, state.parent).errors;\n\n          if (failed) {\n            if (item.otherwise) {\n              return item.otherwise._validate(value, state, options);\n            }\n          } else if (item.then) {\n            return item.then._validate(value, state, options);\n          }\n\n          if (i === il - 1 && baseType) {\n            return baseType._validate(value, state, options);\n          }\n\n          continue;\n        }\n\n        var result = item.schema._validate(value, state, options);\n\n        if (!result.errors) {\n          // Found a valid match\n          return result;\n        }\n\n        errors = errors.concat(result.errors);\n      }\n\n      if (errors.length) {\n        return {\n          errors: this.createError('alternatives.child', {\n            reason: errors\n          }, state, options)\n        };\n      }\n\n      return {\n        errors: this.createError('alternatives.base', null, state, options)\n      };\n    }\n  }, {\n    key: \"try\",\n    value: function _try() {\n      for (var _len = arguments.length, schemas = new Array(_len), _key = 0; _key < _len; _key++) {\n        schemas[_key] = arguments[_key];\n      }\n\n      schemas = Hoek.flatten(schemas);\n      Hoek.assert(schemas.length, 'Cannot add other alternatives without at least one schema');\n      var obj = this.clone();\n\n      for (var i = 0; i < schemas.length; ++i) {\n        var cast = Cast.schema(this._currentJoi, schemas[i]);\n\n        if (cast._refs.length) {\n          obj._refs = obj._refs.concat(cast._refs);\n        }\n\n        obj._inner.matches.push({\n          schema: cast\n        });\n      }\n\n      return obj;\n    }\n  }, {\n    key: \"when\",\n    value: function when(condition, options) {\n      var schemaCondition = false;\n      Hoek.assert(Ref.isRef(condition) || typeof condition === 'string' || (schemaCondition = condition instanceof Any), 'Invalid condition:', condition);\n      Hoek.assert(options, 'Missing options');\n      Hoek.assert(typeof options === 'object', 'Invalid options');\n\n      if (schemaCondition) {\n        Hoek.assert(!options.hasOwnProperty('is'), '\"is\" can not be used with a schema condition');\n      } else {\n        Hoek.assert(options.hasOwnProperty('is'), 'Missing \"is\" directive');\n      }\n\n      Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \"then\" or \"otherwise\"');\n      var obj = this.clone();\n      var is;\n\n      if (!schemaCondition) {\n        is = Cast.schema(this._currentJoi, options.is);\n\n        if (options.is === null || !(Ref.isRef(options.is) || options.is instanceof Any)) {\n          // Only apply required if this wasn't already a schema or a ref, we'll suppose people know what they're doing\n          is = is.required();\n        }\n      }\n\n      var item = {\n        ref: schemaCondition ? null : Cast.ref(condition),\n        peek: schemaCondition ? condition : null,\n        is: is,\n        then: options.then !== undefined ? Cast.schema(this._currentJoi, options.then) : undefined,\n        otherwise: options.otherwise !== undefined ? Cast.schema(this._currentJoi, options.otherwise) : undefined\n      };\n\n      if (obj._baseType) {\n        item.then = item.then && obj._baseType.concat(item.then);\n        item.otherwise = item.otherwise && obj._baseType.concat(item.otherwise);\n      }\n\n      if (!schemaCondition) {\n        Ref.push(obj._refs, item.ref);\n        obj._refs = obj._refs.concat(item.is._refs);\n      }\n\n      if (item.then && item.then._refs) {\n        obj._refs = obj._refs.concat(item.then._refs);\n      }\n\n      if (item.otherwise && item.otherwise._refs) {\n        obj._refs = obj._refs.concat(item.otherwise._refs);\n      }\n\n      obj._inner.matches.push(item);\n\n      return obj;\n    }\n  }, {\n    key: \"describe\",\n    value: function describe() {\n      var description = _get(_getPrototypeOf(_class.prototype), \"describe\", this).call(this);\n\n      var alternatives = [];\n\n      for (var i = 0; i < this._inner.matches.length; ++i) {\n        var item = this._inner.matches[i];\n\n        if (item.schema) {\n          // try()\n          alternatives.push(item.schema.describe());\n        } else {\n          // when()\n          var when = item.is ? {\n            ref: item.ref.toString(),\n            is: item.is.describe()\n          } : {\n            peek: item.peek.describe()\n          };\n\n          if (item.then) {\n            when.then = item.then.describe();\n          }\n\n          if (item.otherwise) {\n            when.otherwise = item.otherwise.describe();\n          }\n\n          alternatives.push(when);\n        }\n      }\n\n      description.alternatives = alternatives;\n      return description;\n    }\n  }]);\n\n  return _class;\n}(Any);\n\nmodule.exports = new internals.Alternatives();","map":{"version":3,"sources":["/home/cloudmynds/Desktop/admin/node_modules/joi/lib/types/alternatives/index.js"],"names":["Hoek","require","Any","Cast","Ref","internals","Alternatives","_type","_invalids","remove","_inner","matches","length","try","value","state","options","errors","il","baseType","_baseType","i","item","schema","peek","is","input","ref","reference","parent","failed","_validate","otherwise","then","result","concat","createError","reason","schemas","flatten","assert","obj","clone","cast","_currentJoi","_refs","push","condition","schemaCondition","isRef","hasOwnProperty","undefined","required","description","alternatives","describe","when","toString","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\n// Load modules\n\nconst Hoek = require('hoek');\nconst Any = require('../any');\nconst Cast = require('../../cast');\nconst Ref = require('../../ref');\n\n\n// Declare internals\n\nconst internals = {};\n\n\ninternals.Alternatives = class extends Any {\n\n    constructor() {\n\n        super();\n        this._type = 'alternatives';\n        this._invalids.remove(null);\n        this._inner.matches = [];\n    }\n\n    _init(...args) {\n\n        return args.length ? this.try(...args) : this;\n    }\n\n    _base(value, state, options) {\n\n        let errors = [];\n        const il = this._inner.matches.length;\n        const baseType = this._baseType;\n\n        for (let i = 0; i < il; ++i) {\n            const item = this._inner.matches[i];\n            if (!item.schema) {\n                const schema = item.peek || item.is;\n                const input = item.is ? item.ref(state.reference || state.parent, options) : value;\n                const failed = schema._validate(input, null, options, state.parent).errors;\n\n                if (failed) {\n                    if (item.otherwise) {\n                        return item.otherwise._validate(value, state, options);\n                    }\n                }\n                else if (item.then) {\n                    return item.then._validate(value, state, options);\n                }\n\n                if (i === (il - 1) && baseType) {\n                    return baseType._validate(value, state, options);\n                }\n\n                continue;\n            }\n\n            const result = item.schema._validate(value, state, options);\n            if (!result.errors) {     // Found a valid match\n                return result;\n            }\n\n            errors = errors.concat(result.errors);\n        }\n\n        if (errors.length) {\n            return { errors: this.createError('alternatives.child', { reason: errors }, state, options) };\n        }\n\n        return { errors: this.createError('alternatives.base', null, state, options) };\n    }\n\n    try(...schemas) {\n\n        schemas = Hoek.flatten(schemas);\n        Hoek.assert(schemas.length, 'Cannot add other alternatives without at least one schema');\n\n        const obj = this.clone();\n\n        for (let i = 0; i < schemas.length; ++i) {\n            const cast = Cast.schema(this._currentJoi, schemas[i]);\n            if (cast._refs.length) {\n                obj._refs = obj._refs.concat(cast._refs);\n            }\n            obj._inner.matches.push({ schema: cast });\n        }\n\n        return obj;\n    }\n\n    when(condition, options) {\n\n        let schemaCondition = false;\n        Hoek.assert(Ref.isRef(condition) || typeof condition === 'string' || (schemaCondition = condition instanceof Any), 'Invalid condition:', condition);\n        Hoek.assert(options, 'Missing options');\n        Hoek.assert(typeof options === 'object', 'Invalid options');\n        if (schemaCondition) {\n            Hoek.assert(!options.hasOwnProperty('is'), '\"is\" can not be used with a schema condition');\n        }\n        else {\n            Hoek.assert(options.hasOwnProperty('is'), 'Missing \"is\" directive');\n        }\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \"then\" or \"otherwise\"');\n\n        const obj = this.clone();\n        let is;\n        if (!schemaCondition) {\n            is = Cast.schema(this._currentJoi, options.is);\n\n            if (options.is === null || !(Ref.isRef(options.is) || options.is instanceof Any)) {\n\n                // Only apply required if this wasn't already a schema or a ref, we'll suppose people know what they're doing\n                is = is.required();\n            }\n        }\n\n        const item = {\n            ref: schemaCondition ? null : Cast.ref(condition),\n            peek: schemaCondition ? condition : null,\n            is,\n            then: options.then !== undefined ? Cast.schema(this._currentJoi, options.then) : undefined,\n            otherwise: options.otherwise !== undefined ? Cast.schema(this._currentJoi, options.otherwise) : undefined\n        };\n\n        if (obj._baseType) {\n\n            item.then = item.then && obj._baseType.concat(item.then);\n            item.otherwise = item.otherwise && obj._baseType.concat(item.otherwise);\n        }\n\n        if (!schemaCondition) {\n            Ref.push(obj._refs, item.ref);\n            obj._refs = obj._refs.concat(item.is._refs);\n        }\n\n        if (item.then && item.then._refs) {\n            obj._refs = obj._refs.concat(item.then._refs);\n        }\n\n        if (item.otherwise && item.otherwise._refs) {\n            obj._refs = obj._refs.concat(item.otherwise._refs);\n        }\n\n        obj._inner.matches.push(item);\n\n        return obj;\n    }\n\n    describe() {\n\n        const description = super.describe();\n        const alternatives = [];\n        for (let i = 0; i < this._inner.matches.length; ++i) {\n            const item = this._inner.matches[i];\n            if (item.schema) {\n\n                // try()\n\n                alternatives.push(item.schema.describe());\n            }\n            else {\n\n                // when()\n\n                const when = item.is ? {\n                    ref: item.ref.toString(),\n                    is: item.is.describe()\n                } : {\n                    peek: item.peek.describe()\n                };\n\n                if (item.then) {\n                    when.then = item.then.describe();\n                }\n\n                if (item.otherwise) {\n                    when.otherwise = item.otherwise.describe();\n                }\n\n                alternatives.push(when);\n            }\n        }\n\n        description.alternatives = alternatives;\n        return description;\n    }\n\n};\n\n\nmodule.exports = new internals.Alternatives();\n"]},"metadata":{},"sourceType":"script"}