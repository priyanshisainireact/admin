{"ast":null,"code":"'use strict'; // Load modules\n\nvar Assert = require('assert');\n\nvar Crypto = require('crypto');\n\nvar Path = require('path');\n\nvar Util = require('util');\n\nvar Escape = require('./escape'); // Declare internals\n\n\nvar internals = {}; // Clone object or array\n\nexports.clone = function (obj, seen) {\n  if (typeof obj !== 'object' || obj === null) {\n    return obj;\n  }\n\n  seen = seen || new Map();\n  var lookup = seen.get(obj);\n\n  if (lookup) {\n    return lookup;\n  }\n\n  var newObj;\n  var cloneDeep = false;\n\n  if (!Array.isArray(obj)) {\n    if (Buffer.isBuffer(obj)) {\n      newObj = Buffer.from(obj);\n    } else if (obj instanceof Date) {\n      newObj = new Date(obj.getTime());\n    } else if (obj instanceof RegExp) {\n      newObj = new RegExp(obj);\n    } else {\n      var proto = Object.getPrototypeOf(obj);\n\n      if (proto && proto.isImmutable) {\n        newObj = obj;\n      } else {\n        newObj = Object.create(proto);\n        cloneDeep = true;\n      }\n    }\n  } else {\n    newObj = [];\n    cloneDeep = true;\n  }\n\n  seen.set(obj, newObj);\n\n  if (cloneDeep) {\n    var keys = Object.getOwnPropertyNames(obj);\n\n    for (var i = 0; i < keys.length; ++i) {\n      var key = keys[i];\n      var descriptor = Object.getOwnPropertyDescriptor(obj, key);\n\n      if (descriptor && (descriptor.get || descriptor.set)) {\n        Object.defineProperty(newObj, key, descriptor);\n      } else {\n        newObj[key] = exports.clone(obj[key], seen);\n      }\n    }\n  }\n\n  return newObj;\n}; // Merge all the properties of source into target, source wins in conflict, and by default null and undefined from source are applied\n\n/*eslint-disable */\n\n\nexports.merge = function (target, source, isNullOverride\n/* = true */\n, isMergeArrays\n/* = true */\n) {\n  /*eslint-enable */\n  exports.assert(target && typeof target === 'object', 'Invalid target value: must be an object');\n  exports.assert(source === null || source === undefined || typeof source === 'object', 'Invalid source value: must be null, undefined, or an object');\n\n  if (!source) {\n    return target;\n  }\n\n  if (Array.isArray(source)) {\n    exports.assert(Array.isArray(target), 'Cannot merge array onto an object');\n\n    if (isMergeArrays === false) {\n      // isMergeArrays defaults to true\n      target.length = 0; // Must not change target assignment\n    }\n\n    for (var i = 0; i < source.length; ++i) {\n      target.push(exports.clone(source[i]));\n    }\n\n    return target;\n  }\n\n  var keys = Object.keys(source);\n\n  for (var _i = 0; _i < keys.length; ++_i) {\n    var key = keys[_i];\n\n    if (key === '__proto__') {\n      continue;\n    }\n\n    var value = source[key];\n\n    if (value && typeof value === 'object') {\n      if (!target[key] || typeof target[key] !== 'object' || Array.isArray(target[key]) !== Array.isArray(value) || value instanceof Date || Buffer.isBuffer(value) || value instanceof RegExp) {\n        target[key] = exports.clone(value);\n      } else {\n        exports.merge(target[key], value, isNullOverride, isMergeArrays);\n      }\n    } else {\n      if (value !== null && value !== undefined) {\n        // Explicit to preserve empty strings\n        target[key] = value;\n      } else if (isNullOverride !== false) {\n        // Defaults to true\n        target[key] = value;\n      }\n    }\n  }\n\n  return target;\n}; // Apply options to a copy of the defaults\n\n\nexports.applyToDefaults = function (defaults, options, isNullOverride) {\n  exports.assert(defaults && typeof defaults === 'object', 'Invalid defaults value: must be an object');\n  exports.assert(!options || options === true || typeof options === 'object', 'Invalid options value: must be true, falsy or an object');\n\n  if (!options) {\n    // If no options, return null\n    return null;\n  }\n\n  var copy = exports.clone(defaults);\n\n  if (options === true) {\n    // If options is set to true, use defaults\n    return copy;\n  }\n\n  return exports.merge(copy, options, isNullOverride === true, false);\n}; // Clone an object except for the listed keys which are shallow copied\n\n\nexports.cloneWithShallow = function (source, keys) {\n  if (!source || typeof source !== 'object') {\n    return source;\n  }\n\n  var storage = internals.store(source, keys); // Move shallow copy items to storage\n\n  var copy = exports.clone(source); // Deep copy the rest\n\n  internals.restore(copy, source, storage); // Shallow copy the stored items and restore\n\n  return copy;\n};\n\ninternals.store = function (source, keys) {\n  var storage = {};\n\n  for (var i = 0; i < keys.length; ++i) {\n    var key = keys[i];\n    var value = exports.reach(source, key);\n\n    if (value !== undefined) {\n      storage[key] = value;\n      internals.reachSet(source, key, undefined);\n    }\n  }\n\n  return storage;\n};\n\ninternals.restore = function (copy, source, storage) {\n  var keys = Object.keys(storage);\n\n  for (var i = 0; i < keys.length; ++i) {\n    var key = keys[i];\n    internals.reachSet(copy, key, storage[key]);\n    internals.reachSet(source, key, storage[key]);\n  }\n};\n\ninternals.reachSet = function (obj, key, value) {\n  var path = key.split('.');\n  var ref = obj;\n\n  for (var i = 0; i < path.length; ++i) {\n    var segment = path[i];\n\n    if (i + 1 === path.length) {\n      ref[segment] = value;\n    }\n\n    ref = ref[segment];\n  }\n}; // Apply options to defaults except for the listed keys which are shallow copied from option without merging\n\n\nexports.applyToDefaultsWithShallow = function (defaults, options, keys) {\n  exports.assert(defaults && typeof defaults === 'object', 'Invalid defaults value: must be an object');\n  exports.assert(!options || options === true || typeof options === 'object', 'Invalid options value: must be true, falsy or an object');\n  exports.assert(keys && Array.isArray(keys), 'Invalid keys');\n\n  if (!options) {\n    // If no options, return null\n    return null;\n  }\n\n  var copy = exports.cloneWithShallow(defaults, keys);\n\n  if (options === true) {\n    // If options is set to true, use defaults\n    return copy;\n  }\n\n  var storage = internals.store(options, keys); // Move shallow copy items to storage\n\n  exports.merge(copy, options, false, false); // Deep copy the rest\n\n  internals.restore(copy, options, storage); // Shallow copy the stored items and restore\n\n  return copy;\n}; // Deep object or array comparison\n\n\nexports.deepEqual = function (obj, ref, options, seen) {\n  if (obj === ref) {\n    // Copied from Deep-eql, copyright(c) 2013 Jake Luer, jake@alogicalparadox.com, MIT Licensed, https://github.com/chaijs/deep-eql\n    return obj !== 0 || 1 / obj === 1 / ref; // -0 / +0\n  }\n\n  options = options || {\n    prototype: true\n  };\n  var type = typeof obj;\n\n  if (type !== typeof ref) {\n    return false;\n  }\n\n  if (type !== 'object' || obj === null || ref === null) {\n    return obj !== obj && ref !== ref; // NaN\n  }\n\n  seen = seen || [];\n\n  if (seen.indexOf(obj) !== -1) {\n    return true; // If previous comparison failed, it would have stopped execution\n  }\n\n  seen.push(obj);\n\n  if (Array.isArray(obj)) {\n    if (!Array.isArray(ref)) {\n      return false;\n    }\n\n    if (!options.part && obj.length !== ref.length) {\n      return false;\n    }\n\n    for (var i = 0; i < obj.length; ++i) {\n      if (options.part) {\n        var found = false;\n\n        for (var j = 0; j < ref.length; ++j) {\n          if (exports.deepEqual(obj[i], ref[j], options)) {\n            found = true;\n            break;\n          }\n        }\n\n        return found;\n      }\n\n      if (!exports.deepEqual(obj[i], ref[i], options)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  if (Buffer.isBuffer(obj)) {\n    if (!Buffer.isBuffer(ref)) {\n      return false;\n    }\n\n    if (obj.length !== ref.length) {\n      return false;\n    }\n\n    for (var _i2 = 0; _i2 < obj.length; ++_i2) {\n      if (obj[_i2] !== ref[_i2]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  if (obj instanceof Date) {\n    return ref instanceof Date && obj.getTime() === ref.getTime();\n  }\n\n  if (obj instanceof RegExp) {\n    return ref instanceof RegExp && obj.toString() === ref.toString();\n  }\n\n  if (options.prototype) {\n    if (Object.getPrototypeOf(obj) !== Object.getPrototypeOf(ref)) {\n      return false;\n    }\n  }\n\n  var keys = Object.getOwnPropertyNames(obj);\n\n  if (!options.part && keys.length !== Object.getOwnPropertyNames(ref).length) {\n    return false;\n  }\n\n  for (var _i3 = 0; _i3 < keys.length; ++_i3) {\n    var key = keys[_i3];\n    var descriptor = Object.getOwnPropertyDescriptor(obj, key);\n\n    if (descriptor.get) {\n      if (!exports.deepEqual(descriptor, Object.getOwnPropertyDescriptor(ref, key), options, seen)) {\n        return false;\n      }\n    } else if (!exports.deepEqual(obj[key], ref[key], options, seen)) {\n      return false;\n    }\n  }\n\n  return true;\n}; // Remove duplicate items from array\n\n\nexports.unique = function (array, key) {\n  var result;\n\n  if (key) {\n    result = [];\n    var index = new Set();\n    array.forEach(function (item) {\n      var identifier = item[key];\n\n      if (!index.has(identifier)) {\n        index.add(identifier);\n        result.push(item);\n      }\n    });\n  } else {\n    result = Array.from(new Set(array));\n  }\n\n  return result;\n}; // Convert array into object\n\n\nexports.mapToObject = function (array, key) {\n  if (!array) {\n    return null;\n  }\n\n  var obj = {};\n\n  for (var i = 0; i < array.length; ++i) {\n    if (key) {\n      if (array[i][key]) {\n        obj[array[i][key]] = true;\n      }\n    } else {\n      obj[array[i]] = true;\n    }\n  }\n\n  return obj;\n}; // Find the common unique items in two arrays\n\n\nexports.intersect = function (array1, array2, justFirst) {\n  if (!array1 || !array2) {\n    return [];\n  }\n\n  var common = [];\n  var hash = Array.isArray(array1) ? exports.mapToObject(array1) : array1;\n  var found = {};\n\n  for (var i = 0; i < array2.length; ++i) {\n    if (hash[array2[i]] && !found[array2[i]]) {\n      if (justFirst) {\n        return array2[i];\n      }\n\n      common.push(array2[i]);\n      found[array2[i]] = true;\n    }\n  }\n\n  return justFirst ? null : common;\n}; // Test if the reference contains the values\n\n\nexports.contain = function (ref, values, options) {\n  /*\n      string -> string(s)\n      array -> item(s)\n      object -> key(s)\n      object -> object (key:value)\n  */\n  var valuePairs = null;\n\n  if (typeof ref === 'object' && typeof values === 'object' && !Array.isArray(ref) && !Array.isArray(values)) {\n    valuePairs = values;\n    values = Object.keys(values);\n  } else {\n    values = [].concat(values);\n  }\n\n  options = options || {}; // deep, once, only, part\n\n  exports.assert(typeof ref === 'string' || typeof ref === 'object', 'Reference must be string or an object');\n  exports.assert(values.length, 'Values array cannot be empty');\n  var compare;\n  var compareFlags;\n\n  if (options.deep) {\n    compare = exports.deepEqual;\n    var hasOnly = options.hasOwnProperty('only');\n    var hasPart = options.hasOwnProperty('part');\n    compareFlags = {\n      prototype: hasOnly ? options.only : hasPart ? !options.part : false,\n      part: hasOnly ? !options.only : hasPart ? options.part : true\n    };\n  } else {\n    compare = function compare(a, b) {\n      return a === b;\n    };\n  }\n\n  var misses = false;\n  var matches = new Array(values.length);\n\n  for (var i = 0; i < matches.length; ++i) {\n    matches[i] = 0;\n  }\n\n  if (typeof ref === 'string') {\n    var pattern = '(';\n\n    for (var _i4 = 0; _i4 < values.length; ++_i4) {\n      var value = values[_i4];\n      exports.assert(typeof value === 'string', 'Cannot compare string reference to non-string value');\n      pattern += (_i4 ? '|' : '') + exports.escapeRegex(value);\n    }\n\n    var regex = new RegExp(pattern + ')', 'g');\n    var leftovers = ref.replace(regex, function ($0, $1) {\n      var index = values.indexOf($1);\n      ++matches[index];\n      return ''; // Remove from string\n    });\n    misses = !!leftovers;\n  } else if (Array.isArray(ref)) {\n    for (var _i5 = 0; _i5 < ref.length; ++_i5) {\n      var matched = false;\n\n      for (var j = 0; j < values.length && matched === false; ++j) {\n        matched = compare(values[j], ref[_i5], compareFlags) && j;\n      }\n\n      if (matched !== false) {\n        ++matches[matched];\n      } else {\n        misses = true;\n      }\n    }\n  } else {\n    var keys = Object.getOwnPropertyNames(ref);\n\n    for (var _i6 = 0; _i6 < keys.length; ++_i6) {\n      var key = keys[_i6];\n      var pos = values.indexOf(key);\n\n      if (pos !== -1) {\n        if (valuePairs && !compare(valuePairs[key], ref[key], compareFlags)) {\n          return false;\n        }\n\n        ++matches[pos];\n      } else {\n        misses = true;\n      }\n    }\n  }\n\n  var result = false;\n\n  for (var _i7 = 0; _i7 < matches.length; ++_i7) {\n    result = result || !!matches[_i7];\n\n    if (options.once && matches[_i7] > 1 || !options.part && !matches[_i7]) {\n      return false;\n    }\n  }\n\n  if (options.only && misses) {\n    return false;\n  }\n\n  return result;\n}; // Flatten array\n\n\nexports.flatten = function (array, target) {\n  var result = target || [];\n\n  for (var i = 0; i < array.length; ++i) {\n    if (Array.isArray(array[i])) {\n      exports.flatten(array[i], result);\n    } else {\n      result.push(array[i]);\n    }\n  }\n\n  return result;\n}; // Convert an object key chain string ('a.b.c') to reference (object[a][b][c])\n\n\nexports.reach = function (obj, chain, options) {\n  if (chain === false || chain === null || typeof chain === 'undefined') {\n    return obj;\n  }\n\n  options = options || {};\n\n  if (typeof options === 'string') {\n    options = {\n      separator: options\n    };\n  }\n\n  var path = chain.split(options.separator || '.');\n  var ref = obj;\n\n  for (var i = 0; i < path.length; ++i) {\n    var key = path[i];\n\n    if (key[0] === '-' && Array.isArray(ref)) {\n      key = key.slice(1, key.length);\n      key = ref.length - key;\n    }\n\n    if (!ref || !((typeof ref === 'object' || typeof ref === 'function') && key in ref) || typeof ref !== 'object' && options.functions === false) {\n      // Only object and function can have properties\n      exports.assert(!options.strict || i + 1 === path.length, 'Missing segment', key, 'in reach path ', chain);\n      exports.assert(typeof ref === 'object' || options.functions === true || typeof ref !== 'function', 'Invalid segment', key, 'in reach path ', chain);\n      ref = options.default;\n      break;\n    }\n\n    ref = ref[key];\n  }\n\n  return ref;\n};\n\nexports.reachTemplate = function (obj, template, options) {\n  return template.replace(/{([^}]+)}/g, function ($0, chain) {\n    var value = exports.reach(obj, chain, options);\n    return value === undefined || value === null ? '' : value;\n  });\n};\n\nexports.formatStack = function (stack) {\n  var trace = [];\n\n  for (var i = 0; i < stack.length; ++i) {\n    var item = stack[i];\n    trace.push([item.getFileName(), item.getLineNumber(), item.getColumnNumber(), item.getFunctionName(), item.isConstructor()]);\n  }\n\n  return trace;\n};\n\nexports.formatTrace = function (trace) {\n  var display = [];\n\n  for (var i = 0; i < trace.length; ++i) {\n    var row = trace[i];\n    display.push((row[4] ? 'new ' : '') + row[3] + ' (' + row[0] + ':' + row[1] + ':' + row[2] + ')');\n  }\n\n  return display;\n};\n\nexports.callStack = function (slice) {\n  // http://code.google.com/p/v8/wiki/JavaScriptStackTraceApi\n  var v8 = Error.prepareStackTrace;\n\n  Error.prepareStackTrace = function (_, stack) {\n    return stack;\n  };\n\n  var capture = {};\n  Error.captureStackTrace(capture, this);\n  var stack = capture.stack;\n  Error.prepareStackTrace = v8;\n  var trace = exports.formatStack(stack);\n  return trace.slice(1 + slice);\n};\n\nexports.displayStack = function (slice) {\n  var trace = exports.callStack(slice === undefined ? 1 : slice + 1);\n  return exports.formatTrace(trace);\n};\n\nexports.abortThrow = false;\n\nexports.abort = function (message, hideStack) {\n  if (process.env.NODE_ENV === 'test' || exports.abortThrow === true) {\n    throw new Error(message || 'Unknown error');\n  }\n\n  var stack = '';\n\n  if (!hideStack) {\n    stack = exports.displayStack(1).join('\\n\\t');\n  }\n\n  console.log('ABORT: ' + message + '\\n\\t' + stack);\n  process.exit(1);\n};\n\nexports.assert = function (condition) {\n  if (condition) {\n    return;\n  }\n\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  if (args.length === 1 && args[0] instanceof Error) {\n    throw args[0];\n  }\n\n  var msgs = args.filter(function (arg) {\n    return arg !== '';\n  }).map(function (arg) {\n    return typeof arg === 'string' ? arg : arg instanceof Error ? arg.message : exports.stringify(arg);\n  });\n  throw new Assert.AssertionError({\n    message: msgs.join(' ') || 'Unknown error',\n    actual: false,\n    expected: true,\n    operator: '==',\n    stackStartFunction: exports.assert\n  });\n};\n\nexports.Bench = function () {\n  this.ts = 0;\n  this.reset();\n};\n\nexports.Bench.prototype.reset = function () {\n  this.ts = exports.Bench.now();\n};\n\nexports.Bench.prototype.elapsed = function () {\n  return exports.Bench.now() - this.ts;\n};\n\nexports.Bench.now = function () {\n  var ts = process.hrtime();\n  return ts[0] * 1e3 + ts[1] / 1e6;\n}; // Escape string for Regex construction\n\n\nexports.escapeRegex = function (string) {\n  // Escape ^$.*+-?=!:|\\/()[]{},\n  return string.replace(/[\\^\\$\\.\\*\\+\\-\\?\\=\\!\\:\\|\\\\\\/\\(\\)\\[\\]\\{\\}\\,]/g, '\\\\$&');\n}; // Base64url (RFC 4648) encode\n\n\nexports.base64urlEncode = function (value, encoding) {\n  exports.assert(typeof value === 'string' || Buffer.isBuffer(value), 'value must be string or buffer');\n  var buf = Buffer.isBuffer(value) ? value : Buffer.from(value, encoding || 'binary');\n  return buf.toString('base64').replace(/\\+/g, '-').replace(/\\//g, '_').replace(/\\=/g, '');\n}; // Base64url (RFC 4648) decode\n\n\nexports.base64urlDecode = function (value, encoding) {\n  if (typeof value !== 'string') {\n    throw new Error('Value not a string');\n  }\n\n  if (!/^[\\w\\-]*$/.test(value)) {\n    throw new Error('Invalid character');\n  }\n\n  var buf = Buffer.from(value, 'base64');\n  return encoding === 'buffer' ? buf : buf.toString(encoding || 'binary');\n}; // Escape attribute value for use in HTTP header\n\n\nexports.escapeHeaderAttribute = function (attribute) {\n  // Allowed value characters: !#$%&'()*+,-./:;<=>?@[]^_`{|}~ and space, a-z, A-Z, 0-9, \\, \"\n  exports.assert(/^[ \\w\\!#\\$%&'\\(\\)\\*\\+,\\-\\.\\/\\:;<\\=>\\?@\\[\\]\\^`\\{\\|\\}~\\\"\\\\]*$/.test(attribute), 'Bad attribute value (' + attribute + ')');\n  return attribute.replace(/\\\\/g, '\\\\\\\\').replace(/\\\"/g, '\\\\\"'); // Escape quotes and slash\n};\n\nexports.escapeHtml = function (string) {\n  return Escape.escapeHtml(string);\n};\n\nexports.escapeJavaScript = function (string) {\n  return Escape.escapeJavaScript(string);\n};\n\nexports.escapeJson = function (string) {\n  return Escape.escapeJson(string);\n};\n\nexports.once = function (method) {\n  if (method._hoekOnce) {\n    return method;\n  }\n\n  var once = false;\n\n  var wrapped = function wrapped() {\n    if (!once) {\n      once = true;\n\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      method.apply(null, args);\n    }\n  };\n\n  wrapped._hoekOnce = true;\n  return wrapped;\n};\n\nexports.isInteger = Number.isSafeInteger;\n\nexports.ignore = function () {};\n\nexports.inherits = Util.inherits;\nexports.format = Util.format;\n\nexports.transform = function (source, transform, options) {\n  exports.assert(source === null || source === undefined || typeof source === 'object' || Array.isArray(source), 'Invalid source object: must be null, undefined, an object, or an array');\n  var separator = typeof options === 'object' && options !== null ? options.separator || '.' : '.';\n\n  if (Array.isArray(source)) {\n    var results = [];\n\n    for (var i = 0; i < source.length; ++i) {\n      results.push(exports.transform(source[i], transform, options));\n    }\n\n    return results;\n  }\n\n  var result = {};\n  var keys = Object.keys(transform);\n\n  for (var _i8 = 0; _i8 < keys.length; ++_i8) {\n    var key = keys[_i8];\n    var path = key.split(separator);\n    var sourcePath = transform[key];\n    exports.assert(typeof sourcePath === 'string', 'All mappings must be \".\" delineated strings');\n    var segment = void 0;\n    var res = result;\n\n    while (path.length > 1) {\n      segment = path.shift();\n\n      if (!res[segment]) {\n        res[segment] = {};\n      }\n\n      res = res[segment];\n    }\n\n    segment = path.shift();\n    res[segment] = exports.reach(source, sourcePath, options);\n  }\n\n  return result;\n};\n\nexports.uniqueFilename = function (path, extension) {\n  if (extension) {\n    extension = extension[0] !== '.' ? '.' + extension : extension;\n  } else {\n    extension = '';\n  }\n\n  path = Path.resolve(path);\n  var name = [Date.now(), process.pid, Crypto.randomBytes(8).toString('hex')].join('-') + extension;\n  return Path.join(path, name);\n};\n\nexports.stringify = function () {\n  try {\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n\n    return JSON.stringify.apply(null, args);\n  } catch (err) {\n    return '[Cannot display object: ' + err.message + ']';\n  }\n};\n\nexports.shallow = function (source) {\n  return Object.assign({}, source);\n};\n\nexports.wait = function (timeout) {\n  return new Promise(function (resolve) {\n    return setTimeout(resolve, timeout);\n  });\n};\n\nexports.block = function () {\n  return new Promise(exports.ignore);\n};","map":{"version":3,"sources":["/home/cloudmynds/Desktop/admin/node_modules/joi/node_modules/hoek/lib/index.js"],"names":["Assert","require","Crypto","Path","Util","Escape","internals","exports","clone","obj","seen","Map","lookup","get","newObj","cloneDeep","Array","isArray","Buffer","isBuffer","from","Date","getTime","RegExp","proto","Object","getPrototypeOf","isImmutable","create","set","keys","getOwnPropertyNames","i","length","key","descriptor","getOwnPropertyDescriptor","defineProperty","merge","target","source","isNullOverride","isMergeArrays","assert","undefined","push","value","applyToDefaults","defaults","options","copy","cloneWithShallow","storage","store","restore","reach","reachSet","path","split","ref","segment","applyToDefaultsWithShallow","deepEqual","prototype","type","indexOf","part","found","j","toString","unique","array","result","index","Set","forEach","item","identifier","has","add","mapToObject","intersect","array1","array2","justFirst","common","hash","contain","values","valuePairs","concat","compare","compareFlags","deep","hasOnly","hasOwnProperty","hasPart","only","a","b","misses","matches","pattern","escapeRegex","regex","leftovers","replace","$0","$1","matched","pos","once","flatten","chain","separator","slice","functions","strict","default","reachTemplate","template","formatStack","stack","trace","getFileName","getLineNumber","getColumnNumber","getFunctionName","isConstructor","formatTrace","display","row","callStack","v8","Error","prepareStackTrace","_","capture","captureStackTrace","displayStack","abortThrow","abort","message","hideStack","process","env","NODE_ENV","join","console","log","exit","condition","args","msgs","filter","arg","map","stringify","AssertionError","actual","expected","operator","stackStartFunction","Bench","ts","reset","now","elapsed","hrtime","string","base64urlEncode","encoding","buf","base64urlDecode","test","escapeHeaderAttribute","attribute","escapeHtml","escapeJavaScript","escapeJson","method","_hoekOnce","wrapped","apply","isInteger","Number","isSafeInteger","ignore","inherits","format","transform","results","sourcePath","res","shift","uniqueFilename","extension","resolve","name","pid","randomBytes","JSON","err","shallow","assign","wait","timeout","Promise","setTimeout","block"],"mappings":"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","sourcesContent":["'use strict';\n\n// Load modules\n\nconst Assert = require('assert');\nconst Crypto = require('crypto');\nconst Path = require('path');\nconst Util = require('util');\n\nconst Escape = require('./escape');\n\n\n// Declare internals\n\nconst internals = {};\n\n\n// Clone object or array\n\nexports.clone = function (obj, seen) {\n\n    if (typeof obj !== 'object' ||\n        obj === null) {\n\n        return obj;\n    }\n\n    seen = seen || new Map();\n\n    const lookup = seen.get(obj);\n    if (lookup) {\n        return lookup;\n    }\n\n    let newObj;\n    let cloneDeep = false;\n\n    if (!Array.isArray(obj)) {\n        if (Buffer.isBuffer(obj)) {\n            newObj = Buffer.from(obj);\n        }\n        else if (obj instanceof Date) {\n            newObj = new Date(obj.getTime());\n        }\n        else if (obj instanceof RegExp) {\n            newObj = new RegExp(obj);\n        }\n        else {\n            const proto = Object.getPrototypeOf(obj);\n            if (proto &&\n                proto.isImmutable) {\n\n                newObj = obj;\n            }\n            else {\n                newObj = Object.create(proto);\n                cloneDeep = true;\n            }\n        }\n    }\n    else {\n        newObj = [];\n        cloneDeep = true;\n    }\n\n    seen.set(obj, newObj);\n\n    if (cloneDeep) {\n        const keys = Object.getOwnPropertyNames(obj);\n        for (let i = 0; i < keys.length; ++i) {\n            const key = keys[i];\n            const descriptor = Object.getOwnPropertyDescriptor(obj, key);\n            if (descriptor &&\n                (descriptor.get ||\n                    descriptor.set)) {\n\n                Object.defineProperty(newObj, key, descriptor);\n            }\n            else {\n                newObj[key] = exports.clone(obj[key], seen);\n            }\n        }\n    }\n\n    return newObj;\n};\n\n\n// Merge all the properties of source into target, source wins in conflict, and by default null and undefined from source are applied\n\n/*eslint-disable */\nexports.merge = function (target, source, isNullOverride /* = true */, isMergeArrays /* = true */) {\n    /*eslint-enable */\n\n    exports.assert(target && typeof target === 'object', 'Invalid target value: must be an object');\n    exports.assert(source === null || source === undefined || typeof source === 'object', 'Invalid source value: must be null, undefined, or an object');\n\n    if (!source) {\n        return target;\n    }\n\n    if (Array.isArray(source)) {\n        exports.assert(Array.isArray(target), 'Cannot merge array onto an object');\n        if (isMergeArrays === false) {                                                  // isMergeArrays defaults to true\n            target.length = 0;                                                          // Must not change target assignment\n        }\n\n        for (let i = 0; i < source.length; ++i) {\n            target.push(exports.clone(source[i]));\n        }\n\n        return target;\n    }\n\n    const keys = Object.keys(source);\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i];\n        if (key === '__proto__') {\n            continue;\n        }\n\n        const value = source[key];\n        if (value &&\n            typeof value === 'object') {\n\n            if (!target[key] ||\n                typeof target[key] !== 'object' ||\n                (Array.isArray(target[key]) !== Array.isArray(value)) ||\n                value instanceof Date ||\n                Buffer.isBuffer(value) ||\n                value instanceof RegExp) {\n\n                target[key] = exports.clone(value);\n            }\n            else {\n                exports.merge(target[key], value, isNullOverride, isMergeArrays);\n            }\n        }\n        else {\n            if (value !== null &&\n                value !== undefined) {                              // Explicit to preserve empty strings\n\n                target[key] = value;\n            }\n            else if (isNullOverride !== false) {                    // Defaults to true\n                target[key] = value;\n            }\n        }\n    }\n\n    return target;\n};\n\n\n// Apply options to a copy of the defaults\n\nexports.applyToDefaults = function (defaults, options, isNullOverride) {\n\n    exports.assert(defaults && typeof defaults === 'object', 'Invalid defaults value: must be an object');\n    exports.assert(!options || options === true || typeof options === 'object', 'Invalid options value: must be true, falsy or an object');\n\n    if (!options) {                                                 // If no options, return null\n        return null;\n    }\n\n    const copy = exports.clone(defaults);\n\n    if (options === true) {                                         // If options is set to true, use defaults\n        return copy;\n    }\n\n    return exports.merge(copy, options, isNullOverride === true, false);\n};\n\n\n// Clone an object except for the listed keys which are shallow copied\n\nexports.cloneWithShallow = function (source, keys) {\n\n    if (!source ||\n        typeof source !== 'object') {\n\n        return source;\n    }\n\n    const storage = internals.store(source, keys);    // Move shallow copy items to storage\n    const copy = exports.clone(source);               // Deep copy the rest\n    internals.restore(copy, source, storage);       // Shallow copy the stored items and restore\n    return copy;\n};\n\n\ninternals.store = function (source, keys) {\n\n    const storage = {};\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i];\n        const value = exports.reach(source, key);\n        if (value !== undefined) {\n            storage[key] = value;\n            internals.reachSet(source, key, undefined);\n        }\n    }\n\n    return storage;\n};\n\n\ninternals.restore = function (copy, source, storage) {\n\n    const keys = Object.keys(storage);\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i];\n        internals.reachSet(copy, key, storage[key]);\n        internals.reachSet(source, key, storage[key]);\n    }\n};\n\n\ninternals.reachSet = function (obj, key, value) {\n\n    const path = key.split('.');\n    let ref = obj;\n    for (let i = 0; i < path.length; ++i) {\n        const segment = path[i];\n        if (i + 1 === path.length) {\n            ref[segment] = value;\n        }\n\n        ref = ref[segment];\n    }\n};\n\n\n// Apply options to defaults except for the listed keys which are shallow copied from option without merging\n\nexports.applyToDefaultsWithShallow = function (defaults, options, keys) {\n\n    exports.assert(defaults && typeof defaults === 'object', 'Invalid defaults value: must be an object');\n    exports.assert(!options || options === true || typeof options === 'object', 'Invalid options value: must be true, falsy or an object');\n    exports.assert(keys && Array.isArray(keys), 'Invalid keys');\n\n    if (!options) {                                                 // If no options, return null\n        return null;\n    }\n\n    const copy = exports.cloneWithShallow(defaults, keys);\n\n    if (options === true) {                                         // If options is set to true, use defaults\n        return copy;\n    }\n\n    const storage = internals.store(options, keys);   // Move shallow copy items to storage\n    exports.merge(copy, options, false, false);     // Deep copy the rest\n    internals.restore(copy, options, storage);      // Shallow copy the stored items and restore\n    return copy;\n};\n\n\n// Deep object or array comparison\n\nexports.deepEqual = function (obj, ref, options, seen) {\n\n    if (obj === ref) {                                                      // Copied from Deep-eql, copyright(c) 2013 Jake Luer, jake@alogicalparadox.com, MIT Licensed, https://github.com/chaijs/deep-eql\n        return obj !== 0 || 1 / obj === 1 / ref;        // -0 / +0\n    }\n\n    options = options || { prototype: true };\n\n    const type = typeof obj;\n\n    if (type !== typeof ref) {\n        return false;\n    }\n\n    if (type !== 'object' ||\n        obj === null ||\n        ref === null) {\n\n        return obj !== obj && ref !== ref;                  // NaN\n    }\n\n    seen = seen || [];\n    if (seen.indexOf(obj) !== -1) {\n        return true;                            // If previous comparison failed, it would have stopped execution\n    }\n\n    seen.push(obj);\n\n    if (Array.isArray(obj)) {\n        if (!Array.isArray(ref)) {\n            return false;\n        }\n\n        if (!options.part && obj.length !== ref.length) {\n            return false;\n        }\n\n        for (let i = 0; i < obj.length; ++i) {\n            if (options.part) {\n                let found = false;\n                for (let j = 0; j < ref.length; ++j) {\n                    if (exports.deepEqual(obj[i], ref[j], options)) {\n                        found = true;\n                        break;\n                    }\n                }\n\n                return found;\n            }\n\n            if (!exports.deepEqual(obj[i], ref[i], options)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    if (Buffer.isBuffer(obj)) {\n        if (!Buffer.isBuffer(ref)) {\n            return false;\n        }\n\n        if (obj.length !== ref.length) {\n            return false;\n        }\n\n        for (let i = 0; i < obj.length; ++i) {\n            if (obj[i] !== ref[i]) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    if (obj instanceof Date) {\n        return (ref instanceof Date && obj.getTime() === ref.getTime());\n    }\n\n    if (obj instanceof RegExp) {\n        return (ref instanceof RegExp && obj.toString() === ref.toString());\n    }\n\n    if (options.prototype) {\n        if (Object.getPrototypeOf(obj) !== Object.getPrototypeOf(ref)) {\n            return false;\n        }\n    }\n\n    const keys = Object.getOwnPropertyNames(obj);\n\n    if (!options.part && keys.length !== Object.getOwnPropertyNames(ref).length) {\n        return false;\n    }\n\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i];\n        const descriptor = Object.getOwnPropertyDescriptor(obj, key);\n        if (descriptor.get) {\n            if (!exports.deepEqual(descriptor, Object.getOwnPropertyDescriptor(ref, key), options, seen)) {\n                return false;\n            }\n        }\n        else if (!exports.deepEqual(obj[key], ref[key], options, seen)) {\n            return false;\n        }\n    }\n\n    return true;\n};\n\n\n// Remove duplicate items from array\n\nexports.unique = (array, key) => {\n\n    let result;\n    if (key) {\n        result = [];\n        const index = new Set();\n        array.forEach((item) => {\n\n            const identifier = item[key];\n            if (!index.has(identifier)) {\n                index.add(identifier);\n                result.push(item);\n            }\n        });\n    }\n    else {\n        result = Array.from(new Set(array));\n    }\n\n    return result;\n};\n\n\n// Convert array into object\n\nexports.mapToObject = function (array, key) {\n\n    if (!array) {\n        return null;\n    }\n\n    const obj = {};\n    for (let i = 0; i < array.length; ++i) {\n        if (key) {\n            if (array[i][key]) {\n                obj[array[i][key]] = true;\n            }\n        }\n        else {\n            obj[array[i]] = true;\n        }\n    }\n\n    return obj;\n};\n\n\n// Find the common unique items in two arrays\n\nexports.intersect = function (array1, array2, justFirst) {\n\n    if (!array1 || !array2) {\n        return [];\n    }\n\n    const common = [];\n    const hash = (Array.isArray(array1) ? exports.mapToObject(array1) : array1);\n    const found = {};\n    for (let i = 0; i < array2.length; ++i) {\n        if (hash[array2[i]] && !found[array2[i]]) {\n            if (justFirst) {\n                return array2[i];\n            }\n\n            common.push(array2[i]);\n            found[array2[i]] = true;\n        }\n    }\n\n    return (justFirst ? null : common);\n};\n\n\n// Test if the reference contains the values\n\nexports.contain = function (ref, values, options) {\n\n    /*\n        string -> string(s)\n        array -> item(s)\n        object -> key(s)\n        object -> object (key:value)\n    */\n\n    let valuePairs = null;\n    if (typeof ref === 'object' &&\n        typeof values === 'object' &&\n        !Array.isArray(ref) &&\n        !Array.isArray(values)) {\n\n        valuePairs = values;\n        values = Object.keys(values);\n    }\n    else {\n        values = [].concat(values);\n    }\n\n    options = options || {};            // deep, once, only, part\n\n    exports.assert(typeof ref === 'string' || typeof ref === 'object', 'Reference must be string or an object');\n    exports.assert(values.length, 'Values array cannot be empty');\n\n    let compare;\n    let compareFlags;\n    if (options.deep) {\n        compare = exports.deepEqual;\n\n        const hasOnly = options.hasOwnProperty('only');\n        const hasPart = options.hasOwnProperty('part');\n\n        compareFlags = {\n            prototype: hasOnly ? options.only : hasPart ? !options.part : false,\n            part: hasOnly ? !options.only : hasPart ? options.part : true\n        };\n    }\n    else {\n        compare = (a, b) => a === b;\n    }\n\n    let misses = false;\n    const matches = new Array(values.length);\n    for (let i = 0; i < matches.length; ++i) {\n        matches[i] = 0;\n    }\n\n    if (typeof ref === 'string') {\n        let pattern = '(';\n        for (let i = 0; i < values.length; ++i) {\n            const value = values[i];\n            exports.assert(typeof value === 'string', 'Cannot compare string reference to non-string value');\n            pattern += (i ? '|' : '') + exports.escapeRegex(value);\n        }\n\n        const regex = new RegExp(pattern + ')', 'g');\n        const leftovers = ref.replace(regex, ($0, $1) => {\n\n            const index = values.indexOf($1);\n            ++matches[index];\n            return '';          // Remove from string\n        });\n\n        misses = !!leftovers;\n    }\n    else if (Array.isArray(ref)) {\n        for (let i = 0; i < ref.length; ++i) {\n            let matched = false;\n            for (let j = 0; j < values.length && matched === false; ++j) {\n                matched = compare(values[j], ref[i], compareFlags) && j;\n            }\n\n            if (matched !== false) {\n                ++matches[matched];\n            }\n            else {\n                misses = true;\n            }\n        }\n    }\n    else {\n        const keys = Object.getOwnPropertyNames(ref);\n        for (let i = 0; i < keys.length; ++i) {\n            const key = keys[i];\n            const pos = values.indexOf(key);\n            if (pos !== -1) {\n                if (valuePairs &&\n                    !compare(valuePairs[key], ref[key], compareFlags)) {\n\n                    return false;\n                }\n\n                ++matches[pos];\n            }\n            else {\n                misses = true;\n            }\n        }\n    }\n\n    let result = false;\n    for (let i = 0; i < matches.length; ++i) {\n        result = result || !!matches[i];\n        if ((options.once && matches[i] > 1) ||\n            (!options.part && !matches[i])) {\n\n            return false;\n        }\n    }\n\n    if (options.only &&\n        misses) {\n\n        return false;\n    }\n\n    return result;\n};\n\n\n// Flatten array\n\nexports.flatten = function (array, target) {\n\n    const result = target || [];\n\n    for (let i = 0; i < array.length; ++i) {\n        if (Array.isArray(array[i])) {\n            exports.flatten(array[i], result);\n        }\n        else {\n            result.push(array[i]);\n        }\n    }\n\n    return result;\n};\n\n\n// Convert an object key chain string ('a.b.c') to reference (object[a][b][c])\n\nexports.reach = function (obj, chain, options) {\n\n    if (chain === false ||\n        chain === null ||\n        typeof chain === 'undefined') {\n\n        return obj;\n    }\n\n    options = options || {};\n    if (typeof options === 'string') {\n        options = { separator: options };\n    }\n\n    const path = chain.split(options.separator || '.');\n    let ref = obj;\n    for (let i = 0; i < path.length; ++i) {\n        let key = path[i];\n        if (key[0] === '-' && Array.isArray(ref)) {\n            key = key.slice(1, key.length);\n            key = ref.length - key;\n        }\n\n        if (!ref ||\n            !((typeof ref === 'object' || typeof ref === 'function') && key in ref) ||\n            (typeof ref !== 'object' && options.functions === false)) {         // Only object and function can have properties\n\n            exports.assert(!options.strict || i + 1 === path.length, 'Missing segment', key, 'in reach path ', chain);\n            exports.assert(typeof ref === 'object' || options.functions === true || typeof ref !== 'function', 'Invalid segment', key, 'in reach path ', chain);\n            ref = options.default;\n            break;\n        }\n\n        ref = ref[key];\n    }\n\n    return ref;\n};\n\n\nexports.reachTemplate = function (obj, template, options) {\n\n    return template.replace(/{([^}]+)}/g, ($0, chain) => {\n\n        const value = exports.reach(obj, chain, options);\n        return (value === undefined || value === null ? '' : value);\n    });\n};\n\n\nexports.formatStack = function (stack) {\n\n    const trace = [];\n    for (let i = 0; i < stack.length; ++i) {\n        const item = stack[i];\n        trace.push([item.getFileName(), item.getLineNumber(), item.getColumnNumber(), item.getFunctionName(), item.isConstructor()]);\n    }\n\n    return trace;\n};\n\n\nexports.formatTrace = function (trace) {\n\n    const display = [];\n\n    for (let i = 0; i < trace.length; ++i) {\n        const row = trace[i];\n        display.push((row[4] ? 'new ' : '') + row[3] + ' (' + row[0] + ':' + row[1] + ':' + row[2] + ')');\n    }\n\n    return display;\n};\n\n\nexports.callStack = function (slice) {\n\n    // http://code.google.com/p/v8/wiki/JavaScriptStackTraceApi\n\n    const v8 = Error.prepareStackTrace;\n    Error.prepareStackTrace = function (_, stack) {\n\n        return stack;\n    };\n\n    const capture = {};\n    Error.captureStackTrace(capture, this);\n    const stack = capture.stack;\n\n    Error.prepareStackTrace = v8;\n\n    const trace = exports.formatStack(stack);\n\n    return trace.slice(1 + slice);\n};\n\n\nexports.displayStack = function (slice) {\n\n    const trace = exports.callStack(slice === undefined ? 1 : slice + 1);\n\n    return exports.formatTrace(trace);\n};\n\n\nexports.abortThrow = false;\n\n\nexports.abort = function (message, hideStack) {\n\n    if (process.env.NODE_ENV === 'test' || exports.abortThrow === true) {\n        throw new Error(message || 'Unknown error');\n    }\n\n    let stack = '';\n    if (!hideStack) {\n        stack = exports.displayStack(1).join('\\n\\t');\n    }\n    console.log('ABORT: ' + message + '\\n\\t' + stack);\n    process.exit(1);\n};\n\n\nexports.assert = function (condition, ...args) {\n\n    if (condition) {\n        return;\n    }\n\n    if (args.length === 1 && args[0] instanceof Error) {\n        throw args[0];\n    }\n\n    const msgs = args\n        .filter((arg) => arg !== '')\n        .map((arg) => {\n\n            return typeof arg === 'string' ? arg : arg instanceof Error ? arg.message : exports.stringify(arg);\n        });\n\n    throw new Assert.AssertionError({\n        message: msgs.join(' ') || 'Unknown error',\n        actual: false,\n        expected: true,\n        operator: '==',\n        stackStartFunction: exports.assert\n    });\n};\n\n\nexports.Bench = function () {\n\n    this.ts = 0;\n    this.reset();\n};\n\n\nexports.Bench.prototype.reset = function () {\n\n    this.ts = exports.Bench.now();\n};\n\n\nexports.Bench.prototype.elapsed = function () {\n\n    return exports.Bench.now() - this.ts;\n};\n\n\nexports.Bench.now = function () {\n\n    const ts = process.hrtime();\n    return (ts[0] * 1e3) + (ts[1] / 1e6);\n};\n\n\n// Escape string for Regex construction\n\nexports.escapeRegex = function (string) {\n\n    // Escape ^$.*+-?=!:|\\/()[]{},\n    return string.replace(/[\\^\\$\\.\\*\\+\\-\\?\\=\\!\\:\\|\\\\\\/\\(\\)\\[\\]\\{\\}\\,]/g, '\\\\$&');\n};\n\n\n// Base64url (RFC 4648) encode\n\nexports.base64urlEncode = function (value, encoding) {\n\n    exports.assert(typeof value === 'string' || Buffer.isBuffer(value), 'value must be string or buffer');\n    const buf = (Buffer.isBuffer(value) ? value : Buffer.from(value, encoding || 'binary'));\n    return buf.toString('base64').replace(/\\+/g, '-').replace(/\\//g, '_').replace(/\\=/g, '');\n};\n\n\n// Base64url (RFC 4648) decode\n\nexports.base64urlDecode = function (value, encoding) {\n\n    if (typeof value !== 'string') {\n\n        throw new Error('Value not a string');\n    }\n\n    if (!/^[\\w\\-]*$/.test(value)) {\n\n        throw new Error('Invalid character');\n    }\n\n    const buf = Buffer.from(value, 'base64');\n    return (encoding === 'buffer' ? buf : buf.toString(encoding || 'binary'));\n};\n\n\n// Escape attribute value for use in HTTP header\n\nexports.escapeHeaderAttribute = function (attribute) {\n\n    // Allowed value characters: !#$%&'()*+,-./:;<=>?@[]^_`{|}~ and space, a-z, A-Z, 0-9, \\, \"\n\n    exports.assert(/^[ \\w\\!#\\$%&'\\(\\)\\*\\+,\\-\\.\\/\\:;<\\=>\\?@\\[\\]\\^`\\{\\|\\}~\\\"\\\\]*$/.test(attribute), 'Bad attribute value (' + attribute + ')');\n\n    return attribute.replace(/\\\\/g, '\\\\\\\\').replace(/\\\"/g, '\\\\\"');                             // Escape quotes and slash\n};\n\n\nexports.escapeHtml = function (string) {\n\n    return Escape.escapeHtml(string);\n};\n\n\nexports.escapeJavaScript = function (string) {\n\n    return Escape.escapeJavaScript(string);\n};\n\n\nexports.escapeJson = function (string) {\n\n    return Escape.escapeJson(string);\n};\n\n\nexports.once = function (method) {\n\n    if (method._hoekOnce) {\n        return method;\n    }\n\n    let once = false;\n    const wrapped = function (...args) {\n\n        if (!once) {\n            once = true;\n            method.apply(null, args);\n        }\n    };\n\n    wrapped._hoekOnce = true;\n    return wrapped;\n};\n\n\nexports.isInteger = Number.isSafeInteger;\n\n\nexports.ignore = function () { };\n\n\nexports.inherits = Util.inherits;\n\n\nexports.format = Util.format;\n\n\nexports.transform = function (source, transform, options) {\n\n    exports.assert(source === null || source === undefined || typeof source === 'object' || Array.isArray(source), 'Invalid source object: must be null, undefined, an object, or an array');\n    const separator = (typeof options === 'object' && options !== null) ? (options.separator || '.') : '.';\n\n    if (Array.isArray(source)) {\n        const results = [];\n        for (let i = 0; i < source.length; ++i) {\n            results.push(exports.transform(source[i], transform, options));\n        }\n        return results;\n    }\n\n    const result = {};\n    const keys = Object.keys(transform);\n\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i];\n        const path = key.split(separator);\n        const sourcePath = transform[key];\n\n        exports.assert(typeof sourcePath === 'string', 'All mappings must be \".\" delineated strings');\n\n        let segment;\n        let res = result;\n\n        while (path.length > 1) {\n            segment = path.shift();\n            if (!res[segment]) {\n                res[segment] = {};\n            }\n            res = res[segment];\n        }\n        segment = path.shift();\n        res[segment] = exports.reach(source, sourcePath, options);\n    }\n\n    return result;\n};\n\n\nexports.uniqueFilename = function (path, extension) {\n\n    if (extension) {\n        extension = extension[0] !== '.' ? '.' + extension : extension;\n    }\n    else {\n        extension = '';\n    }\n\n    path = Path.resolve(path);\n    const name = [Date.now(), process.pid, Crypto.randomBytes(8).toString('hex')].join('-') + extension;\n    return Path.join(path, name);\n};\n\n\nexports.stringify = function (...args) {\n\n    try {\n        return JSON.stringify.apply(null, args);\n    }\n    catch (err) {\n        return '[Cannot display object: ' + err.message + ']';\n    }\n};\n\n\nexports.shallow = function (source) {\n\n    return Object.assign({}, source);\n};\n\n\nexports.wait = function (timeout) {\n\n    return new Promise((resolve) => setTimeout(resolve, timeout));\n};\n\n\nexports.block = function () {\n\n    return new Promise(exports.ignore);\n};\n"]},"metadata":{},"sourceType":"script"}