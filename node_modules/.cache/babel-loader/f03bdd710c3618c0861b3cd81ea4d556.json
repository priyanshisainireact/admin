{"ast":null,"code":"'use strict'; // Load modules\n\nvar _classCallCheck = require(\"/home/cloudmynds/Desktop/admin/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/cloudmynds/Desktop/admin/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar Hoek = require('hoek'); // Declare internals\n\n\nvar internals = {};\n\nmodule.exports = /*#__PURE__*/function () {\n  function Topo() {\n    _classCallCheck(this, Topo);\n\n    this._items = [];\n    this.nodes = [];\n  }\n\n  _createClass(Topo, [{\n    key: \"add\",\n    value: function add(nodes, options) {\n      var _this = this;\n\n      options = options || {}; // Validate rules\n\n      var before = [].concat(options.before || []);\n      var after = [].concat(options.after || []);\n      var group = options.group || '?';\n      var sort = options.sort || 0; // Used for merging only\n\n      Hoek.assert(!before.includes(group), \"Item cannot come before itself: \".concat(group));\n      Hoek.assert(!before.includes('?'), 'Item cannot come before unassociated items');\n      Hoek.assert(!after.includes(group), \"Item cannot come after itself: \".concat(group));\n      Hoek.assert(!after.includes('?'), 'Item cannot come after unassociated items');\n      [].concat(nodes).forEach(function (node, i) {\n        var item = {\n          seq: _this._items.length,\n          sort: sort,\n          before: before,\n          after: after,\n          group: group,\n          node: node\n        };\n\n        _this._items.push(item);\n      }); // Insert event\n\n      var error = this._sort();\n\n      Hoek.assert(!error, 'item', group !== '?' ? \"added into group \".concat(group) : '', 'created a dependencies error');\n      return this.nodes;\n    }\n  }, {\n    key: \"merge\",\n    value: function merge(others) {\n      others = [].concat(others);\n\n      for (var i = 0; i < others.length; ++i) {\n        var other = others[i];\n\n        if (other) {\n          for (var j = 0; j < other._items.length; ++j) {\n            var item = Object.assign({}, other._items[j]); // Shallow cloned\n\n            this._items.push(item);\n          }\n        }\n      } // Sort items\n\n\n      this._items.sort(internals.mergeSort);\n\n      for (var _i = 0; _i < this._items.length; ++_i) {\n        this._items[_i].seq = _i;\n      }\n\n      var error = this._sort();\n\n      Hoek.assert(!error, 'merge created a dependencies error');\n      return this.nodes;\n    }\n  }, {\n    key: \"_sort\",\n    value: function _sort() {\n      // Construct graph\n      var graph = {};\n      var graphAfters = Object.create(null); // A prototype can bungle lookups w/ false positives\n\n      var groups = Object.create(null);\n\n      for (var i = 0; i < this._items.length; ++i) {\n        var item = this._items[i];\n        var seq = item.seq; // Unique across all items\n\n        var group = item.group; // Determine Groups\n\n        groups[group] = groups[group] || [];\n        groups[group].push(seq); // Build intermediary graph using 'before'\n\n        graph[seq] = item.before; // Build second intermediary graph with 'after'\n\n        var after = item.after;\n\n        for (var j = 0; j < after.length; ++j) {\n          graphAfters[after[j]] = (graphAfters[after[j]] || []).concat(seq);\n        }\n      } // Expand intermediary graph\n\n\n      var graphNodes = Object.keys(graph);\n\n      for (var _i2 = 0; _i2 < graphNodes.length; ++_i2) {\n        var node = graphNodes[_i2];\n        var expandedGroups = [];\n        var graphNodeItems = Object.keys(graph[node]);\n\n        for (var _j = 0; _j < graphNodeItems.length; ++_j) {\n          var _group = graph[node][graphNodeItems[_j]];\n          groups[_group] = groups[_group] || [];\n\n          for (var k = 0; k < groups[_group].length; ++k) {\n            expandedGroups.push(groups[_group][k]);\n          }\n        }\n\n        graph[node] = expandedGroups;\n      } // Merge intermediary graph using graphAfters into final graph\n\n\n      var afterNodes = Object.keys(graphAfters);\n\n      for (var _i3 = 0; _i3 < afterNodes.length; ++_i3) {\n        var _group2 = afterNodes[_i3];\n\n        if (groups[_group2]) {\n          for (var _j2 = 0; _j2 < groups[_group2].length; ++_j2) {\n            var _node = groups[_group2][_j2];\n            graph[_node] = graph[_node].concat(graphAfters[_group2]);\n          }\n        }\n      } // Compile ancestors\n\n\n      var children;\n      var ancestors = {};\n      graphNodes = Object.keys(graph);\n\n      for (var _i4 = 0; _i4 < graphNodes.length; ++_i4) {\n        var _node2 = graphNodes[_i4];\n        children = graph[_node2];\n\n        for (var _j3 = 0; _j3 < children.length; ++_j3) {\n          ancestors[children[_j3]] = (ancestors[children[_j3]] || []).concat(_node2);\n        }\n      } // Topo sort\n\n\n      var visited = {};\n      var sorted = [];\n\n      for (var _i5 = 0; _i5 < this._items.length; ++_i5) {\n        // Really looping thru item.seq values out of order\n        var next = _i5;\n\n        if (ancestors[_i5]) {\n          next = null;\n\n          for (var _j4 = 0; _j4 < this._items.length; ++_j4) {\n            // As above, these are item.seq values\n            if (visited[_j4] === true) {\n              continue;\n            }\n\n            if (!ancestors[_j4]) {\n              ancestors[_j4] = [];\n            }\n\n            var shouldSeeCount = ancestors[_j4].length;\n            var seenCount = 0;\n\n            for (var _k = 0; _k < shouldSeeCount; ++_k) {\n              if (visited[ancestors[_j4][_k]]) {\n                ++seenCount;\n              }\n            }\n\n            if (seenCount === shouldSeeCount) {\n              next = _j4;\n              break;\n            }\n          }\n        }\n\n        if (next !== null) {\n          visited[next] = true;\n          sorted.push(next);\n        }\n      }\n\n      if (sorted.length !== this._items.length) {\n        return new Error('Invalid dependencies');\n      }\n\n      var seqIndex = {};\n\n      for (var _i6 = 0; _i6 < this._items.length; ++_i6) {\n        var _item = this._items[_i6];\n        seqIndex[_item.seq] = _item;\n      }\n\n      var sortedNodes = [];\n      this._items = sorted.map(function (value) {\n        var sortedItem = seqIndex[value];\n        sortedNodes.push(sortedItem.node);\n        return sortedItem;\n      });\n      this.nodes = sortedNodes;\n    }\n  }]);\n\n  return Topo;\n}();\n\ninternals.mergeSort = function (a, b) {\n  return a.sort === b.sort ? 0 : a.sort < b.sort ? -1 : 1;\n};","map":{"version":3,"sources":["/home/cloudmynds/Desktop/admin/node_modules/topo/lib/index.js"],"names":["Hoek","require","internals","module","exports","_items","nodes","options","before","concat","after","group","sort","assert","includes","forEach","node","i","item","seq","length","push","error","_sort","others","other","j","Object","assign","mergeSort","graph","graphAfters","create","groups","graphNodes","keys","expandedGroups","graphNodeItems","k","afterNodes","children","ancestors","visited","sorted","next","shouldSeeCount","seenCount","Error","seqIndex","sortedNodes","map","value","sortedItem","a","b"],"mappings":"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","sourcesContent":["'use strict';\n\n// Load modules\n\nconst Hoek = require('hoek');\n\n\n// Declare internals\n\nconst internals = {};\n\n\nmodule.exports = class Topo {\n\n    constructor() {\n\n        this._items = [];\n        this.nodes = [];\n    }\n\n    add(nodes, options) {\n\n        options = options || {};\n\n        // Validate rules\n\n        const before = [].concat(options.before || []);\n        const after = [].concat(options.after || []);\n        const group = options.group || '?';\n        const sort = options.sort || 0;                   // Used for merging only\n\n        Hoek.assert(!before.includes(group), `Item cannot come before itself: ${group}`);\n        Hoek.assert(!before.includes('?'), 'Item cannot come before unassociated items');\n        Hoek.assert(!after.includes(group), `Item cannot come after itself: ${group}`);\n        Hoek.assert(!after.includes('?'), 'Item cannot come after unassociated items');\n\n        ([].concat(nodes)).forEach((node, i) => {\n\n            const item = {\n                seq: this._items.length,\n                sort,\n                before,\n                after,\n                group,\n                node\n            };\n\n            this._items.push(item);\n        });\n\n        // Insert event\n\n        const error = this._sort();\n        Hoek.assert(!error, 'item', (group !== '?' ? `added into group ${group}` : ''), 'created a dependencies error');\n\n        return this.nodes;\n    }\n\n    merge(others) {\n\n        others = [].concat(others);\n        for (let i = 0; i < others.length; ++i) {\n            const other = others[i];\n            if (other) {\n                for (let j = 0; j < other._items.length; ++j) {\n                    const item = Object.assign({}, other._items[j]);        // Shallow cloned\n                    this._items.push(item);\n                }\n            }\n        }\n\n        // Sort items\n\n        this._items.sort(internals.mergeSort);\n        for (let i = 0; i < this._items.length; ++i) {\n            this._items[i].seq = i;\n        }\n\n        const error = this._sort();\n        Hoek.assert(!error, 'merge created a dependencies error');\n\n        return this.nodes;\n    }\n\n    _sort() {\n\n        // Construct graph\n\n        const graph = {};\n        const graphAfters = Object.create(null); // A prototype can bungle lookups w/ false positives\n        const groups = Object.create(null);\n\n        for (let i = 0; i < this._items.length; ++i) {\n            const item = this._items[i];\n            const seq = item.seq;                         // Unique across all items\n            const group = item.group;\n\n            // Determine Groups\n\n            groups[group] = groups[group] || [];\n            groups[group].push(seq);\n\n            // Build intermediary graph using 'before'\n\n            graph[seq] = item.before;\n\n            // Build second intermediary graph with 'after'\n\n            const after = item.after;\n            for (let j = 0; j < after.length; ++j) {\n                graphAfters[after[j]] = (graphAfters[after[j]] || []).concat(seq);\n            }\n        }\n\n        // Expand intermediary graph\n\n        let graphNodes = Object.keys(graph);\n        for (let i = 0; i < graphNodes.length; ++i) {\n            const node = graphNodes[i];\n            const expandedGroups = [];\n\n            const graphNodeItems = Object.keys(graph[node]);\n            for (let j = 0; j < graphNodeItems.length; ++j) {\n                const group = graph[node][graphNodeItems[j]];\n                groups[group] = groups[group] || [];\n\n                for (let k = 0; k < groups[group].length; ++k) {\n                    expandedGroups.push(groups[group][k]);\n                }\n            }\n\n            graph[node] = expandedGroups;\n        }\n\n        // Merge intermediary graph using graphAfters into final graph\n\n        const afterNodes = Object.keys(graphAfters);\n        for (let i = 0; i < afterNodes.length; ++i) {\n            const group = afterNodes[i];\n\n            if (groups[group]) {\n                for (let j = 0; j < groups[group].length; ++j) {\n                    const node = groups[group][j];\n                    graph[node] = graph[node].concat(graphAfters[group]);\n                }\n            }\n        }\n\n        // Compile ancestors\n\n        let children;\n        const ancestors = {};\n        graphNodes = Object.keys(graph);\n        for (let i = 0; i < graphNodes.length; ++i) {\n            const node = graphNodes[i];\n            children = graph[node];\n\n            for (let j = 0; j < children.length; ++j) {\n                ancestors[children[j]] = (ancestors[children[j]] || []).concat(node);\n            }\n        }\n\n        // Topo sort\n\n        const visited = {};\n        const sorted = [];\n\n        for (let i = 0; i < this._items.length; ++i) {          // Really looping thru item.seq values out of order\n            let next = i;\n\n            if (ancestors[i]) {\n                next = null;\n                for (let j = 0; j < this._items.length; ++j) {  // As above, these are item.seq values\n                    if (visited[j] === true) {\n                        continue;\n                    }\n\n                    if (!ancestors[j]) {\n                        ancestors[j] = [];\n                    }\n\n                    const shouldSeeCount = ancestors[j].length;\n                    let seenCount = 0;\n                    for (let k = 0; k < shouldSeeCount; ++k) {\n                        if (visited[ancestors[j][k]]) {\n                            ++seenCount;\n                        }\n                    }\n\n                    if (seenCount === shouldSeeCount) {\n                        next = j;\n                        break;\n                    }\n                }\n            }\n\n            if (next !== null) {\n                visited[next] = true;\n                sorted.push(next);\n            }\n        }\n\n        if (sorted.length !== this._items.length) {\n            return new Error('Invalid dependencies');\n        }\n\n        const seqIndex = {};\n        for (let i = 0; i < this._items.length; ++i) {\n            const item = this._items[i];\n            seqIndex[item.seq] = item;\n        }\n\n        const sortedNodes = [];\n        this._items = sorted.map((value) => {\n\n            const sortedItem = seqIndex[value];\n            sortedNodes.push(sortedItem.node);\n            return sortedItem;\n        });\n\n        this.nodes = sortedNodes;\n    }\n};\n\ninternals.mergeSort = (a, b) => {\n\n    return a.sort === b.sort ? 0 : (a.sort < b.sort ? -1 : 1);\n};\n"]},"metadata":{},"sourceType":"script"}